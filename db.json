{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/weixin.png","path":"images/weixin.png","modified":0,"renderable":0},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":0,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/images/tree.png","path":"images/tree.png","modified":0,"renderable":0},{"_id":"source/images/mark_sweep.gif","path":"images/mark_sweep.gif","modified":0,"renderable":0},{"_id":"themes/jacman/source/assets/weixin.png","path":"assets/weixin.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/jacman/.gitignore","hash":"7d65523f2a5afb69d76824dd1dfa62a34faa3197","modified":1544018849561},{"_id":"themes/jacman/README.md","hash":"098545637b0aeb27b14707c15e429470c603d78d","modified":1510572588000},{"_id":"themes/jacman/README_zh.md","hash":"9c73931bca4883de13eedd4be254da547d4ca52e","modified":1510572588000},{"_id":"themes/jacman/LICENSE","hash":"931516aa36c53eb7843c83d82662eb50cc3c4367","modified":1544018849561},{"_id":"themes/jacman/_config.yml","hash":"31a529acc618e5d61a6eca2405cd5a9f29901da5","modified":1546850104444},{"_id":"themes/jacman/_config_me.yml","hash":"dc81ad6a6ac14211fe1613fadf132ff28236ea99","modified":1544018849563},{"_id":"source/_posts/css选择器.md","hash":"80599f8d193124a765922f0a770fd3067bb7bbba","modified":1546844051681},{"_id":"source/_posts/git submodule的使用.md","hash":"36c67f14f6343ae32aca679b02bc56bbea15d08c","modified":1545568293510},{"_id":"source/_posts/AJAX是什么.md","hash":"112058afe023b242764225b0e8151ad5eaea3c20","modified":1545568293508},{"_id":"source/_posts/JavaScript中的this.md","hash":"8afea39b45ebf2ef0ae6a2a334b71e746fe23656","modified":1546591045541},{"_id":"source/_posts/git的常用命令简介.md","hash":"a9b21fdde2fcfa94bc15310e53088841eeac75ca","modified":1545568293510},{"_id":"source/_posts/react最佳实践.md","hash":"36dae96e9c5c105cb8d46aa3dfb0f79d1ab1d97c","modified":1544018849559},{"_id":"source/_posts/树的深度遍历与广度遍历.md","hash":"01f207aaddb473118066ebb02a9f7d0bdf24846a","modified":1546589533525},{"_id":"source/_posts/正则表达式.md","hash":"d78ec24255502bde0488aaa8f9b9edb9b7abc296","modified":1546412040153},{"_id":"source/_posts/每日一题.md","hash":"9a22dbb95f8c9525aea2624357bcdce38442da4f","modified":1546842836768},{"_id":"source/about/index.md","hash":"c661819a1024574696706096ad297f1f259f4232","modified":1546849368764},{"_id":"themes/jacman/languages/default.yml","hash":"eea72d6138497287c0b3f4bd93e4f6f62b7aff37","modified":1544018849564},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"1f3b9d00dd4322352b0c9c82a76dc9865a616d41","modified":1544018849564},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"61a02ba818d641579a86fcd7f5926ab1e6ab5f70","modified":1544018849564},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1544018849571},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1544018849571},{"_id":"themes/jacman/layout/index.ejs","hash":"75cef2172c286994af412e11ab7f4f5a0daaf1f5","modified":1544018849571},{"_id":"themes/jacman/layout/layout.ejs","hash":"5b4289a4526899809b9c2facea535367ff51ba2b","modified":1544018849571},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1544018849572},{"_id":"themes/jacman/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1544018849572},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1544018849572},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1544018849572},{"_id":"themes/jacman/source/CNAME","hash":"a7d7367dbda80b03747a09e014f28072e97a1116","modified":1544018849573},{"_id":"source/images/weixin.png","hash":"859cd451ffc3becad71e2550cd0fe4130e070a6d","modified":1545835509748},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"697601996220fe0a0f9cd628be67dec3c86ae2aa","modified":1544018849565},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"2c7395e7563fe016521712a645c28a13f952d52a","modified":1544018849565},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"261ecacb8456f4cb972632b6a9103860fa63b9a3","modified":1544018849566},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"3e1f1d8dc38b1e17c523d1176f7ee503fc648045","modified":1510572588000},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"4cb855d91ece7f67b2ca0992fffa55472d0b9c93","modified":1544018849566},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"761941be4922cd3c177c8130296b909bf7db5c09","modified":1544018849566},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"5f80bf6c6ddcf8c28c4599cd1540b14b25d54f18","modified":1510572588000},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"8a52d0344d5bce1925cf586ed73c11192925209b","modified":1544018849566},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"d42994ac696f52ba99c1cbac382cd76d5b04a3e8","modified":1544018849567},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"18515612344ff048b9372b91b7eef6f3b143801f","modified":1510572588000},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6146ac37dfb4f8613090bc52b3fc8cfa911a186a","modified":1544018849567},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"1083824a6c6c3df02767f2f3b727aee78ebb76ec","modified":1544018849568},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"c4f527fff0070fbe65919053a16224412317f40d","modified":1544018849569},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"06ecddc8a9d40b480fe2e958af1dab857a9d5441","modified":1544018849569},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"b33b2b5d08f1d53a8de25a95f660f7f1cea7b3cb","modified":1544018849569},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"39ea6b7888406fbd1b4cf236ebd718e881493374","modified":1544018849569},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"c1fae96b5053da021bcc04ab2ce5c2c8d30de8a2","modified":1510572588000},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"bea5bb7cb9350b8af7d97a8d223af63a5b30ab78","modified":1544018849569},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"e3820c36169e88663e6c9177666b2904c1ce47e6","modified":1544018849570},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"d49a8d609c5fbafa9e7ad328163565af03306519","modified":1510572588000},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"e49868063439c2092cdf9a8ec82cc295b0e42f66","modified":1544018849570},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"0a4b5f2a2e36a1d504fe2e7c6c8372cbb4628aab","modified":1544018849570},{"_id":"themes/jacman/layout/_widget/sponsor.ejs","hash":"683d1a19b404ea2d67db37b22ec56b47dd0bd854","modified":1544018849570},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"7e82ad9c916b9ce871b2f65ce8f283c5ba47947b","modified":1544018849570},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"10a1001189d5c28ce6d42494563b9637c302b454","modified":1544018849570},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"a31c2b223d0feb2a227e203cac9e5d13b7d328a8","modified":1544018849571},{"_id":"themes/jacman/layout/_widget/weixin.ejs","hash":"90260bca4eb966d8288efa5c12fed8f987cb6f0f","modified":1546850441495},{"_id":"themes/jacman/source/css/style.styl","hash":"a0a45af186a72ae68979bf26f2a5d0d2303189ca","modified":1544018849578},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1544018849578},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1544018849579},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1544018849579},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1544018849579},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1544018849580},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1544018849580},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1544018849582},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1544018849583},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1544018849582},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1544018849584},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1544018849584},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1544018849586},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1544018849586},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1544018849588},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1544018849591},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1544018849591},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1544018849592},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1544018849593},{"_id":"themes/jacman/source/img/author.jpg","hash":"b03bdafababe1dd3bb533719518e0a2d66b51b9d","modified":1543979312000},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1544018849595},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1544018849596},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1544018849596},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1544018849596},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1544018849596},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1544018849596},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1544018849597},{"_id":"themes/jacman/source/img/favicon.ico","hash":"df5708b7258bd6e690d8883c954152c8636cfa65","modified":1543979312000},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1544018849597},{"_id":"themes/jacman/source/img/favicon.png","hash":"6658b5a8bbe2a31ceea767cdc28faedddd289285","modified":1544018849597},{"_id":"themes/jacman/source/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1544018849598},{"_id":"themes/jacman/source/img/logo.png","hash":"b03bdafababe1dd3bb533719518e0a2d66b51b9d","modified":1543979312000},{"_id":"themes/jacman/source/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1544018849598},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1544018849598},{"_id":"themes/jacman/source/js/jekyll-search.js","hash":"b80e71eb664e5ed8545a887a073aa9fc5ee3fca2","modified":1544018849599},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1544018849600},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1544018849600},{"_id":"themes/jacman/source/js/tagcloud.js","hash":"3adec98f4a68d40ecc2583769c48278a90421dd2","modified":1544018849600},{"_id":"themes/jacman/source/js/toc.js","hash":"0451f0c1dc475186067cc19afc20c8e9ad3f02d7","modified":1544018849600},{"_id":"themes/jacman/source/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1544018849600},{"_id":"themes/jacman/source/assets/weixin.png","hash":"859cd451ffc3becad71e2550cd0fe4130e070a6d","modified":1544018849574},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1544018849585},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1544018849590},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1544018849592},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1544018849599},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"b09e3acea7076e1f01dfe0c2295e19951ea09437","modified":1544018849567},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"0e37bababc8f4659f5b59a552a946b46d89e4158","modified":1544018849567},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"b12ec08a5845a3d8c01257614f1dfead879c87d2","modified":1544018849568},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"548c69c570d5aac567bc6f088e9ee0c02223b088","modified":1510572588000},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fafc2501d7e65983b0f5c2b58151ca12e57c0574","modified":1544018849568},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"36a705942b691abe0d643ea8afa339981b32f6f2","modified":1510572588000},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"d7f5960039ac74924559ab6ba03c64457b8f0966","modified":1544018849568},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"7de9c07a4c968429a8088c31a28b7f3a993ded1b","modified":1544018849568},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"c8a0faf43b08e37ad07a5669db76d595da966159","modified":1544018849574},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"f016180726019927b9a835ed01e04d153f27a149","modified":1510572588000},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"cb652eb83c28a208743fabab92de896f8b7cbf7b","modified":1544018849575},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"c69641b4a34a8c62986b335414413dbde26de25e","modified":1544018849576},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"506fde1d67ce750452cbe84bee01a19c7d027c5e","modified":1544018849576},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"e85f1192283f043115c272a9deb3cb6ced793990","modified":1544018849576},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"1911613a19b605a58f801c21b03b5d4c83b90f9c","modified":1510572588000},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"7246809f4ce3166ec1b259bf475cae1a48e29aad","modified":1544018849577},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"5121ceb712be3f2dde98b8b6e589b546e19eab8f","modified":1510572588000},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"1136600932b97534b88465bf05ef313630b2de3d","modified":1544018849577},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"a72ff14effd276015264f870f47ed8f8413bf5d3","modified":1544018849577},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"96363d7c5aaed5f649667fc0752a62620a67e872","modified":1544018849578},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1544018849580},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1544018849580},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1544018849581},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1544018849581},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1544018849581},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1544018849581},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1510572588000},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1544018849589},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"91b62bfc58390b0d5db782a75be6965ee3665eb3","modified":1544018849575},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"e3a59bd427ba37a54ead9eeba9a5356b3f720a48","modified":1544018849575},{"_id":"public/about/index.html","hash":"cd633e8b9108a1ce9d4ff674f1fc4adaf23c2839","modified":1546849438630},{"_id":"public/archives/index.html","hash":"e2a2b25b5dd073d7209000271522e3248b9d813f","modified":1546848605508},{"_id":"public/archives/2016/index.html","hash":"16d9576fa7ad7415bc060669e48f4660acf81c1a","modified":1546848605508},{"_id":"public/archives/2016/01/index.html","hash":"b5cc3dde6b081d0e835f4c3d36ef67e202048f6e","modified":1546848605508},{"_id":"public/archives/2016/06/index.html","hash":"39d787b4db339afde7258b5d7b983226fd9ef966","modified":1546848605508},{"_id":"public/archives/2016/07/index.html","hash":"1c3c28194d8c17e8bf162cce934725e1a43bc8d6","modified":1546848605508},{"_id":"public/archives/2017/index.html","hash":"c4fce52a6c553c9a733d2f7694dc9637215386aa","modified":1546848605509},{"_id":"public/archives/2017/01/index.html","hash":"30111e4e2eae06da3339ef8eb12f153600fd8aa7","modified":1546848605509},{"_id":"public/archives/2017/02/index.html","hash":"35c23d8613caee82e6ecfcf50ea5e8ae517d4f3a","modified":1546848605509},{"_id":"public/archives/2017/06/index.html","hash":"fa9611e5c264bf4d24075637c06078322a879ca1","modified":1546848605509},{"_id":"public/categories/network/index.html","hash":"2631b68df5319bd09502616e2d3e9ca7fe1b2e89","modified":1546848605507},{"_id":"public/categories/Git/index.html","hash":"d4c22974bc09b54266916b8aea87dac570da5c3d","modified":1546848605507},{"_id":"public/categories/react/index.html","hash":"29f31a5ad6f8cdccddd80aba4f07d4fa0cab4bb7","modified":1546848605508},{"_id":"public/categories/js/index.html","hash":"9eba78185f97b51b1ad044d36aab7a06ff7f7370","modified":1546848605508},{"_id":"public/categories/JS/index.html","hash":"c731ffb3da60619d9efefda4dd0757275fcd6b40","modified":1546848605508},{"_id":"public/categories/subject/index.html","hash":"793d0f3257e677b9688a8fc3212642ad64d26a35","modified":1546848605508},{"_id":"public/index.html","hash":"e0af8d873078481db16163a36fcd1002c5468194","modified":1546850447701},{"_id":"public/tags/network/index.html","hash":"e96789003a5fe320b42f01948c5572f7e0bf4da4","modified":1546848605509},{"_id":"public/tags/Git/index.html","hash":"06ca2ab19aee5e3ec9c25a0bdd296c9b9fb14514","modified":1546848605509},{"_id":"public/tags/js/index.html","hash":"f50f836c62bde00051c4a6bd4c0f3aff35ad38e2","modified":1546848605509},{"_id":"public/tags/react/index.html","hash":"d8e06093f9d9a9c3a59a53380ba78fc890dac1bd","modified":1546848605509},{"_id":"public/tags/JS/index.html","hash":"dea9775eecfa3584b169fe49c799b1d3cb1360e2","modified":1546848605510},{"_id":"public/tags/subject/index.html","hash":"281ae8f2760ed7ee2fd8fe8d2a97e6afd5af78a5","modified":1546848605510},{"_id":"public/2017/06/27/树的深度遍历与广度遍历/index.html","hash":"5c94b3b974f3a98f91c2bcd39236e45caca0a742","modified":1546850447712},{"_id":"public/2017/06/20/react最佳实践/index.html","hash":"8ca0a08999b9b189d50e2fc7183056271ac994ed","modified":1546850447712},{"_id":"public/2017/02/25/正则表达式/index.html","hash":"b81073eacae935c6402d1153e3e6b7fd8bd34d50","modified":1546850447712},{"_id":"public/2017/01/04/每日一题/index.html","hash":"f9d60abfad07cfcbd0c23e8fecc3407e43e0e478","modified":1546850447712},{"_id":"public/2016/07/24/git submodule的使用/index.html","hash":"319e752bee1e84359370b51c254eafa6633d797f","modified":1546850447712},{"_id":"public/2016/06/24/git的常用命令简介/index.html","hash":"b80d90fc2e52cd9a9524227dc7cbf8b6fff3c343","modified":1546850447713},{"_id":"public/2016/01/02/JavaScript中的this/index.html","hash":"04b45a3de323153af6484a4a2afe9ba655e3b3aa","modified":1546850447713},{"_id":"public/2016/01/01/css选择器/index.html","hash":"319bd42454b19c2ba777ff03488228c71c180f16","modified":1546843635399},{"_id":"public/2016/01/01/AJAX是什么/index.html","hash":"795783c7a642597488bd09116b3f51ec5183816a","modified":1546850447713},{"_id":"source/images/tree.png","hash":"640976db930bcfa6f633bd2c58bceb8f663d31d8","modified":1546221266516},{"_id":"public/images/tree.png","hash":"640976db930bcfa6f633bd2c58bceb8f663d31d8","modified":1546848605520},{"_id":"source/_posts/JS常用函数.md","hash":"4668bfa4286fb45885358a0a1939c95bd64dfd46","modified":1545897948000},{"_id":"source/_posts/伪类与伪元素的区别.md","hash":"d49faedbdf3a020034051d500fb46fd8313e8763","modified":1546585162371},{"_id":"source/_posts/nginx配置.md","hash":"033543daab0b92caf015297e6c882b85ebdc0d9e","modified":1545967116000},{"_id":"source/_posts/排序方法.md","hash":"9c1970476831f2b642014d493525288a62b8d68a","modified":1546050481000},{"_id":"source/images/mark_sweep.gif","hash":"0764d470b0b57e6b13d8b3acdc2548748bcbefc3","modified":1546842727733},{"_id":"public/2018/12/27/JS常用函数/index.html","hash":"ae96a1e680df398596cfbf95f4dabf1ada022495","modified":1546843635288},{"_id":"public/2017/06/20/排序方法/index.html","hash":"4eff40764d570067f0c800d7f30c6d3aa12bfcce","modified":1546843635289},{"_id":"public/archives/page/2/index.html","hash":"12eed7a564ef6a150638f0c98755acd1a6b13a19","modified":1546848605508},{"_id":"public/archives/2018/index.html","hash":"f59b8f4032756efdfe0f614cc8ca193e6e434754","modified":1546843635441},{"_id":"public/archives/2018/12/index.html","hash":"7100d4354f817ce6784fb4cdd5abaa17dba006d2","modified":1546843635442},{"_id":"public/page/2/index.html","hash":"0c36b8966952a341c37291d2013a5fe2b85760ce","modified":1546850447701},{"_id":"public/2018/12/28/nginx配置/index.html","hash":"b625170be0bb127f76048dc28d6d45dbfac9e477","modified":1546842849489},{"_id":"public/2017/06/20/伪类与伪元素的区别/index.html","hash":"82c22f67513f29b4869477e845fb848139027934","modified":1546850447712},{"_id":"public/images/weixin.png","hash":"859cd451ffc3becad71e2550cd0fe4130e070a6d","modified":1546848606087},{"_id":"public/images/mark_sweep.gif","hash":"0764d470b0b57e6b13d8b3acdc2548748bcbefc3","modified":1546848606103},{"_id":"source/_posts/10.nginx基本配置及常用命令.md","hash":"7e1f76f69ca47302270324a21c632c4b29e6c5e3","modified":1546843948300},{"_id":"public/categories/server/index.html","hash":"e285b1926c790b0acb41a955ca0166dd42df1f6e","modified":1546848605508},{"_id":"public/tags/server/index.html","hash":"972c0d3c90136eec8de64ac8725d5f3a6ac92985","modified":1546848605510},{"_id":"public/archives/2017/10/index.html","hash":"e307e246959bfc3f6b0192135ba5c6873956ffde","modified":1546848605509},{"_id":"public/2017/10/11/10.nginx基本配置及常用命令/index.html","hash":"7a2bbac242bcf0c230a4de2503ad2df0524efc61","modified":1546850447712},{"_id":"source/_posts/JS常用方法.md","hash":"9c3740f5d3b1c972fcd2e33c5698966365729fe5","modified":1546844144953},{"_id":"public/archives/2016/05/index.html","hash":"d7f11a8804179f258f5708216223d86261df8620","modified":1546848605508},{"_id":"public/tags/css/index.html","hash":"d9f3fb54c024471535e794b8764d8b2215b180f3","modified":1546848605510},{"_id":"public/categories/css/index.html","hash":"b3fde8780bb7e3c5a21cabea09208161f14b4443","modified":1546848605508},{"_id":"public/2016/05/05/css选择器/index.html","hash":"73b8667f79005422b100b24044ffe5533dd886cb","modified":1546850447713},{"_id":"public/2016/06/05/JS常用方法/index.html","hash":"0f950f736f9495c01acd0fdbe0fb90fe49fe5bec","modified":1546850447713},{"_id":"public/CNAME","hash":"a7d7367dbda80b03747a09e014f28072e97a1116","modified":1546845234878},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1546848605518},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1546848605518},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1546848605518},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1546848605518},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1546848605518},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1546848605518},{"_id":"public/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1546848605518},{"_id":"public/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1546848605518},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1546848605518},{"_id":"public/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1546848605519},{"_id":"public/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1546848605518},{"_id":"public/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1546848605518},{"_id":"public/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1546848605519},{"_id":"public/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1546848605519},{"_id":"public/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1546848605519},{"_id":"public/img/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1546848605519},{"_id":"public/img/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1546848605519},{"_id":"public/img/author.jpg","hash":"b03bdafababe1dd3bb533719518e0a2d66b51b9d","modified":1546849762970},{"_id":"public/img/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1546848605519},{"_id":"public/img/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1546848605519},{"_id":"public/img/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1546848605519},{"_id":"public/img/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1546848605519},{"_id":"public/img/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1546848605519},{"_id":"public/img/favicon.ico","hash":"df5708b7258bd6e690d8883c954152c8636cfa65","modified":1546848605520},{"_id":"public/img/jacman.jpg","hash":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1546848605520},{"_id":"public/img/favicon.png","hash":"6658b5a8bbe2a31ceea767cdc28faedddd289285","modified":1546848605520},{"_id":"public/img/logo.png","hash":"b03bdafababe1dd3bb533719518e0a2d66b51b9d","modified":1546848605520},{"_id":"public/img/logo.svg","hash":"9ae38f7225c38624faeb7b74996efa9de7bf065b","modified":1546848605520},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1546848605520},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1546848605520},{"_id":"public/font/coveredbyyourgrace-webfont.svg","hash":"eabdb262d8e246865dfb56031f01ff6e8d2f9d53","modified":1546848606088},{"_id":"public/assets/weixin.png","hash":"859cd451ffc3becad71e2550cd0fe4130e070a6d","modified":1546848606090},{"_id":"public/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1546848606090},{"_id":"public/font/fontdiao.svg","hash":"334a94e6a66a8b089be7315d876bec93efe38d2b","modified":1546848606090},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1546848606095},{"_id":"public/js/gallery.js","hash":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed","modified":1546848606096},{"_id":"public/js/jquery.imagesloaded.min.js","hash":"4109837b1f6477bacc6b095a863b1b95b1b3693f","modified":1546848606096},{"_id":"public/js/tagcloud.js","hash":"3adec98f4a68d40ecc2583769c48278a90421dd2","modified":1546845235446},{"_id":"public/js/totop.js","hash":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb","modified":1546848606096},{"_id":"public/js/toc.js","hash":"0451f0c1dc475186067cc19afc20c8e9ad3f02d7","modified":1546845235446},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1546848606096},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1546848606096},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1546848606096},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1546848606096},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1546848606096},{"_id":"public/css/style.css","hash":"5b045ae09d68300cdf1154487910bec1d8534f85","modified":1546848606096},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1546848606096},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1546848606096},{"_id":"public/js/jekyll-search.js","hash":"b80e71eb664e5ed8545a887a073aa9fc5ee3fca2","modified":1546845235446},{"_id":"public/js/jquery.qrcode-0.12.0.min.js","hash":"57c3987166a26415a71292162690e82c21e315ad","modified":1546848606096},{"_id":"public/js/jquery-2.0.3.min.js","hash":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d","modified":1546848606097},{"_id":"public/img/banner.jpg","hash":"650f9ffce2ba4a7d73defc464e483daf048edd07","modified":1546845235446},{"_id":"public/font/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1546848606100},{"_id":"themes/jacman/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1546848147637}],"Category":[{"name":"network","_id":"cjq5aqcs80003dsztuwimd86j"},{"name":"Git","_id":"cjq5aqcse0008dsztab1j56j7"},{"name":"js","_id":"cjq5aqcsq000jdsztj6v2m01x"},{"name":"react","_id":"cjq5aqcsu000rdsztep33l3qa"},{"name":"JS","_id":"cjq5aqcsx000zdszt74bake0p"},{"name":"subject","_id":"cjq5aqcsy0014dsztbgosh6ap"},{"name":"server","_id":"cjqlycze000024a0ryilafhin"},{"name":"css","_id":"cjqlz47k10003d10rn6jw6u55"}],"Data":[],"Page":[{"layout":"page","type":"page","title":"About me","_content":"\n80末程序员...\n微信:\n![](images/weixin.png)","source":"about/index.md","raw":"---\nlayout: page\ntype: page\ntitle: About me\n---\n\n80末程序员...\n微信:\n![](images/weixin.png)","date":"2019-01-07T08:22:48.764Z","updated":"2019-01-07T08:22:48.764Z","path":"about/index.html","_id":"cjq5aqcs50001dsztufqcoqfd","comments":1,"content":"<p>80末程序员…<br>微信:<br><img src=\"images/weixin.png\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>80末程序员…<br>微信:<br><img src=\"images/weixin.png\" alt=\"\"></p>\n"}],"Post":[{"layout":"post","title":"css选择器","tagline":"Supporting tagline","description":null,"date":"2016-05-05T10:10:20.000Z","_content":"\n### 基本选择器\n\n- `*`: 通配符，匹配任何元素\n  例：`* { color: red }`\n\n- `#id`: id选择器\n  例：匹配所有id属性为app的元素\n  `#app { color: red }`\n\n- `.class`: class选择器\n  匹配所有class属性为btn的元素\n  例：`.btn { color: red }`\n\n- `element`: 元素选择器\n  匹配所有div标签\n  例：`div { color: red }`\n\n优先级: `#` > `.` > `element` `*`\n\n\n### 属性选择器\n\nHTML:\n```\n  <div title=\"myBtn Button\" lang=\"en-us\" />\n```\nCSS 2.1\n- `[attribute]`: 匹配所有带有attribute属性的元素\n  `[title] { color: red; }`\n\n- `[attribute=\"x\"]`: 匹配所有attribute属性为x的元素\n  `[title=myBtn] { color: red; }`\n\n- `[attribute~=\"x\"]`: 匹配所有attribute属性具有多个空格分隔的值，其中一个值等于x的元素\n  `[title~=\"Button\"] { color: red; }`\n\n- `[attribute|=\"x\"]`: 匹配所有attribute属性具有连字符`-`分隔的值，其中一个值以x开头的元素\n\n  `[lang|=\"en\"] { color: red; }`\n\n\nCSS 3\n- `[attribute^=\"x\"]`: 匹配属性attribute的值以x开头的元素\n  `[title^=my] { color: red; }`\n\n- `[attribute$=\"x\"]`: 匹配属性attribute的值以x结尾的元素\n  `[title$=Button] { color: red; }`\n\n- `[attribute*=\"x\"]`: 匹配属性attribute的值包含x的元素\n    `[title*=Btn] { color: red; }`\n\n\n### 伪类选择器\n\nHTML：\n```\n<div>\n  <a lang=\"en\" href=\"http://xinghunm.com\" target=\"_blank\">Xinghunm.com</a>\n</div>\n```\n\nCSS 2.1\n以下的E、F指selector匹配到的元素，其本身就是selector。\n\n- `E:first-child`: 匹配元素E当它是其父元素的第一个子元素\n  `a:first-child { color: red; }`\n\n- `E:link`: 匹配未被访问(未点击或跳转)的元素\n  `a:link { color: black; }`\n\n- `E:visited`: 匹配未被访问(未跳转)的元素\n  `a:visited { color: green; }`\n\n- `E:hover`: 匹配鼠标悬停其上的元素\n  `:hover`必须在:link和:visited之后才能看到效果。\n  `a:hover { color: blue; }`\n\n- `E:active`: 匹配鼠标按下还未抬起的元素\n  `:active`必须在`:hover`之后才能看到效果。\n  `a:active { color: red; }`\n\n- `E:focus`: 匹配获取当前焦点的元素\n  `a:focus { color: yellow; }`\n\n- `E:lang(x)`: 匹配lang属性等于x的元素\n  `a:lang(en) { color: red; }`\n\n\nCSS 3\n\nHTML：\n```\n  <div>\n      <h1>this is h1</h1>\n      <h3>first-of-type h3</h3>\n      <h3>last-of-type h3</h3>\n      <ul>\n          <li><a href=\"#tab1\">tab1</a></li>\n          <li><a href=\"#tab2\">tab2</a></li>\n      </ul>\n      <div id=\"tab1\">this is tab1</div>\n      <div id=\"tab2\">this is tab2</div>\n      <p><span>only child</span></p>\n      <p></p>\n  </div>\n```\n\n- `E:target`: URL后跟锚点#，指向文档内某个具体的元素，这个被链接的元素就是目标元素，       `E:target`选择器用于选取当前活动的目标元素\n  当我们点击列表tab1时，因为其锚点链接的元素就是id为tab1的元素，所以此时活动的目标元素就是id为tab1的div，通过div:target就可以获取此目标元素。\n  `div:target { background: red; }`\n\n- `:not(selector)`: 匹配与selector选择器描述不相符的元素\n  `div :not(div) { color: red; }`\n\n**结构性伪类**\n- `:root`: 匹配根元素，对应HTML文档就是html元素\n  `:root { color: red; }`\n\n- `E:nth-child(n)`: 匹配元素E当它是其父元素的第n(从1开始)个子元素\n  列表tab1是其父元素ul的第一个元素，因此可以匹配到列表tab1\n  `li:nth-child(1) { color: red; }`\n\n- `E:nth-last-child(n)`: 匹配元素E当它是其父元素的倒数第n(从1开始)个子元素\n  列表tab2是其父元素ul的倒数第一个子元素，因此可以匹配到列表tab2\n  `li:nth-last-child(1) { color: red; }`\n\n- `E:last-child`: 匹配元素E当它是其父元素的倒数第1个子元素\n  `li:last-child() { color: red; }`\n\n- `E:only-child`: 匹配元素E当它是其父元素的唯一一个子元素\n  `span:only-child() { color: red; }`\n\n- `E:nth-of-type(n)`: 匹配元素E当它是其父元素的第n(从1开始)个出现的与E类型相同的子元素\n  匹配`<div id=\"tab2\">this is tab2</div>`\n  `div:nth-of-type(2) { color: red; }`\n\n- `E:nth-last-of-type(n)`: 匹配元素E当它是其父元素的倒数第n(从1开始)个出现的与E类型相同的子元素\n  匹配`<div id=\"tab1\">this is tab1</div>`\n  `div:nth-last-of-type(2) { color: red; }`\n\n- `E:first-of-type`: 匹配元素E当它是其父元素的第1个出现的与E类型相同的元素子元素(可能有多个)\n  `h3:first-of-type { color: red; }`\n\n- `E:last-of-type`: 匹配元素E当它是其父元素的倒数第1个出现的与E类型相同的元素子元素(可能有多个)\n  `h3:last-of-type { color: red; }`\n\n- `E:only-of-type`: 匹配元素E当它是其父元素下唯一一个E类型的元素\n  `h1:only-of-type { color: red; }`\n\n- `E:empty`: 匹配元素E当没有子元素或内容时\n  `p:empty{ color: red; }`\n\n\n\n### 伪元素选择器\n\nHTML：\n```\n <div>\n   <p>12<br>34</p>\n </div>\n```\n\nCSS 2.1\n\n- `::first-line`: 匹配元素的第一行\n  `p::first-line { color: red; }`\n\n- `::first-letter`: 匹配元素的第一个字母\n  `p::first-letter { color: red; }`\n\n- `::before`: 在元素前通过content属性插入内容\n  `p::before {  content: \"*\"; }`\n\n- `::after`: 在元素后通过content属性插入内容\n  `p::after {  content: \"*\"; }`\n\n\n### 多级选择器\n\nHTML:\n```\n  <div id=\"div1\">\n      <div id=\"div2\">\n        <h1>this is dev2 > h1</h1>\n        <h2>this is dev2 > h2</h2>\n      </div>\n       <div id=\"div3\">this is dev3</div>\n       <div id=\"div4\">this is dev4</div>\n       <h1>this is div1 > h1</h1>\n    </div>\n```\n- `E, F`: 多元素选择器，同时匹配E元素和F元素\n  `h1, h2 { color: red; }`\n\n- `E > F`: 子元素选择器，匹配E元素的子元素F\n  `#div2 > h1 { color: red; }`\n\n- `E  F`: 后代元素选择器，匹配E元素的后代元素F\n  `#div1 h2 { color: red; }`\n\n- `E + F`: 相邻元素选择器，匹配所有紧随E元素之后的F元素\n  匹配div3\n  `#div2 + div { color: red; }`\n\n- `E ~ F`: 同级元素选择器，匹配所有E元素之后的同级元素F\n  匹配div3，div4\n  `#div2 ~ div { color: red; }`\n\n### 优先级\n`!important > 行内样式 > ID > 类、伪类、属性 > 标签名 > 继承 > 通配符`","source":"_posts/css选择器.md","raw":"---\nlayout: post\ntitle: css选择器\ncategory : css\ntagline: \"Supporting tagline\"\ntags : [css]\ndescription: \ndate: 2016-5-05 18:10:20\n---\n\n### 基本选择器\n\n- `*`: 通配符，匹配任何元素\n  例：`* { color: red }`\n\n- `#id`: id选择器\n  例：匹配所有id属性为app的元素\n  `#app { color: red }`\n\n- `.class`: class选择器\n  匹配所有class属性为btn的元素\n  例：`.btn { color: red }`\n\n- `element`: 元素选择器\n  匹配所有div标签\n  例：`div { color: red }`\n\n优先级: `#` > `.` > `element` `*`\n\n\n### 属性选择器\n\nHTML:\n```\n  <div title=\"myBtn Button\" lang=\"en-us\" />\n```\nCSS 2.1\n- `[attribute]`: 匹配所有带有attribute属性的元素\n  `[title] { color: red; }`\n\n- `[attribute=\"x\"]`: 匹配所有attribute属性为x的元素\n  `[title=myBtn] { color: red; }`\n\n- `[attribute~=\"x\"]`: 匹配所有attribute属性具有多个空格分隔的值，其中一个值等于x的元素\n  `[title~=\"Button\"] { color: red; }`\n\n- `[attribute|=\"x\"]`: 匹配所有attribute属性具有连字符`-`分隔的值，其中一个值以x开头的元素\n\n  `[lang|=\"en\"] { color: red; }`\n\n\nCSS 3\n- `[attribute^=\"x\"]`: 匹配属性attribute的值以x开头的元素\n  `[title^=my] { color: red; }`\n\n- `[attribute$=\"x\"]`: 匹配属性attribute的值以x结尾的元素\n  `[title$=Button] { color: red; }`\n\n- `[attribute*=\"x\"]`: 匹配属性attribute的值包含x的元素\n    `[title*=Btn] { color: red; }`\n\n\n### 伪类选择器\n\nHTML：\n```\n<div>\n  <a lang=\"en\" href=\"http://xinghunm.com\" target=\"_blank\">Xinghunm.com</a>\n</div>\n```\n\nCSS 2.1\n以下的E、F指selector匹配到的元素，其本身就是selector。\n\n- `E:first-child`: 匹配元素E当它是其父元素的第一个子元素\n  `a:first-child { color: red; }`\n\n- `E:link`: 匹配未被访问(未点击或跳转)的元素\n  `a:link { color: black; }`\n\n- `E:visited`: 匹配未被访问(未跳转)的元素\n  `a:visited { color: green; }`\n\n- `E:hover`: 匹配鼠标悬停其上的元素\n  `:hover`必须在:link和:visited之后才能看到效果。\n  `a:hover { color: blue; }`\n\n- `E:active`: 匹配鼠标按下还未抬起的元素\n  `:active`必须在`:hover`之后才能看到效果。\n  `a:active { color: red; }`\n\n- `E:focus`: 匹配获取当前焦点的元素\n  `a:focus { color: yellow; }`\n\n- `E:lang(x)`: 匹配lang属性等于x的元素\n  `a:lang(en) { color: red; }`\n\n\nCSS 3\n\nHTML：\n```\n  <div>\n      <h1>this is h1</h1>\n      <h3>first-of-type h3</h3>\n      <h3>last-of-type h3</h3>\n      <ul>\n          <li><a href=\"#tab1\">tab1</a></li>\n          <li><a href=\"#tab2\">tab2</a></li>\n      </ul>\n      <div id=\"tab1\">this is tab1</div>\n      <div id=\"tab2\">this is tab2</div>\n      <p><span>only child</span></p>\n      <p></p>\n  </div>\n```\n\n- `E:target`: URL后跟锚点#，指向文档内某个具体的元素，这个被链接的元素就是目标元素，       `E:target`选择器用于选取当前活动的目标元素\n  当我们点击列表tab1时，因为其锚点链接的元素就是id为tab1的元素，所以此时活动的目标元素就是id为tab1的div，通过div:target就可以获取此目标元素。\n  `div:target { background: red; }`\n\n- `:not(selector)`: 匹配与selector选择器描述不相符的元素\n  `div :not(div) { color: red; }`\n\n**结构性伪类**\n- `:root`: 匹配根元素，对应HTML文档就是html元素\n  `:root { color: red; }`\n\n- `E:nth-child(n)`: 匹配元素E当它是其父元素的第n(从1开始)个子元素\n  列表tab1是其父元素ul的第一个元素，因此可以匹配到列表tab1\n  `li:nth-child(1) { color: red; }`\n\n- `E:nth-last-child(n)`: 匹配元素E当它是其父元素的倒数第n(从1开始)个子元素\n  列表tab2是其父元素ul的倒数第一个子元素，因此可以匹配到列表tab2\n  `li:nth-last-child(1) { color: red; }`\n\n- `E:last-child`: 匹配元素E当它是其父元素的倒数第1个子元素\n  `li:last-child() { color: red; }`\n\n- `E:only-child`: 匹配元素E当它是其父元素的唯一一个子元素\n  `span:only-child() { color: red; }`\n\n- `E:nth-of-type(n)`: 匹配元素E当它是其父元素的第n(从1开始)个出现的与E类型相同的子元素\n  匹配`<div id=\"tab2\">this is tab2</div>`\n  `div:nth-of-type(2) { color: red; }`\n\n- `E:nth-last-of-type(n)`: 匹配元素E当它是其父元素的倒数第n(从1开始)个出现的与E类型相同的子元素\n  匹配`<div id=\"tab1\">this is tab1</div>`\n  `div:nth-last-of-type(2) { color: red; }`\n\n- `E:first-of-type`: 匹配元素E当它是其父元素的第1个出现的与E类型相同的元素子元素(可能有多个)\n  `h3:first-of-type { color: red; }`\n\n- `E:last-of-type`: 匹配元素E当它是其父元素的倒数第1个出现的与E类型相同的元素子元素(可能有多个)\n  `h3:last-of-type { color: red; }`\n\n- `E:only-of-type`: 匹配元素E当它是其父元素下唯一一个E类型的元素\n  `h1:only-of-type { color: red; }`\n\n- `E:empty`: 匹配元素E当没有子元素或内容时\n  `p:empty{ color: red; }`\n\n\n\n### 伪元素选择器\n\nHTML：\n```\n <div>\n   <p>12<br>34</p>\n </div>\n```\n\nCSS 2.1\n\n- `::first-line`: 匹配元素的第一行\n  `p::first-line { color: red; }`\n\n- `::first-letter`: 匹配元素的第一个字母\n  `p::first-letter { color: red; }`\n\n- `::before`: 在元素前通过content属性插入内容\n  `p::before {  content: \"*\"; }`\n\n- `::after`: 在元素后通过content属性插入内容\n  `p::after {  content: \"*\"; }`\n\n\n### 多级选择器\n\nHTML:\n```\n  <div id=\"div1\">\n      <div id=\"div2\">\n        <h1>this is dev2 > h1</h1>\n        <h2>this is dev2 > h2</h2>\n      </div>\n       <div id=\"div3\">this is dev3</div>\n       <div id=\"div4\">this is dev4</div>\n       <h1>this is div1 > h1</h1>\n    </div>\n```\n- `E, F`: 多元素选择器，同时匹配E元素和F元素\n  `h1, h2 { color: red; }`\n\n- `E > F`: 子元素选择器，匹配E元素的子元素F\n  `#div2 > h1 { color: red; }`\n\n- `E  F`: 后代元素选择器，匹配E元素的后代元素F\n  `#div1 h2 { color: red; }`\n\n- `E + F`: 相邻元素选择器，匹配所有紧随E元素之后的F元素\n  匹配div3\n  `#div2 + div { color: red; }`\n\n- `E ~ F`: 同级元素选择器，匹配所有E元素之后的同级元素F\n  匹配div3，div4\n  `#div2 ~ div { color: red; }`\n\n### 优先级\n`!important > 行内样式 > ID > 类、伪类、属性 > 标签名 > 继承 > 通配符`","slug":"css选择器","published":1,"updated":"2019-01-07T06:54:11.681Z","_id":"cjq5aqcs00000dsztlxq3nxiu","comments":1,"photos":[],"link":"","content":"<h3 id=\"基本选择器\"><a href=\"#基本选择器\" class=\"headerlink\" title=\"基本选择器\"></a>基本选择器</h3><ul>\n<li><p><code>*</code>: 通配符，匹配任何元素<br>例：<code>* { color: red }</code></p>\n</li>\n<li><p><code>#id</code>: id选择器<br>例：匹配所有id属性为app的元素<br><code>#app { color: red }</code></p>\n</li>\n<li><p><code>.class</code>: class选择器<br>匹配所有class属性为btn的元素<br>例：<code>.btn { color: red }</code></p>\n</li>\n<li><p><code>element</code>: 元素选择器<br>匹配所有div标签<br>例：<code>div { color: red }</code></p>\n</li>\n</ul>\n<p>优先级: <code>#</code> &gt; <code>.</code> &gt; <code>element</code> <code>*</code></p>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>HTML:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div title=&quot;myBtn Button&quot; lang=&quot;en-us&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS 2.1</p>\n<ul>\n<li><p><code>[attribute]</code>: 匹配所有带有attribute属性的元素<br><code>[title] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute=&quot;x&quot;]</code>: 匹配所有attribute属性为x的元素<br><code>[title=myBtn] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute~=&quot;x&quot;]</code>: 匹配所有attribute属性具有多个空格分隔的值，其中一个值等于x的元素<br><code>[title~=&quot;Button&quot;] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute|=&quot;x&quot;]</code>: 匹配所有attribute属性具有连字符<code>-</code>分隔的值，其中一个值以x开头的元素</p>\n<p><code>[lang|=&quot;en&quot;] { color: red; }</code></p>\n</li>\n</ul>\n<p>CSS 3</p>\n<ul>\n<li><p><code>[attribute^=&quot;x&quot;]</code>: 匹配属性attribute的值以x开头的元素<br><code>[title^=my] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute$=&quot;x&quot;]</code>: 匹配属性attribute的值以x结尾的元素<br><code>[title$=Button] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute*=&quot;x&quot;]</code>: 匹配属性attribute的值包含x的元素<br>  <code>[title*=Btn] { color: red; }</code></p>\n</li>\n</ul>\n<h3 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h3><p>HTML：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;a lang=&quot;en&quot; href=&quot;http://xinghunm.com&quot; target=&quot;_blank&quot;&gt;Xinghunm.com&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS 2.1<br>以下的E、F指selector匹配到的元素，其本身就是selector。</p>\n<ul>\n<li><p><code>E:first-child</code>: 匹配元素E当它是其父元素的第一个子元素<br><code>a:first-child { color: red; }</code></p>\n</li>\n<li><p><code>E:link</code>: 匹配未被访问(未点击或跳转)的元素<br><code>a:link { color: black; }</code></p>\n</li>\n<li><p><code>E:visited</code>: 匹配未被访问(未跳转)的元素<br><code>a:visited { color: green; }</code></p>\n</li>\n<li><p><code>E:hover</code>: 匹配鼠标悬停其上的元素<br><code>:hover</code>必须在:link和:visited之后才能看到效果。<br><code>a:hover { color: blue; }</code></p>\n</li>\n<li><p><code>E:active</code>: 匹配鼠标按下还未抬起的元素<br><code>:active</code>必须在<code>:hover</code>之后才能看到效果。<br><code>a:active { color: red; }</code></p>\n</li>\n<li><p><code>E:focus</code>: 匹配获取当前焦点的元素<br><code>a:focus { color: yellow; }</code></p>\n</li>\n<li><p><code>E:lang(x)</code>: 匹配lang属性等于x的元素<br><code>a:lang(en) { color: red; }</code></p>\n</li>\n</ul>\n<p>CSS 3</p>\n<p>HTML：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;this is h1&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h3&gt;first-of-type h3&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;last-of-type h3&lt;/h3&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;a href=&quot;#tab1&quot;&gt;tab1&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;a href=&quot;#tab2&quot;&gt;tab2&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">    &lt;div id=&quot;tab1&quot;&gt;this is tab1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div id=&quot;tab2&quot;&gt;this is tab2&lt;/div&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;span&gt;only child&lt;/span&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>E:target</code>: URL后跟锚点#，指向文档内某个具体的元素，这个被链接的元素就是目标元素，       <code>E:target</code>选择器用于选取当前活动的目标元素<br>当我们点击列表tab1时，因为其锚点链接的元素就是id为tab1的元素，所以此时活动的目标元素就是id为tab1的div，通过div:target就可以获取此目标元素。<br><code>div:target { background: red; }</code></p>\n</li>\n<li><p><code>:not(selector)</code>: 匹配与selector选择器描述不相符的元素<br><code>div :not(div) { color: red; }</code></p>\n</li>\n</ul>\n<p><strong>结构性伪类</strong></p>\n<ul>\n<li><p><code>:root</code>: 匹配根元素，对应HTML文档就是html元素<br><code>:root { color: red; }</code></p>\n</li>\n<li><p><code>E:nth-child(n)</code>: 匹配元素E当它是其父元素的第n(从1开始)个子元素<br>列表tab1是其父元素ul的第一个元素，因此可以匹配到列表tab1<br><code>li:nth-child(1) { color: red; }</code></p>\n</li>\n<li><p><code>E:nth-last-child(n)</code>: 匹配元素E当它是其父元素的倒数第n(从1开始)个子元素<br>列表tab2是其父元素ul的倒数第一个子元素，因此可以匹配到列表tab2<br><code>li:nth-last-child(1) { color: red; }</code></p>\n</li>\n<li><p><code>E:last-child</code>: 匹配元素E当它是其父元素的倒数第1个子元素<br><code>li:last-child() { color: red; }</code></p>\n</li>\n<li><p><code>E:only-child</code>: 匹配元素E当它是其父元素的唯一一个子元素<br><code>span:only-child() { color: red; }</code></p>\n</li>\n<li><p><code>E:nth-of-type(n)</code>: 匹配元素E当它是其父元素的第n(从1开始)个出现的与E类型相同的子元素<br>匹配<code>&lt;div id=&quot;tab2&quot;&gt;this is tab2&lt;/div&gt;</code><br><code>div:nth-of-type(2) { color: red; }</code></p>\n</li>\n<li><p><code>E:nth-last-of-type(n)</code>: 匹配元素E当它是其父元素的倒数第n(从1开始)个出现的与E类型相同的子元素<br>匹配<code>&lt;div id=&quot;tab1&quot;&gt;this is tab1&lt;/div&gt;</code><br><code>div:nth-last-of-type(2) { color: red; }</code></p>\n</li>\n<li><p><code>E:first-of-type</code>: 匹配元素E当它是其父元素的第1个出现的与E类型相同的元素子元素(可能有多个)<br><code>h3:first-of-type { color: red; }</code></p>\n</li>\n<li><p><code>E:last-of-type</code>: 匹配元素E当它是其父元素的倒数第1个出现的与E类型相同的元素子元素(可能有多个)<br><code>h3:last-of-type { color: red; }</code></p>\n</li>\n<li><p><code>E:only-of-type</code>: 匹配元素E当它是其父元素下唯一一个E类型的元素<br><code>h1:only-of-type { color: red; }</code></p>\n</li>\n<li><p><code>E:empty</code>: 匹配元素E当没有子元素或内容时<br><code>p:empty{ color: red; }</code></p>\n</li>\n</ul>\n<h3 id=\"伪元素选择器\"><a href=\"#伪元素选择器\" class=\"headerlink\" title=\"伪元素选择器\"></a>伪元素选择器</h3><p>HTML：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;p&gt;12&lt;br&gt;34&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS 2.1</p>\n<ul>\n<li><p><code>::first-line</code>: 匹配元素的第一行<br><code>p::first-line { color: red; }</code></p>\n</li>\n<li><p><code>::first-letter</code>: 匹配元素的第一个字母<br><code>p::first-letter { color: red; }</code></p>\n</li>\n<li><p><code>::before</code>: 在元素前通过content属性插入内容<br><code>p::before {  content: &quot;*&quot;; }</code></p>\n</li>\n<li><p><code>::after</code>: 在元素后通过content属性插入内容<br><code>p::after {  content: &quot;*&quot;; }</code></p>\n</li>\n</ul>\n<h3 id=\"多级选择器\"><a href=\"#多级选择器\" class=\"headerlink\" title=\"多级选择器\"></a>多级选择器</h3><p>HTML:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div1&quot;&gt;</span><br><span class=\"line\">    &lt;div id=&quot;div2&quot;&gt;</span><br><span class=\"line\">      &lt;h1&gt;this is dev2 &gt; h1&lt;/h1&gt;</span><br><span class=\"line\">      &lt;h2&gt;this is dev2 &gt; h2&lt;/h2&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">     &lt;div id=&quot;div3&quot;&gt;this is dev3&lt;/div&gt;</span><br><span class=\"line\">     &lt;div id=&quot;div4&quot;&gt;this is dev4&lt;/div&gt;</span><br><span class=\"line\">     &lt;h1&gt;this is div1 &gt; h1&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>E, F</code>: 多元素选择器，同时匹配E元素和F元素<br><code>h1, h2 { color: red; }</code></p>\n</li>\n<li><p><code>E &gt; F</code>: 子元素选择器，匹配E元素的子元素F<br><code>#div2 &gt; h1 { color: red; }</code></p>\n</li>\n<li><p><code>E  F</code>: 后代元素选择器，匹配E元素的后代元素F<br><code>#div1 h2 { color: red; }</code></p>\n</li>\n<li><p><code>E + F</code>: 相邻元素选择器，匹配所有紧随E元素之后的F元素<br>匹配div3<br><code>#div2 + div { color: red; }</code></p>\n</li>\n<li><p><code>E ~ F</code>: 同级元素选择器，匹配所有E元素之后的同级元素F<br>匹配div3，div4<br><code>#div2 ~ div { color: red; }</code></p>\n</li>\n</ul>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p><code>!important &gt; 行内样式 &gt; ID &gt; 类、伪类、属性 &gt; 标签名 &gt; 继承 &gt; 通配符</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本选择器\"><a href=\"#基本选择器\" class=\"headerlink\" title=\"基本选择器\"></a>基本选择器</h3><ul>\n<li><p><code>*</code>: 通配符，匹配任何元素<br>例：<code>* { color: red }</code></p>\n</li>\n<li><p><code>#id</code>: id选择器<br>例：匹配所有id属性为app的元素<br><code>#app { color: red }</code></p>\n</li>\n<li><p><code>.class</code>: class选择器<br>匹配所有class属性为btn的元素<br>例：<code>.btn { color: red }</code></p>\n</li>\n<li><p><code>element</code>: 元素选择器<br>匹配所有div标签<br>例：<code>div { color: red }</code></p>\n</li>\n</ul>\n<p>优先级: <code>#</code> &gt; <code>.</code> &gt; <code>element</code> <code>*</code></p>\n<h3 id=\"属性选择器\"><a href=\"#属性选择器\" class=\"headerlink\" title=\"属性选择器\"></a>属性选择器</h3><p>HTML:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div title=&quot;myBtn Button&quot; lang=&quot;en-us&quot; /&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS 2.1</p>\n<ul>\n<li><p><code>[attribute]</code>: 匹配所有带有attribute属性的元素<br><code>[title] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute=&quot;x&quot;]</code>: 匹配所有attribute属性为x的元素<br><code>[title=myBtn] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute~=&quot;x&quot;]</code>: 匹配所有attribute属性具有多个空格分隔的值，其中一个值等于x的元素<br><code>[title~=&quot;Button&quot;] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute|=&quot;x&quot;]</code>: 匹配所有attribute属性具有连字符<code>-</code>分隔的值，其中一个值以x开头的元素</p>\n<p><code>[lang|=&quot;en&quot;] { color: red; }</code></p>\n</li>\n</ul>\n<p>CSS 3</p>\n<ul>\n<li><p><code>[attribute^=&quot;x&quot;]</code>: 匹配属性attribute的值以x开头的元素<br><code>[title^=my] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute$=&quot;x&quot;]</code>: 匹配属性attribute的值以x结尾的元素<br><code>[title$=Button] { color: red; }</code></p>\n</li>\n<li><p><code>[attribute*=&quot;x&quot;]</code>: 匹配属性attribute的值包含x的元素<br>  <code>[title*=Btn] { color: red; }</code></p>\n</li>\n</ul>\n<h3 id=\"伪类选择器\"><a href=\"#伪类选择器\" class=\"headerlink\" title=\"伪类选择器\"></a>伪类选择器</h3><p>HTML：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;a lang=&quot;en&quot; href=&quot;http://xinghunm.com&quot; target=&quot;_blank&quot;&gt;Xinghunm.com&lt;/a&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS 2.1<br>以下的E、F指selector匹配到的元素，其本身就是selector。</p>\n<ul>\n<li><p><code>E:first-child</code>: 匹配元素E当它是其父元素的第一个子元素<br><code>a:first-child { color: red; }</code></p>\n</li>\n<li><p><code>E:link</code>: 匹配未被访问(未点击或跳转)的元素<br><code>a:link { color: black; }</code></p>\n</li>\n<li><p><code>E:visited</code>: 匹配未被访问(未跳转)的元素<br><code>a:visited { color: green; }</code></p>\n</li>\n<li><p><code>E:hover</code>: 匹配鼠标悬停其上的元素<br><code>:hover</code>必须在:link和:visited之后才能看到效果。<br><code>a:hover { color: blue; }</code></p>\n</li>\n<li><p><code>E:active</code>: 匹配鼠标按下还未抬起的元素<br><code>:active</code>必须在<code>:hover</code>之后才能看到效果。<br><code>a:active { color: red; }</code></p>\n</li>\n<li><p><code>E:focus</code>: 匹配获取当前焦点的元素<br><code>a:focus { color: yellow; }</code></p>\n</li>\n<li><p><code>E:lang(x)</code>: 匹配lang属性等于x的元素<br><code>a:lang(en) { color: red; }</code></p>\n</li>\n</ul>\n<p>CSS 3</p>\n<p>HTML：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">    &lt;h1&gt;this is h1&lt;/h1&gt;</span><br><span class=\"line\">    &lt;h3&gt;first-of-type h3&lt;/h3&gt;</span><br><span class=\"line\">    &lt;h3&gt;last-of-type h3&lt;/h3&gt;</span><br><span class=\"line\">    &lt;ul&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;a href=&quot;#tab1&quot;&gt;tab1&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">        &lt;li&gt;&lt;a href=&quot;#tab2&quot;&gt;tab2&lt;/a&gt;&lt;/li&gt;</span><br><span class=\"line\">    &lt;/ul&gt;</span><br><span class=\"line\">    &lt;div id=&quot;tab1&quot;&gt;this is tab1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div id=&quot;tab2&quot;&gt;this is tab2&lt;/div&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;span&gt;only child&lt;/span&gt;&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>E:target</code>: URL后跟锚点#，指向文档内某个具体的元素，这个被链接的元素就是目标元素，       <code>E:target</code>选择器用于选取当前活动的目标元素<br>当我们点击列表tab1时，因为其锚点链接的元素就是id为tab1的元素，所以此时活动的目标元素就是id为tab1的div，通过div:target就可以获取此目标元素。<br><code>div:target { background: red; }</code></p>\n</li>\n<li><p><code>:not(selector)</code>: 匹配与selector选择器描述不相符的元素<br><code>div :not(div) { color: red; }</code></p>\n</li>\n</ul>\n<p><strong>结构性伪类</strong></p>\n<ul>\n<li><p><code>:root</code>: 匹配根元素，对应HTML文档就是html元素<br><code>:root { color: red; }</code></p>\n</li>\n<li><p><code>E:nth-child(n)</code>: 匹配元素E当它是其父元素的第n(从1开始)个子元素<br>列表tab1是其父元素ul的第一个元素，因此可以匹配到列表tab1<br><code>li:nth-child(1) { color: red; }</code></p>\n</li>\n<li><p><code>E:nth-last-child(n)</code>: 匹配元素E当它是其父元素的倒数第n(从1开始)个子元素<br>列表tab2是其父元素ul的倒数第一个子元素，因此可以匹配到列表tab2<br><code>li:nth-last-child(1) { color: red; }</code></p>\n</li>\n<li><p><code>E:last-child</code>: 匹配元素E当它是其父元素的倒数第1个子元素<br><code>li:last-child() { color: red; }</code></p>\n</li>\n<li><p><code>E:only-child</code>: 匹配元素E当它是其父元素的唯一一个子元素<br><code>span:only-child() { color: red; }</code></p>\n</li>\n<li><p><code>E:nth-of-type(n)</code>: 匹配元素E当它是其父元素的第n(从1开始)个出现的与E类型相同的子元素<br>匹配<code>&lt;div id=&quot;tab2&quot;&gt;this is tab2&lt;/div&gt;</code><br><code>div:nth-of-type(2) { color: red; }</code></p>\n</li>\n<li><p><code>E:nth-last-of-type(n)</code>: 匹配元素E当它是其父元素的倒数第n(从1开始)个出现的与E类型相同的子元素<br>匹配<code>&lt;div id=&quot;tab1&quot;&gt;this is tab1&lt;/div&gt;</code><br><code>div:nth-last-of-type(2) { color: red; }</code></p>\n</li>\n<li><p><code>E:first-of-type</code>: 匹配元素E当它是其父元素的第1个出现的与E类型相同的元素子元素(可能有多个)<br><code>h3:first-of-type { color: red; }</code></p>\n</li>\n<li><p><code>E:last-of-type</code>: 匹配元素E当它是其父元素的倒数第1个出现的与E类型相同的元素子元素(可能有多个)<br><code>h3:last-of-type { color: red; }</code></p>\n</li>\n<li><p><code>E:only-of-type</code>: 匹配元素E当它是其父元素下唯一一个E类型的元素<br><code>h1:only-of-type { color: red; }</code></p>\n</li>\n<li><p><code>E:empty</code>: 匹配元素E当没有子元素或内容时<br><code>p:empty{ color: red; }</code></p>\n</li>\n</ul>\n<h3 id=\"伪元素选择器\"><a href=\"#伪元素选择器\" class=\"headerlink\" title=\"伪元素选择器\"></a>伪元素选择器</h3><p>HTML：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;p&gt;12&lt;br&gt;34&lt;/p&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p>CSS 2.1</p>\n<ul>\n<li><p><code>::first-line</code>: 匹配元素的第一行<br><code>p::first-line { color: red; }</code></p>\n</li>\n<li><p><code>::first-letter</code>: 匹配元素的第一个字母<br><code>p::first-letter { color: red; }</code></p>\n</li>\n<li><p><code>::before</code>: 在元素前通过content属性插入内容<br><code>p::before {  content: &quot;*&quot;; }</code></p>\n</li>\n<li><p><code>::after</code>: 在元素后通过content属性插入内容<br><code>p::after {  content: &quot;*&quot;; }</code></p>\n</li>\n</ul>\n<h3 id=\"多级选择器\"><a href=\"#多级选择器\" class=\"headerlink\" title=\"多级选择器\"></a>多级选择器</h3><p>HTML:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;div1&quot;&gt;</span><br><span class=\"line\">    &lt;div id=&quot;div2&quot;&gt;</span><br><span class=\"line\">      &lt;h1&gt;this is dev2 &gt; h1&lt;/h1&gt;</span><br><span class=\"line\">      &lt;h2&gt;this is dev2 &gt; h2&lt;/h2&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">     &lt;div id=&quot;div3&quot;&gt;this is dev3&lt;/div&gt;</span><br><span class=\"line\">     &lt;div id=&quot;div4&quot;&gt;this is dev4&lt;/div&gt;</span><br><span class=\"line\">     &lt;h1&gt;this is div1 &gt; h1&lt;/h1&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p><code>E, F</code>: 多元素选择器，同时匹配E元素和F元素<br><code>h1, h2 { color: red; }</code></p>\n</li>\n<li><p><code>E &gt; F</code>: 子元素选择器，匹配E元素的子元素F<br><code>#div2 &gt; h1 { color: red; }</code></p>\n</li>\n<li><p><code>E  F</code>: 后代元素选择器，匹配E元素的后代元素F<br><code>#div1 h2 { color: red; }</code></p>\n</li>\n<li><p><code>E + F</code>: 相邻元素选择器，匹配所有紧随E元素之后的F元素<br>匹配div3<br><code>#div2 + div { color: red; }</code></p>\n</li>\n<li><p><code>E ~ F</code>: 同级元素选择器，匹配所有E元素之后的同级元素F<br>匹配div3，div4<br><code>#div2 ~ div { color: red; }</code></p>\n</li>\n</ul>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><p><code>!important &gt; 行内样式 &gt; ID &gt; 类、伪类、属性 &gt; 标签名 &gt; 继承 &gt; 通配符</code></p>\n"},{"layout":"post","title":"Git submodule的使用","tagline":"Supporting tagline","description":"最近在做一个上传的客户端，上传的部分由后端同学以SDK的方式提供，因此该SDK是在一个独立的仓库，那么对于客户端该如何方便的对集成该SDK呢？这就可以考虑用git的submodule。","date":"2016-07-24T15:30:09.000Z","_content":"\n### **遇到的问题**\n\n最近在做一个上传的客户端，上传的部分由后端同学以SDK的方式提供，因此该SDK是在一个独立的仓库，那么对于客户端该如何方便的集成该SDK呢？每次SDK更新把代码拷贝到客户端仓库？把SDK发布到npm？显然都不合理，这就可以考虑用git的submodule。\n\n### **什么是submodule**\n\nsubmodule是一个多项目管理工具，它允许将子项目以独立的git项目添加到主项目，而主项目以submodule的形式拥有子项目。子项目拥有自己的commit、push、pull，而与主项目互不干扰。主项目只需要记录子项目的地址和所需要的commit id，通过地址和commit id 就能够得到对应的子项目。\n\n### **添加submodule**\n通常情况下，我们都有一个主项目(MainProject)，在MainProject文件夹下执行如下命令，即可添加submodule。\n```\n$ git submodule add [url] [path]\n//url为子项目远程地址或本地地址, path为子项目路径，可省略\n例: git add submodule git@github.com:fengyueran/UploaderSDK.git ./src/UploaderSDK\n```\ngit status可以看到如下信息\n```\n On branch master\n    Changes to be committed:\n    \n        new file:   .gitmodules\n        new file:   UploaderSDK\n```\n可以看到多了两个个文件.gitmodules和UploaderSDK。\ncat .gitmodules看到.gitmodules储存了submodule的路径及远程地址。\n```\n[submodule \"src/uploaderSDK\"]\n\tpath = src/uploaderSDK\n\turl = git@github.com:fengyueran/UploaderSDK.git\n```\nUploaderSDK的内容为submodule的commit id。\n```\nSubproject commit 6b53e1840b27ca1587b96c1eb9dd5f4ff0866089\n```\n不难想象通过.gitmodules和UploaderSDK的信息就可以拿到submodule的内容了，因此我们需要提交这个两个文件。\n```\ngit add .\ngit commit -m \"add submodule\"\n```\n\n### **克隆带有submodule的项目**\n\n主要有两个方式\n\n**1. 采用先克隆后更新的方式**\n\n和想象中的不一样，直接clone主项目，submodule并不会跟着clone下来，而只有包含submodule名的空文件夹。\n```\n1）$ git clone git@github.com:fengyueran/MainProject.git\n```\n需再执行如下命令\n```\n2）$ git submodule init\n```\n输出如下，可以看到该命令给子项目注册了路径，即在主项目中的位置。此时，uploaderSDK文件夹仍未空。\n```\n    \n    Submodule 'src/uploaderSDK' (git@github.com:fengyueran/UploaderSDK.git) registered for path 'src/uploaderSDK'\n```\n\b再执行\n```\n//该命令\b并不是直接更新到最新的submodule commit，而是更新至主项目\b所存储存的commit(有可能是较旧的commit)。\n3）$ git submodule update\n```\n输出如下，可以看到sumodule得到更新，更新到主项目存储的submodule commit，是一个游离的git header。\n  ```\n  Cloning into '/Work/test/MainProject/tmp/MainProject/src/uploaderSDK'...\n\n  Submodule path 'src/uploaderSDK': checked out '6b53e1840b27ca1587b96c1eb9dd5f4ff0866089'\n  ```\n\n\n**2. 采用递归参数--recursive**\n\n```\ngit clone git@github.com:fengyueran/MainProject.git --recursive\n```\n输出如下，可以看到主项目包括submodule都被clone下来了。\n```\nCloning into 'MainProject'...\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (4/4), done.\nReceiving objects: 100% (7/7), done.\nremote: Total 7 (delta 0), reused 4 (delta 0), pack-reused 0\nSubmodule 'src/uploaderSDK' (git@github.com:fengyueran/UploaderSDK.git) registered for path 'src/uploaderSDK'\nCloning into '/Work/test/MainProject/tmp/MainProject/tmp/MainProject/src/uploaderSDK'...\nSubmodule path 'src/uploaderSDK': checked out '6b53e1840b27ca1587b96c1eb9dd5f4ff0866089'\n```\n\n### **修改更新submodule**\n\n主要有两种情况\n\n**1. 直接在主项目中的submodule下修改**\n\n如上例，直接在MainProject下的src/uploaderSDK中修改，uploaderSDK切换到工作分支，修改并提交后，可以checkout到最新的commit，也可以不切，反正都在当前最新的commit上(如果想测试其他commit也可以切换到相应commit上)，此时MainProject中我们可以看到src/uploaderSDK的commit有如下变化，a4d6为修改的提交，需要注意的地方是此时submodule已经在最新的commit上了，不要再在MainProject中git submodule update进行更新了，如果进行此操作submodule又会回到原来的commit(带有减号的commit)，只需要在MainProject提交，并在必要的时候push到远程仓库。这种方法，非submodule的开发人员就不用关心submodule是否更新了，只需要在MainProject下pull代码发现submodule有更改时执行git submodule update(更新为带减号commit)进行更新，前提是其他开发人员提交了正确的submodule commit。\n```差点\n-Subproject commit 6b53e1840b27ca1587b96c1eb9dd5f4ff0866089\n+Subproject commit a4d6dc0457673a275b1f6cbeda6f8ff23293b9de\n```\n**2. 在submodule自己独立的仓库进行修改**\n\n在工作目录克隆下submodule的仓库，切换到工作分支进行修改提交并push到远程仓库。这种方法需要submodule开发人员告诉MainProject的开发人员submodule有更新或主动查看是否有更新，有更新时就在MainProject的src/uploaderSDK下pull远程代码(需要知道submodule的工作分支)，快速合并后，uploaderSDK的commit有如下变化，此时同1不要git submodule update，而只是在MainProject下提交这个更改。\n```\n-Subproject commit f4573cc1bb50000779202c7f56a640b1ffc075cb\n+Subproject commit 64ae6d149c0f6e3b06b8cea262c6126a7bc0887f\n\n```\n\n### **删除submodule**\n\n执行如下命令\n\n1) $ git submodule deinit \n```\n逆初始化模块，submodule为子模块目录，执行后可发现子模块目录被清空\n$ git submodule deinit [submodule_name] \n-> Cleared directory 'test2sub'\nSubmodule 'test2sub' (git@github.com:fengyueran/test2sub.git) unregistered for path 'test2sub'\n\n//执行如下命令还能看到子项目信息\n$ git submodule\n-> -dab52c62f52353d9967619625c28e28dc4320aef test2sub\n```\n2) $ git rm `--`cached [submodule_name]\n```\n// 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）\ngit rm --cached test2sub\n//执行如下命令已看看不到删除的子项目信息了\n$ git submodule\n```\n3）$ git commit\n```\ngit commit -m \"remove submodule\"\n```\n\n\n\n\n","source":"_posts/git submodule的使用.md","raw":"---\nlayout: post\ntitle: Git submodule的使用\ncategory : Git\ntagline: \"Supporting tagline\"\ntags : [Git]\ndescription: 最近在做一个上传的客户端，上传的部分由后端同学以SDK的方式提供，因此该SDK是在一个独立的仓库，那么对于客户端该如何方便的对集成该SDK呢？这就可以考虑用git的submodule。\ndate: 2016-7-24 23:30:09\n---\n\n### **遇到的问题**\n\n最近在做一个上传的客户端，上传的部分由后端同学以SDK的方式提供，因此该SDK是在一个独立的仓库，那么对于客户端该如何方便的集成该SDK呢？每次SDK更新把代码拷贝到客户端仓库？把SDK发布到npm？显然都不合理，这就可以考虑用git的submodule。\n\n### **什么是submodule**\n\nsubmodule是一个多项目管理工具，它允许将子项目以独立的git项目添加到主项目，而主项目以submodule的形式拥有子项目。子项目拥有自己的commit、push、pull，而与主项目互不干扰。主项目只需要记录子项目的地址和所需要的commit id，通过地址和commit id 就能够得到对应的子项目。\n\n### **添加submodule**\n通常情况下，我们都有一个主项目(MainProject)，在MainProject文件夹下执行如下命令，即可添加submodule。\n```\n$ git submodule add [url] [path]\n//url为子项目远程地址或本地地址, path为子项目路径，可省略\n例: git add submodule git@github.com:fengyueran/UploaderSDK.git ./src/UploaderSDK\n```\ngit status可以看到如下信息\n```\n On branch master\n    Changes to be committed:\n    \n        new file:   .gitmodules\n        new file:   UploaderSDK\n```\n可以看到多了两个个文件.gitmodules和UploaderSDK。\ncat .gitmodules看到.gitmodules储存了submodule的路径及远程地址。\n```\n[submodule \"src/uploaderSDK\"]\n\tpath = src/uploaderSDK\n\turl = git@github.com:fengyueran/UploaderSDK.git\n```\nUploaderSDK的内容为submodule的commit id。\n```\nSubproject commit 6b53e1840b27ca1587b96c1eb9dd5f4ff0866089\n```\n不难想象通过.gitmodules和UploaderSDK的信息就可以拿到submodule的内容了，因此我们需要提交这个两个文件。\n```\ngit add .\ngit commit -m \"add submodule\"\n```\n\n### **克隆带有submodule的项目**\n\n主要有两个方式\n\n**1. 采用先克隆后更新的方式**\n\n和想象中的不一样，直接clone主项目，submodule并不会跟着clone下来，而只有包含submodule名的空文件夹。\n```\n1）$ git clone git@github.com:fengyueran/MainProject.git\n```\n需再执行如下命令\n```\n2）$ git submodule init\n```\n输出如下，可以看到该命令给子项目注册了路径，即在主项目中的位置。此时，uploaderSDK文件夹仍未空。\n```\n    \n    Submodule 'src/uploaderSDK' (git@github.com:fengyueran/UploaderSDK.git) registered for path 'src/uploaderSDK'\n```\n\b再执行\n```\n//该命令\b并不是直接更新到最新的submodule commit，而是更新至主项目\b所存储存的commit(有可能是较旧的commit)。\n3）$ git submodule update\n```\n输出如下，可以看到sumodule得到更新，更新到主项目存储的submodule commit，是一个游离的git header。\n  ```\n  Cloning into '/Work/test/MainProject/tmp/MainProject/src/uploaderSDK'...\n\n  Submodule path 'src/uploaderSDK': checked out '6b53e1840b27ca1587b96c1eb9dd5f4ff0866089'\n  ```\n\n\n**2. 采用递归参数--recursive**\n\n```\ngit clone git@github.com:fengyueran/MainProject.git --recursive\n```\n输出如下，可以看到主项目包括submodule都被clone下来了。\n```\nCloning into 'MainProject'...\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (4/4), done.\nReceiving objects: 100% (7/7), done.\nremote: Total 7 (delta 0), reused 4 (delta 0), pack-reused 0\nSubmodule 'src/uploaderSDK' (git@github.com:fengyueran/UploaderSDK.git) registered for path 'src/uploaderSDK'\nCloning into '/Work/test/MainProject/tmp/MainProject/tmp/MainProject/src/uploaderSDK'...\nSubmodule path 'src/uploaderSDK': checked out '6b53e1840b27ca1587b96c1eb9dd5f4ff0866089'\n```\n\n### **修改更新submodule**\n\n主要有两种情况\n\n**1. 直接在主项目中的submodule下修改**\n\n如上例，直接在MainProject下的src/uploaderSDK中修改，uploaderSDK切换到工作分支，修改并提交后，可以checkout到最新的commit，也可以不切，反正都在当前最新的commit上(如果想测试其他commit也可以切换到相应commit上)，此时MainProject中我们可以看到src/uploaderSDK的commit有如下变化，a4d6为修改的提交，需要注意的地方是此时submodule已经在最新的commit上了，不要再在MainProject中git submodule update进行更新了，如果进行此操作submodule又会回到原来的commit(带有减号的commit)，只需要在MainProject提交，并在必要的时候push到远程仓库。这种方法，非submodule的开发人员就不用关心submodule是否更新了，只需要在MainProject下pull代码发现submodule有更改时执行git submodule update(更新为带减号commit)进行更新，前提是其他开发人员提交了正确的submodule commit。\n```差点\n-Subproject commit 6b53e1840b27ca1587b96c1eb9dd5f4ff0866089\n+Subproject commit a4d6dc0457673a275b1f6cbeda6f8ff23293b9de\n```\n**2. 在submodule自己独立的仓库进行修改**\n\n在工作目录克隆下submodule的仓库，切换到工作分支进行修改提交并push到远程仓库。这种方法需要submodule开发人员告诉MainProject的开发人员submodule有更新或主动查看是否有更新，有更新时就在MainProject的src/uploaderSDK下pull远程代码(需要知道submodule的工作分支)，快速合并后，uploaderSDK的commit有如下变化，此时同1不要git submodule update，而只是在MainProject下提交这个更改。\n```\n-Subproject commit f4573cc1bb50000779202c7f56a640b1ffc075cb\n+Subproject commit 64ae6d149c0f6e3b06b8cea262c6126a7bc0887f\n\n```\n\n### **删除submodule**\n\n执行如下命令\n\n1) $ git submodule deinit \n```\n逆初始化模块，submodule为子模块目录，执行后可发现子模块目录被清空\n$ git submodule deinit [submodule_name] \n-> Cleared directory 'test2sub'\nSubmodule 'test2sub' (git@github.com:fengyueran/test2sub.git) unregistered for path 'test2sub'\n\n//执行如下命令还能看到子项目信息\n$ git submodule\n-> -dab52c62f52353d9967619625c28e28dc4320aef test2sub\n```\n2) $ git rm `--`cached [submodule_name]\n```\n// 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）\ngit rm --cached test2sub\n//执行如下命令已看看不到删除的子项目信息了\n$ git submodule\n```\n3）$ git commit\n```\ngit commit -m \"remove submodule\"\n```\n\n\n\n\n","slug":"git submodule的使用","published":1,"updated":"2018-12-23T12:31:33.510Z","comments":1,"photos":[],"link":"","_id":"cjq5aqcs60002dsztxw50b0y2","content":"<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a><strong>遇到的问题</strong></h3><p>最近在做一个上传的客户端，上传的部分由后端同学以SDK的方式提供，因此该SDK是在一个独立的仓库，那么对于客户端该如何方便的集成该SDK呢？每次SDK更新把代码拷贝到客户端仓库？把SDK发布到npm？显然都不合理，这就可以考虑用git的submodule。</p>\n<h3 id=\"什么是submodule\"><a href=\"#什么是submodule\" class=\"headerlink\" title=\"什么是submodule\"></a><strong>什么是submodule</strong></h3><p>submodule是一个多项目管理工具，它允许将子项目以独立的git项目添加到主项目，而主项目以submodule的形式拥有子项目。子项目拥有自己的commit、push、pull，而与主项目互不干扰。主项目只需要记录子项目的地址和所需要的commit id，通过地址和commit id 就能够得到对应的子项目。</p>\n<h3 id=\"添加submodule\"><a href=\"#添加submodule\" class=\"headerlink\" title=\"添加submodule\"></a><strong>添加submodule</strong></h3><p>通常情况下，我们都有一个主项目(MainProject)，在MainProject文件夹下执行如下命令，即可添加submodule。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git submodule add [url] [path]</span><br><span class=\"line\">//url为子项目远程地址或本地地址, path为子项目路径，可省略</span><br><span class=\"line\">例: git add submodule git@github.com:fengyueran/UploaderSDK.git ./src/UploaderSDK</span><br></pre></td></tr></table></figure></p>\n<p>git status可以看到如下信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\">   Changes to be committed:</span><br><span class=\"line\">   </span><br><span class=\"line\">       new file:   .gitmodules</span><br><span class=\"line\">       new file:   UploaderSDK</span><br></pre></td></tr></table></figure></p>\n<p>可以看到多了两个个文件.gitmodules和UploaderSDK。<br>cat .gitmodules看到.gitmodules储存了submodule的路径及远程地址。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[submodule &quot;src/uploaderSDK&quot;]</span><br><span class=\"line\">\tpath = src/uploaderSDK</span><br><span class=\"line\">\turl = git@github.com:fengyueran/UploaderSDK.git</span><br></pre></td></tr></table></figure></p>\n<p>UploaderSDK的内容为submodule的commit id。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Subproject commit 6b53e1840b27ca1587b96c1eb9dd5f4ff0866089</span><br></pre></td></tr></table></figure></p>\n<p>不难想象通过.gitmodules和UploaderSDK的信息就可以拿到submodule的内容了，因此我们需要提交这个两个文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;add submodule&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"克隆带有submodule的项目\"><a href=\"#克隆带有submodule的项目\" class=\"headerlink\" title=\"克隆带有submodule的项目\"></a><strong>克隆带有submodule的项目</strong></h3><p>主要有两个方式</p>\n<p><strong>1. 采用先克隆后更新的方式</strong></p>\n<p>和想象中的不一样，直接clone主项目，submodule并不会跟着clone下来，而只有包含submodule名的空文件夹。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）$ git clone git@github.com:fengyueran/MainProject.git</span><br></pre></td></tr></table></figure></p>\n<p>需再执行如下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2）$ git submodule init</span><br></pre></td></tr></table></figure></p>\n<p>输出如下，可以看到该命令给子项目注册了路径，即在主项目中的位置。此时，uploaderSDK文件夹仍未空。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Submodule &apos;src/uploaderSDK&apos; (git@github.com:fengyueran/UploaderSDK.git) registered for path &apos;src/uploaderSDK&apos;</span><br></pre></td></tr></table></figure></p>\n<p>\b再执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//该命令\b并不是直接更新到最新的submodule commit，而是更新至主项目\b所存储存的commit(有可能是较旧的commit)。</span><br><span class=\"line\">3）$ git submodule update</span><br></pre></td></tr></table></figure></p>\n<p>输出如下，可以看到sumodule得到更新，更新到主项目存储的submodule commit，是一个游离的git header。<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cloning into &apos;/Work/test/MainProject/tmp/MainProject/src/uploaderSDK&apos;...</span><br><span class=\"line\"></span><br><span class=\"line\">Submodule path &apos;src/uploaderSDK&apos;: checked out &apos;6b53e1840b27ca1587b96c1eb9dd5f4ff0866089&apos;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2. 采用递归参数–recursive</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:fengyueran/MainProject.git --recursive</span><br></pre></td></tr></table></figure>\n<p>输出如下，可以看到主项目包括submodule都被clone下来了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cloning into &apos;MainProject&apos;...</span><br><span class=\"line\">remote: Counting objects: 7, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (4/4), done.</span><br><span class=\"line\">Receiving objects: 100% (7/7), done.</span><br><span class=\"line\">remote: Total 7 (delta 0), reused 4 (delta 0), pack-reused 0</span><br><span class=\"line\">Submodule &apos;src/uploaderSDK&apos; (git@github.com:fengyueran/UploaderSDK.git) registered for path &apos;src/uploaderSDK&apos;</span><br><span class=\"line\">Cloning into &apos;/Work/test/MainProject/tmp/MainProject/tmp/MainProject/src/uploaderSDK&apos;...</span><br><span class=\"line\">Submodule path &apos;src/uploaderSDK&apos;: checked out &apos;6b53e1840b27ca1587b96c1eb9dd5f4ff0866089&apos;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修改更新submodule\"><a href=\"#修改更新submodule\" class=\"headerlink\" title=\"修改更新submodule\"></a><strong>修改更新submodule</strong></h3><p>主要有两种情况</p>\n<p><strong>1. 直接在主项目中的submodule下修改</strong></p>\n<p>如上例，直接在MainProject下的src/uploaderSDK中修改，uploaderSDK切换到工作分支，修改并提交后，可以checkout到最新的commit，也可以不切，反正都在当前最新的commit上(如果想测试其他commit也可以切换到相应commit上)，此时MainProject中我们可以看到src/uploaderSDK的commit有如下变化，a4d6为修改的提交，需要注意的地方是此时submodule已经在最新的commit上了，不要再在MainProject中git submodule update进行更新了，如果进行此操作submodule又会回到原来的commit(带有减号的commit)，只需要在MainProject提交，并在必要的时候push到远程仓库。这种方法，非submodule的开发人员就不用关心submodule是否更新了，只需要在MainProject下pull代码发现submodule有更改时执行git submodule update(更新为带减号commit)进行更新，前提是其他开发人员提交了正确的submodule commit。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Subproject commit 6b53e1840b27ca1587b96c1eb9dd5f4ff0866089</span><br><span class=\"line\">+Subproject commit a4d6dc0457673a275b1f6cbeda6f8ff23293b9de</span><br></pre></td></tr></table></figure></p>\n<p><strong>2. 在submodule自己独立的仓库进行修改</strong></p>\n<p>在工作目录克隆下submodule的仓库，切换到工作分支进行修改提交并push到远程仓库。这种方法需要submodule开发人员告诉MainProject的开发人员submodule有更新或主动查看是否有更新，有更新时就在MainProject的src/uploaderSDK下pull远程代码(需要知道submodule的工作分支)，快速合并后，uploaderSDK的commit有如下变化，此时同1不要git submodule update，而只是在MainProject下提交这个更改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Subproject commit f4573cc1bb50000779202c7f56a640b1ffc075cb</span><br><span class=\"line\">+Subproject commit 64ae6d149c0f6e3b06b8cea262c6126a7bc0887f</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除submodule\"><a href=\"#删除submodule\" class=\"headerlink\" title=\"删除submodule\"></a><strong>删除submodule</strong></h3><p>执行如下命令</p>\n<p>1) $ git submodule deinit<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">逆初始化模块，submodule为子模块目录，执行后可发现子模块目录被清空</span><br><span class=\"line\">$ git submodule deinit [submodule_name] </span><br><span class=\"line\">-&gt; Cleared directory &apos;test2sub&apos;</span><br><span class=\"line\">Submodule &apos;test2sub&apos; (git@github.com:fengyueran/test2sub.git) unregistered for path &apos;test2sub&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">//执行如下命令还能看到子项目信息</span><br><span class=\"line\">$ git submodule</span><br><span class=\"line\">-&gt; -dab52c62f52353d9967619625c28e28dc4320aef test2sub</span><br></pre></td></tr></table></figure></p>\n<p>2) $ git rm <code>--</code>cached [submodule_name]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）</span><br><span class=\"line\">git rm --cached test2sub</span><br><span class=\"line\">//执行如下命令已看看不到删除的子项目信息了</span><br><span class=\"line\">$ git submodule</span><br></pre></td></tr></table></figure></p>\n<p>3）$ git commit<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;remove submodule&quot;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a><strong>遇到的问题</strong></h3><p>最近在做一个上传的客户端，上传的部分由后端同学以SDK的方式提供，因此该SDK是在一个独立的仓库，那么对于客户端该如何方便的集成该SDK呢？每次SDK更新把代码拷贝到客户端仓库？把SDK发布到npm？显然都不合理，这就可以考虑用git的submodule。</p>\n<h3 id=\"什么是submodule\"><a href=\"#什么是submodule\" class=\"headerlink\" title=\"什么是submodule\"></a><strong>什么是submodule</strong></h3><p>submodule是一个多项目管理工具，它允许将子项目以独立的git项目添加到主项目，而主项目以submodule的形式拥有子项目。子项目拥有自己的commit、push、pull，而与主项目互不干扰。主项目只需要记录子项目的地址和所需要的commit id，通过地址和commit id 就能够得到对应的子项目。</p>\n<h3 id=\"添加submodule\"><a href=\"#添加submodule\" class=\"headerlink\" title=\"添加submodule\"></a><strong>添加submodule</strong></h3><p>通常情况下，我们都有一个主项目(MainProject)，在MainProject文件夹下执行如下命令，即可添加submodule。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git submodule add [url] [path]</span><br><span class=\"line\">//url为子项目远程地址或本地地址, path为子项目路径，可省略</span><br><span class=\"line\">例: git add submodule git@github.com:fengyueran/UploaderSDK.git ./src/UploaderSDK</span><br></pre></td></tr></table></figure></p>\n<p>git status可以看到如下信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">On branch master</span><br><span class=\"line\">   Changes to be committed:</span><br><span class=\"line\">   </span><br><span class=\"line\">       new file:   .gitmodules</span><br><span class=\"line\">       new file:   UploaderSDK</span><br></pre></td></tr></table></figure></p>\n<p>可以看到多了两个个文件.gitmodules和UploaderSDK。<br>cat .gitmodules看到.gitmodules储存了submodule的路径及远程地址。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[submodule &quot;src/uploaderSDK&quot;]</span><br><span class=\"line\">\tpath = src/uploaderSDK</span><br><span class=\"line\">\turl = git@github.com:fengyueran/UploaderSDK.git</span><br></pre></td></tr></table></figure></p>\n<p>UploaderSDK的内容为submodule的commit id。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Subproject commit 6b53e1840b27ca1587b96c1eb9dd5f4ff0866089</span><br></pre></td></tr></table></figure></p>\n<p>不难想象通过.gitmodules和UploaderSDK的信息就可以拿到submodule的内容了，因此我们需要提交这个两个文件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m &quot;add submodule&quot;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"克隆带有submodule的项目\"><a href=\"#克隆带有submodule的项目\" class=\"headerlink\" title=\"克隆带有submodule的项目\"></a><strong>克隆带有submodule的项目</strong></h3><p>主要有两个方式</p>\n<p><strong>1. 采用先克隆后更新的方式</strong></p>\n<p>和想象中的不一样，直接clone主项目，submodule并不会跟着clone下来，而只有包含submodule名的空文件夹。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）$ git clone git@github.com:fengyueran/MainProject.git</span><br></pre></td></tr></table></figure></p>\n<p>需再执行如下命令<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2）$ git submodule init</span><br></pre></td></tr></table></figure></p>\n<p>输出如下，可以看到该命令给子项目注册了路径，即在主项目中的位置。此时，uploaderSDK文件夹仍未空。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Submodule &apos;src/uploaderSDK&apos; (git@github.com:fengyueran/UploaderSDK.git) registered for path &apos;src/uploaderSDK&apos;</span><br></pre></td></tr></table></figure></p>\n<p>\b再执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//该命令\b并不是直接更新到最新的submodule commit，而是更新至主项目\b所存储存的commit(有可能是较旧的commit)。</span><br><span class=\"line\">3）$ git submodule update</span><br></pre></td></tr></table></figure></p>\n<p>输出如下，可以看到sumodule得到更新，更新到主项目存储的submodule commit，是一个游离的git header。<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cloning into &apos;/Work/test/MainProject/tmp/MainProject/src/uploaderSDK&apos;...</span><br><span class=\"line\"></span><br><span class=\"line\">Submodule path &apos;src/uploaderSDK&apos;: checked out &apos;6b53e1840b27ca1587b96c1eb9dd5f4ff0866089&apos;</span><br></pre></td></tr></table></figure></p>\n<p><strong>2. 采用递归参数–recursive</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@github.com:fengyueran/MainProject.git --recursive</span><br></pre></td></tr></table></figure>\n<p>输出如下，可以看到主项目包括submodule都被clone下来了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cloning into &apos;MainProject&apos;...</span><br><span class=\"line\">remote: Counting objects: 7, done.</span><br><span class=\"line\">remote: Compressing objects: 100% (4/4), done.</span><br><span class=\"line\">Receiving objects: 100% (7/7), done.</span><br><span class=\"line\">remote: Total 7 (delta 0), reused 4 (delta 0), pack-reused 0</span><br><span class=\"line\">Submodule &apos;src/uploaderSDK&apos; (git@github.com:fengyueran/UploaderSDK.git) registered for path &apos;src/uploaderSDK&apos;</span><br><span class=\"line\">Cloning into &apos;/Work/test/MainProject/tmp/MainProject/tmp/MainProject/src/uploaderSDK&apos;...</span><br><span class=\"line\">Submodule path &apos;src/uploaderSDK&apos;: checked out &apos;6b53e1840b27ca1587b96c1eb9dd5f4ff0866089&apos;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修改更新submodule\"><a href=\"#修改更新submodule\" class=\"headerlink\" title=\"修改更新submodule\"></a><strong>修改更新submodule</strong></h3><p>主要有两种情况</p>\n<p><strong>1. 直接在主项目中的submodule下修改</strong></p>\n<p>如上例，直接在MainProject下的src/uploaderSDK中修改，uploaderSDK切换到工作分支，修改并提交后，可以checkout到最新的commit，也可以不切，反正都在当前最新的commit上(如果想测试其他commit也可以切换到相应commit上)，此时MainProject中我们可以看到src/uploaderSDK的commit有如下变化，a4d6为修改的提交，需要注意的地方是此时submodule已经在最新的commit上了，不要再在MainProject中git submodule update进行更新了，如果进行此操作submodule又会回到原来的commit(带有减号的commit)，只需要在MainProject提交，并在必要的时候push到远程仓库。这种方法，非submodule的开发人员就不用关心submodule是否更新了，只需要在MainProject下pull代码发现submodule有更改时执行git submodule update(更新为带减号commit)进行更新，前提是其他开发人员提交了正确的submodule commit。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Subproject commit 6b53e1840b27ca1587b96c1eb9dd5f4ff0866089</span><br><span class=\"line\">+Subproject commit a4d6dc0457673a275b1f6cbeda6f8ff23293b9de</span><br></pre></td></tr></table></figure></p>\n<p><strong>2. 在submodule自己独立的仓库进行修改</strong></p>\n<p>在工作目录克隆下submodule的仓库，切换到工作分支进行修改提交并push到远程仓库。这种方法需要submodule开发人员告诉MainProject的开发人员submodule有更新或主动查看是否有更新，有更新时就在MainProject的src/uploaderSDK下pull远程代码(需要知道submodule的工作分支)，快速合并后，uploaderSDK的commit有如下变化，此时同1不要git submodule update，而只是在MainProject下提交这个更改。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Subproject commit f4573cc1bb50000779202c7f56a640b1ffc075cb</span><br><span class=\"line\">+Subproject commit 64ae6d149c0f6e3b06b8cea262c6126a7bc0887f</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除submodule\"><a href=\"#删除submodule\" class=\"headerlink\" title=\"删除submodule\"></a><strong>删除submodule</strong></h3><p>执行如下命令</p>\n<p>1) $ git submodule deinit<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">逆初始化模块，submodule为子模块目录，执行后可发现子模块目录被清空</span><br><span class=\"line\">$ git submodule deinit [submodule_name] </span><br><span class=\"line\">-&gt; Cleared directory &apos;test2sub&apos;</span><br><span class=\"line\">Submodule &apos;test2sub&apos; (git@github.com:fengyueran/test2sub.git) unregistered for path &apos;test2sub&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">//执行如下命令还能看到子项目信息</span><br><span class=\"line\">$ git submodule</span><br><span class=\"line\">-&gt; -dab52c62f52353d9967619625c28e28dc4320aef test2sub</span><br></pre></td></tr></table></figure></p>\n<p>2) $ git rm <code>--</code>cached [submodule_name]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 删除.gitmodules中记录的模块信息（--cached选项清除.git/modules中的缓存）</span><br><span class=\"line\">git rm --cached test2sub</span><br><span class=\"line\">//执行如下命令已看看不到删除的子项目信息了</span><br><span class=\"line\">$ git submodule</span><br></pre></td></tr></table></figure></p>\n<p>3）$ git commit<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git commit -m &quot;remove submodule&quot;</span><br></pre></td></tr></table></figure></p>\n"},{"layout":"post","title":"AJAX是什么","tagline":"Supporting tagline","description":"前端的同学在日常编程中应该对网络请求得心应手，什么get请求、post请求第三方库api一调用得溜溜的，其实这些库基本都是封装的ajax请求，那什么是ajax呢？","date":"2016-01-01T10:10:20.000Z","_content":"\n### **什么是AJAX** \n\nAJAX即Asynchronous JavaScript and XML(异步的JavaScript和XML技术)，它不是一种具体的东西，而是一种使用现有标准的技术，它允许客户端脚本向服务器发送请求，这对于21世纪的我们来说似乎再寻常不过了，但没有AJAX之前发送网络请求是这样的：\n - 打开浏览器 => 输入网址 => 回车 => 发送请求 => 服务器返回页面，页面刷新\n - 表单 => 提交 => 发送请求 => 服务器返回页面，页面刷新\n - 特殊标签，img、link、script等请求特定文件(不刷新页面)\n\n可以看到没有AJAX之前除了请求特定文件外都会导致页面刷新，即使只修改了页面很小一部分也需要刷新整个页面，这样的处理效率低下，用户体验也相当糟糕。于是AJAX横空出世，它允许客户端用JS向服务器请求必要数据并进行处理，更新网页(不刷新整个页面)\n\n### **发起AJAX请求** \n\n- 创建XMLHttpRequest对象\n  XMLHttpRequest对象是AJAX的基础，现代浏览器均支持该对象。\n```\nconst xhr = new XMLHttpRequest();\n```\n- 监听请求状态\n```\nxhr.onreadystatechange = () => {\n  if (this.readyState == 4 && this.status == 200) {\n    document.getElementById(\"root\").innerHTML=xhr.responseText\n    console.log('请求成功');\n  }\n};\n\n```\n- 设置请求参数\n\n```\n/*\n 方法：open(method,url,async)\n - method: GET或POST\n - url: 发送请求的URL\n - async: 异步或同步(true或false)\n*/\n// get请求\nxhr.open( \"get\", \"http://localhost:4000/data?page=\" + encodeURTComponent(page), true);\n// post 请求\nxhr.open(\"POST\",\"http://localhost:4000/data\",true);\n// 必须设置提交时的内容类型，否则服务器端收不到参数 \nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n```\n\n- 发送请求\n\n```\n  // get\n  request.send();\n  // post data为为请求参数\n  const data =\"name=\" + encodeURIComponent(\"xhm\");\n  request.send(data);\n```\n  \n### **AJAX请求post和get的区别** \n\n- get请求\n - 数据较小，一般限制在1kb以下\n - 数据追加到url中，如(http://localhost:4000/data?username=xhm&&password=xhm)\n - 浏览器会缓存请求记录，可能带来安全性问题\n - 服务器端用Request.query获取变量的值\n\n- post请求\n - 没有数据量限制(但理论上，因服务器的不同而异)\n - 发送包含未知字符的用户输入时post更加安全\n - get请求时参数在url里，send的时参数为null，post请求时可以给send函数赋予参数\n - 服务器端用Request.Form获取提交的数据\n\n","source":"_posts/AJAX是什么.md","raw":"---\nlayout: post\ntitle: AJAX是什么\ncategory : network\ntagline: \"Supporting tagline\"\ntags : [network]\ndescription: 前端的同学在日常编程中应该对网络请求得心应手，什么get请求、post请求第三方库api一调用得溜溜的，其实这些库基本都是封装的ajax请求，那什么是ajax呢？\ndate: 2016-1-01 18:10:20\n---\n\n### **什么是AJAX** \n\nAJAX即Asynchronous JavaScript and XML(异步的JavaScript和XML技术)，它不是一种具体的东西，而是一种使用现有标准的技术，它允许客户端脚本向服务器发送请求，这对于21世纪的我们来说似乎再寻常不过了，但没有AJAX之前发送网络请求是这样的：\n - 打开浏览器 => 输入网址 => 回车 => 发送请求 => 服务器返回页面，页面刷新\n - 表单 => 提交 => 发送请求 => 服务器返回页面，页面刷新\n - 特殊标签，img、link、script等请求特定文件(不刷新页面)\n\n可以看到没有AJAX之前除了请求特定文件外都会导致页面刷新，即使只修改了页面很小一部分也需要刷新整个页面，这样的处理效率低下，用户体验也相当糟糕。于是AJAX横空出世，它允许客户端用JS向服务器请求必要数据并进行处理，更新网页(不刷新整个页面)\n\n### **发起AJAX请求** \n\n- 创建XMLHttpRequest对象\n  XMLHttpRequest对象是AJAX的基础，现代浏览器均支持该对象。\n```\nconst xhr = new XMLHttpRequest();\n```\n- 监听请求状态\n```\nxhr.onreadystatechange = () => {\n  if (this.readyState == 4 && this.status == 200) {\n    document.getElementById(\"root\").innerHTML=xhr.responseText\n    console.log('请求成功');\n  }\n};\n\n```\n- 设置请求参数\n\n```\n/*\n 方法：open(method,url,async)\n - method: GET或POST\n - url: 发送请求的URL\n - async: 异步或同步(true或false)\n*/\n// get请求\nxhr.open( \"get\", \"http://localhost:4000/data?page=\" + encodeURTComponent(page), true);\n// post 请求\nxhr.open(\"POST\",\"http://localhost:4000/data\",true);\n// 必须设置提交时的内容类型，否则服务器端收不到参数 \nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');\n```\n\n- 发送请求\n\n```\n  // get\n  request.send();\n  // post data为为请求参数\n  const data =\"name=\" + encodeURIComponent(\"xhm\");\n  request.send(data);\n```\n  \n### **AJAX请求post和get的区别** \n\n- get请求\n - 数据较小，一般限制在1kb以下\n - 数据追加到url中，如(http://localhost:4000/data?username=xhm&&password=xhm)\n - 浏览器会缓存请求记录，可能带来安全性问题\n - 服务器端用Request.query获取变量的值\n\n- post请求\n - 没有数据量限制(但理论上，因服务器的不同而异)\n - 发送包含未知字符的用户输入时post更加安全\n - get请求时参数在url里，send的时参数为null，post请求时可以给send函数赋予参数\n - 服务器端用Request.Form获取提交的数据\n\n","slug":"AJAX是什么","published":1,"updated":"2018-12-23T12:31:33.508Z","comments":1,"photos":[],"link":"","_id":"cjq5aqcsb0005dsztgpkjt5tn","content":"<h3 id=\"什么是AJAX\"><a href=\"#什么是AJAX\" class=\"headerlink\" title=\"什么是AJAX\"></a><strong>什么是AJAX</strong></h3><p>AJAX即Asynchronous JavaScript and XML(异步的JavaScript和XML技术)，它不是一种具体的东西，而是一种使用现有标准的技术，它允许客户端脚本向服务器发送请求，这对于21世纪的我们来说似乎再寻常不过了，但没有AJAX之前发送网络请求是这样的：</p>\n<ul>\n<li>打开浏览器 =&gt; 输入网址 =&gt; 回车 =&gt; 发送请求 =&gt; 服务器返回页面，页面刷新</li>\n<li>表单 =&gt; 提交 =&gt; 发送请求 =&gt; 服务器返回页面，页面刷新</li>\n<li>特殊标签，img、link、script等请求特定文件(不刷新页面)</li>\n</ul>\n<p>可以看到没有AJAX之前除了请求特定文件外都会导致页面刷新，即使只修改了页面很小一部分也需要刷新整个页面，这样的处理效率低下，用户体验也相当糟糕。于是AJAX横空出世，它允许客户端用JS向服务器请求必要数据并进行处理，更新网页(不刷新整个页面)</p>\n<h3 id=\"发起AJAX请求\"><a href=\"#发起AJAX请求\" class=\"headerlink\" title=\"发起AJAX请求\"></a><strong>发起AJAX请求</strong></h3><ul>\n<li><p>创建XMLHttpRequest对象<br>XMLHttpRequest对象是AJAX的基础，现代浏览器均支持该对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>监听请求状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">  if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;</span><br><span class=\"line\">    document.getElementById(&quot;root&quot;).innerHTML=xhr.responseText</span><br><span class=\"line\">    console.log(&apos;请求成功&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置请求参数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> 方法：open(method,url,async)</span><br><span class=\"line\"> - method: GET或POST</span><br><span class=\"line\"> - url: 发送请求的URL</span><br><span class=\"line\"> - async: 异步或同步(true或false)</span><br><span class=\"line\">*/</span><br><span class=\"line\">// get请求</span><br><span class=\"line\">xhr.open( &quot;get&quot;, &quot;http://localhost:4000/data?page=&quot; + encodeURTComponent(page), true);</span><br><span class=\"line\">// post 请求</span><br><span class=\"line\">xhr.open(&quot;POST&quot;,&quot;http://localhost:4000/data&quot;,true);</span><br><span class=\"line\">// 必须设置提交时的内容类型，否则服务器端收不到参数 </span><br><span class=\"line\">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>发送请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// get</span><br><span class=\"line\">request.send();</span><br><span class=\"line\">// post data为为请求参数</span><br><span class=\"line\">const data =&quot;name=&quot; + encodeURIComponent(&quot;xhm&quot;);</span><br><span class=\"line\">request.send(data);</span><br></pre></td></tr></table></figure>\n<h3 id=\"AJAX请求post和get的区别\"><a href=\"#AJAX请求post和get的区别\" class=\"headerlink\" title=\"AJAX请求post和get的区别\"></a><strong>AJAX请求post和get的区别</strong></h3><ul>\n<li><p>get请求</p>\n<ul>\n<li>数据较小，一般限制在1kb以下</li>\n<li>数据追加到url中，如(<a href=\"http://localhost:4000/data?username=xhm&amp;&amp;password=xhm\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/data?username=xhm&amp;&amp;password=xhm</a>)</li>\n<li>浏览器会缓存请求记录，可能带来安全性问题</li>\n<li>服务器端用Request.query获取变量的值</li>\n</ul>\n</li>\n<li><p>post请求</p>\n<ul>\n<li>没有数据量限制(但理论上，因服务器的不同而异)</li>\n<li>发送包含未知字符的用户输入时post更加安全</li>\n<li>get请求时参数在url里，send的时参数为null，post请求时可以给send函数赋予参数</li>\n<li>服务器端用Request.Form获取提交的数据</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是AJAX\"><a href=\"#什么是AJAX\" class=\"headerlink\" title=\"什么是AJAX\"></a><strong>什么是AJAX</strong></h3><p>AJAX即Asynchronous JavaScript and XML(异步的JavaScript和XML技术)，它不是一种具体的东西，而是一种使用现有标准的技术，它允许客户端脚本向服务器发送请求，这对于21世纪的我们来说似乎再寻常不过了，但没有AJAX之前发送网络请求是这样的：</p>\n<ul>\n<li>打开浏览器 =&gt; 输入网址 =&gt; 回车 =&gt; 发送请求 =&gt; 服务器返回页面，页面刷新</li>\n<li>表单 =&gt; 提交 =&gt; 发送请求 =&gt; 服务器返回页面，页面刷新</li>\n<li>特殊标签，img、link、script等请求特定文件(不刷新页面)</li>\n</ul>\n<p>可以看到没有AJAX之前除了请求特定文件外都会导致页面刷新，即使只修改了页面很小一部分也需要刷新整个页面，这样的处理效率低下，用户体验也相当糟糕。于是AJAX横空出世，它允许客户端用JS向服务器请求必要数据并进行处理，更新网页(不刷新整个页面)</p>\n<h3 id=\"发起AJAX请求\"><a href=\"#发起AJAX请求\" class=\"headerlink\" title=\"发起AJAX请求\"></a><strong>发起AJAX请求</strong></h3><ul>\n<li><p>创建XMLHttpRequest对象<br>XMLHttpRequest对象是AJAX的基础，现代浏览器均支持该对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>监听请求状态</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xhr.onreadystatechange = () =&gt; &#123;</span><br><span class=\"line\">  if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;</span><br><span class=\"line\">    document.getElementById(&quot;root&quot;).innerHTML=xhr.responseText</span><br><span class=\"line\">    console.log(&apos;请求成功&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>设置请求参数</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> 方法：open(method,url,async)</span><br><span class=\"line\"> - method: GET或POST</span><br><span class=\"line\"> - url: 发送请求的URL</span><br><span class=\"line\"> - async: 异步或同步(true或false)</span><br><span class=\"line\">*/</span><br><span class=\"line\">// get请求</span><br><span class=\"line\">xhr.open( &quot;get&quot;, &quot;http://localhost:4000/data?page=&quot; + encodeURTComponent(page), true);</span><br><span class=\"line\">// post 请求</span><br><span class=\"line\">xhr.open(&quot;POST&quot;,&quot;http://localhost:4000/data&quot;,true);</span><br><span class=\"line\">// 必须设置提交时的内容类型，否则服务器端收不到参数 </span><br><span class=\"line\">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded; charset=UTF-8&apos;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>发送请求</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// get</span><br><span class=\"line\">request.send();</span><br><span class=\"line\">// post data为为请求参数</span><br><span class=\"line\">const data =&quot;name=&quot; + encodeURIComponent(&quot;xhm&quot;);</span><br><span class=\"line\">request.send(data);</span><br></pre></td></tr></table></figure>\n<h3 id=\"AJAX请求post和get的区别\"><a href=\"#AJAX请求post和get的区别\" class=\"headerlink\" title=\"AJAX请求post和get的区别\"></a><strong>AJAX请求post和get的区别</strong></h3><ul>\n<li><p>get请求</p>\n<ul>\n<li>数据较小，一般限制在1kb以下</li>\n<li>数据追加到url中，如(<a href=\"http://localhost:4000/data?username=xhm&amp;&amp;password=xhm\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/data?username=xhm&amp;&amp;password=xhm</a>)</li>\n<li>浏览器会缓存请求记录，可能带来安全性问题</li>\n<li>服务器端用Request.query获取变量的值</li>\n</ul>\n</li>\n<li><p>post请求</p>\n<ul>\n<li>没有数据量限制(但理论上，因服务器的不同而异)</li>\n<li>发送包含未知字符的用户输入时post更加安全</li>\n<li>get请求时参数在url里，send的时参数为null，post请求时可以给send函数赋予参数</li>\n<li>服务器端用Request.Form获取提交的数据</li>\n</ul>\n</li>\n</ul>\n"},{"layout":"post","title":"JavaScript中的this","tagline":"Supporting tagline","description":"在JavaScript中并没有OOP编程的概念，我们谈到的this不同于一些OOP编程里指向的实例化对象，它指的是运行时的上下文。所谓上下文，就是运行时所在的环境对象，比如你在公司，可能你的领导是你的部门经理，在家就是你媳妇儿一样，不同的场合上下文是不一样的。","date":"2016-01-02T08:17:25.000Z","_content":"\n### **this是什么** \n在JavaScript中并没有OOP编程的概念，我们谈到的this不同于一些OOP编程里指向的实例化对象，它指的是运行时的上下文。所谓上下文，就是运行时所在的环境对象，比如你在公司，可能你的领导是你的部门经理，在家就是你媳妇儿一样，不同的场合上下文是不一样的。\n\n### **this的应用场景** \n在JavaScript中的函数具有定义时上下文、运行时上下文以及上下文可改变的特点，也就是说函数中的this在不同的场合对应不同的值，来看如下例子：\n\n**全局调用(非严格模式)**\n全局调用即单纯的函数调用，如下: 例1中函数getName在全局调用，this指向全局对象，例2中尽管函数getNameFunc为boy对象的方法，但因其在全局调用，this同样指向全局对象。\n```\n// 例1\nvar name = 'lily';\nfunction getName() {\n  console.log(this.name)\n};\ngetName();\n=> lily\n\n// 例2\nvar boy = {\n  name: 'lucy',\n  getName,\n};\nvar getNameFunc = boy.getName;\ngetNameFunc();\n=> lily\n```\n\n**对象调用**\n\n实例对象调用自己的方法getName，this则指向改实例对象\n\n```\nvar boy = {\n  name: 'lucy',\n  getName,\n};\n\nboy.getName();\n=> lucy\n```\n\n**构造函数调用**\n\n构造函数生成一个新的对象，this就指向这个对象。\n\n```\nfunction person() {\n　this.name = 'xhm';\n}\n\nvar p = new person();\np.name // xhm\n```\n\n**func.call和func.apply**\nfunc.call和func.apply的作用一样都是改变执行上下文，只是接收参数的形式不同。\n\n- func.apply(context, param)\n  func.apply方法传入两个参数，第一个参数是上下文对象，为空则指向全局对象，第二个参数是函数参数组成的数组。\n  如下，给出了apply函数的源码大义，可以看到传入的数组参数会拼接成参数列表组成的一个字符串，并将需要执行的函数绑定到目标对象上。\n  ```\n  Function.prototype.apply = function(target, arr){\n    target = target || window\n    target.fn = this;\n     if(arr == []) {\n        return target.fn;\n        delete target.fn;\n     } else {\n        var args = [];\n        for(var i = 0; i < arr.length; i ++){\n          args.push('arr['+ i + ']');\n        }\n        //eval()函数会将传入的字符串当做JavaScript代码进行执行\n        var result = eval('target.fn('+ args.join(',') +')');\n        delete target.fn;\n        return result;\n     }\n  }\n  ```\n  - 应用1-apply方法数组参数特性的应用\n  实例1：求数组a = [2, 4, 1, 6]的最大值，不要遍历数组\n  ```\n  /*\n   target = window，this = Math.max，target.fn = window.Math.max\n   result = eval(target.fn(2,4,1,6))\n  */\n  Math.max.apply(null, a);\n  => 6\n  ```\n    实例2：实现一个log方法来代理console.log方法\n  ```\n    //arguments为一个对应于传递给函数参数的类数组对象Arguments，它是所有非箭头函数中可用的局部变量\n    function log() {\n      console.log.apply(null, arguments)\n    }\n    // \n    log(1, 2);\n    => 1\n    => 2\n  ```\n\n  \n  - 应用2-apply方法改变this指向的应用:\n  如下boy并没有getName方法，但是通过apply改变this的指向达到了在boy中调用girl的getName方法。\n  ```\n    function getName(firstName, lastName) {\n      console.log(`${firstName}.${this.name}.${lastName}`)\n    };\n    const girl = {\n      name: 'lucy',\n      getName,\n    };\n    const boy = {\n      name: 'Jeffrey'\n    };\n    //相当于boy.getName(['Michael', 'Jordan'])\n    girl.getName.apply(boy, ['Michael', 'Jordan']);\n    => Michael.Jeffrey.Jordan\n  ```\n- func.call(context, param)\n  func.call方法传入两个参数，第一个参数是上下文对象，第二个参数是传入的是一个参数列表，而不是单个数组。\n\n  如下，给出了call函数源码大义:\n  ```\n  Function.prototype.call = function(){\n    var target = arguments[0] || window\n    target.fn = this;\n    var args = [];\n    for(var i = 1; i < arguments.length; i ++){\n        args.push('arguments['+ i +']');\n    }\n    \n    var result = eval('target.fn(' + args.join(',')+')');\n    \n    delete target.fn;\n    return result;\n  }\n  ```\n  - 应用1-call方法改变this指向的应用\n  获取`<div><ul>1</ul><ul>2</ul></div>`的ul的内容\n  ```\n   const nodes = document.querySelectorAll('ul');\n   // nodes为伪数组，没有数组的遍历方法，通过[].slice.call返回真数组\n   const realArr = [].slice.call(nodes);\n   realArr.forEach((node)=> console.log(node.innerText))\n   => 1 \n   => 2\n  ```\n  \n**bind函数**\nbind方法不会立即执行，而是返回一个改变了上下文this后的函数。\n\n```\nconst newGetName = girl.getName.bind(boy);\nnewGetName('Michael', 'Jordan')\n=> Michael.Jeffrey.Jordan\n```  \n\n综上，this的指向由其具体的执行环境决定，同时也可以通过函数的原型方法apply、call以及bind来显式地改变this指向。\n\n\n\n","source":"_posts/JavaScript中的this.md","raw":"---\nlayout: post\ntitle: JavaScript中的this\ncategory : js\ntagline: \"Supporting tagline\"\ntags : [js]\ndescription: 在JavaScript中并没有OOP编程的概念，我们谈到的this不同于一些OOP编程里指向的实例化对象，它指的是运行时的上下文。所谓上下文，就是运行时所在的环境对象，比如你在公司，可能你的领导是你的部门经理，在家就是你媳妇儿一样，不同的场合上下文是不一样的。\ndate: 2016-1-02 16:17:25\n---\n\n### **this是什么** \n在JavaScript中并没有OOP编程的概念，我们谈到的this不同于一些OOP编程里指向的实例化对象，它指的是运行时的上下文。所谓上下文，就是运行时所在的环境对象，比如你在公司，可能你的领导是你的部门经理，在家就是你媳妇儿一样，不同的场合上下文是不一样的。\n\n### **this的应用场景** \n在JavaScript中的函数具有定义时上下文、运行时上下文以及上下文可改变的特点，也就是说函数中的this在不同的场合对应不同的值，来看如下例子：\n\n**全局调用(非严格模式)**\n全局调用即单纯的函数调用，如下: 例1中函数getName在全局调用，this指向全局对象，例2中尽管函数getNameFunc为boy对象的方法，但因其在全局调用，this同样指向全局对象。\n```\n// 例1\nvar name = 'lily';\nfunction getName() {\n  console.log(this.name)\n};\ngetName();\n=> lily\n\n// 例2\nvar boy = {\n  name: 'lucy',\n  getName,\n};\nvar getNameFunc = boy.getName;\ngetNameFunc();\n=> lily\n```\n\n**对象调用**\n\n实例对象调用自己的方法getName，this则指向改实例对象\n\n```\nvar boy = {\n  name: 'lucy',\n  getName,\n};\n\nboy.getName();\n=> lucy\n```\n\n**构造函数调用**\n\n构造函数生成一个新的对象，this就指向这个对象。\n\n```\nfunction person() {\n　this.name = 'xhm';\n}\n\nvar p = new person();\np.name // xhm\n```\n\n**func.call和func.apply**\nfunc.call和func.apply的作用一样都是改变执行上下文，只是接收参数的形式不同。\n\n- func.apply(context, param)\n  func.apply方法传入两个参数，第一个参数是上下文对象，为空则指向全局对象，第二个参数是函数参数组成的数组。\n  如下，给出了apply函数的源码大义，可以看到传入的数组参数会拼接成参数列表组成的一个字符串，并将需要执行的函数绑定到目标对象上。\n  ```\n  Function.prototype.apply = function(target, arr){\n    target = target || window\n    target.fn = this;\n     if(arr == []) {\n        return target.fn;\n        delete target.fn;\n     } else {\n        var args = [];\n        for(var i = 0; i < arr.length; i ++){\n          args.push('arr['+ i + ']');\n        }\n        //eval()函数会将传入的字符串当做JavaScript代码进行执行\n        var result = eval('target.fn('+ args.join(',') +')');\n        delete target.fn;\n        return result;\n     }\n  }\n  ```\n  - 应用1-apply方法数组参数特性的应用\n  实例1：求数组a = [2, 4, 1, 6]的最大值，不要遍历数组\n  ```\n  /*\n   target = window，this = Math.max，target.fn = window.Math.max\n   result = eval(target.fn(2,4,1,6))\n  */\n  Math.max.apply(null, a);\n  => 6\n  ```\n    实例2：实现一个log方法来代理console.log方法\n  ```\n    //arguments为一个对应于传递给函数参数的类数组对象Arguments，它是所有非箭头函数中可用的局部变量\n    function log() {\n      console.log.apply(null, arguments)\n    }\n    // \n    log(1, 2);\n    => 1\n    => 2\n  ```\n\n  \n  - 应用2-apply方法改变this指向的应用:\n  如下boy并没有getName方法，但是通过apply改变this的指向达到了在boy中调用girl的getName方法。\n  ```\n    function getName(firstName, lastName) {\n      console.log(`${firstName}.${this.name}.${lastName}`)\n    };\n    const girl = {\n      name: 'lucy',\n      getName,\n    };\n    const boy = {\n      name: 'Jeffrey'\n    };\n    //相当于boy.getName(['Michael', 'Jordan'])\n    girl.getName.apply(boy, ['Michael', 'Jordan']);\n    => Michael.Jeffrey.Jordan\n  ```\n- func.call(context, param)\n  func.call方法传入两个参数，第一个参数是上下文对象，第二个参数是传入的是一个参数列表，而不是单个数组。\n\n  如下，给出了call函数源码大义:\n  ```\n  Function.prototype.call = function(){\n    var target = arguments[0] || window\n    target.fn = this;\n    var args = [];\n    for(var i = 1; i < arguments.length; i ++){\n        args.push('arguments['+ i +']');\n    }\n    \n    var result = eval('target.fn(' + args.join(',')+')');\n    \n    delete target.fn;\n    return result;\n  }\n  ```\n  - 应用1-call方法改变this指向的应用\n  获取`<div><ul>1</ul><ul>2</ul></div>`的ul的内容\n  ```\n   const nodes = document.querySelectorAll('ul');\n   // nodes为伪数组，没有数组的遍历方法，通过[].slice.call返回真数组\n   const realArr = [].slice.call(nodes);\n   realArr.forEach((node)=> console.log(node.innerText))\n   => 1 \n   => 2\n  ```\n  \n**bind函数**\nbind方法不会立即执行，而是返回一个改变了上下文this后的函数。\n\n```\nconst newGetName = girl.getName.bind(boy);\nnewGetName('Michael', 'Jordan')\n=> Michael.Jeffrey.Jordan\n```  \n\n综上，this的指向由其具体的执行环境决定，同时也可以通过函数的原型方法apply、call以及bind来显式地改变this指向。\n\n\n\n","slug":"JavaScript中的this","published":1,"updated":"2019-01-04T08:37:25.541Z","_id":"cjq5aqcsc0006dszttzcmofjo","comments":1,"photos":[],"link":"","content":"<h3 id=\"this是什么\"><a href=\"#this是什么\" class=\"headerlink\" title=\"this是什么\"></a><strong>this是什么</strong></h3><p>在JavaScript中并没有OOP编程的概念，我们谈到的this不同于一些OOP编程里指向的实例化对象，它指的是运行时的上下文。所谓上下文，就是运行时所在的环境对象，比如你在公司，可能你的领导是你的部门经理，在家就是你媳妇儿一样，不同的场合上下文是不一样的。</p>\n<h3 id=\"this的应用场景\"><a href=\"#this的应用场景\" class=\"headerlink\" title=\"this的应用场景\"></a><strong>this的应用场景</strong></h3><p>在JavaScript中的函数具有定义时上下文、运行时上下文以及上下文可改变的特点，也就是说函数中的this在不同的场合对应不同的值，来看如下例子：</p>\n<p><strong>全局调用(非严格模式)</strong><br>全局调用即单纯的函数调用，如下: 例1中函数getName在全局调用，this指向全局对象，例2中尽管函数getNameFunc为boy对象的方法，但因其在全局调用，this同样指向全局对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例1</span><br><span class=\"line\">var name = &apos;lily&apos;;</span><br><span class=\"line\">function getName() &#123;</span><br><span class=\"line\">  console.log(this.name)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">getName();</span><br><span class=\"line\">=&gt; lily</span><br><span class=\"line\"></span><br><span class=\"line\">// 例2</span><br><span class=\"line\">var boy = &#123;</span><br><span class=\"line\">  name: &apos;lucy&apos;,</span><br><span class=\"line\">  getName,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var getNameFunc = boy.getName;</span><br><span class=\"line\">getNameFunc();</span><br><span class=\"line\">=&gt; lily</span><br></pre></td></tr></table></figure></p>\n<p><strong>对象调用</strong></p>\n<p>实例对象调用自己的方法getName，this则指向改实例对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var boy = &#123;</span><br><span class=\"line\">  name: &apos;lucy&apos;,</span><br><span class=\"line\">  getName,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">boy.getName();</span><br><span class=\"line\">=&gt; lucy</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数调用</strong></p>\n<p>构造函数生成一个新的对象，this就指向这个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function person() &#123;</span><br><span class=\"line\">　this.name = &apos;xhm&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new person();</span><br><span class=\"line\">p.name // xhm</span><br></pre></td></tr></table></figure>\n<p><strong>func.call和func.apply</strong><br>func.call和func.apply的作用一样都是改变执行上下文，只是接收参数的形式不同。</p>\n<ul>\n<li><p>func.apply(context, param)<br>func.apply方法传入两个参数，第一个参数是上下文对象，为空则指向全局对象，第二个参数是函数参数组成的数组。<br>如下，给出了apply函数的源码大义，可以看到传入的数组参数会拼接成参数列表组成的一个字符串，并将需要执行的函数绑定到目标对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.apply = function(target, arr)&#123;</span><br><span class=\"line\">  target = target || window</span><br><span class=\"line\">  target.fn = this;</span><br><span class=\"line\">   if(arr == []) &#123;</span><br><span class=\"line\">      return target.fn;</span><br><span class=\"line\">      delete target.fn;</span><br><span class=\"line\">   &#125; else &#123;</span><br><span class=\"line\">      var args = [];</span><br><span class=\"line\">      for(var i = 0; i &lt; arr.length; i ++)&#123;</span><br><span class=\"line\">        args.push(&apos;arr[&apos;+ i + &apos;]&apos;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      //eval()函数会将传入的字符串当做JavaScript代码进行执行</span><br><span class=\"line\">      var result = eval(&apos;target.fn(&apos;+ args.join(&apos;,&apos;) +&apos;)&apos;);</span><br><span class=\"line\">      delete target.fn;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>应用1-apply方法数组参数特性的应用<br>实例1：求数组a = [2, 4, 1, 6]的最大值，不要遍历数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> target = window，this = Math.max，target.fn = window.Math.max</span><br><span class=\"line\"> result = eval(target.fn(2,4,1,6))</span><br><span class=\"line\">*/</span><br><span class=\"line\">Math.max.apply(null, a);</span><br><span class=\"line\">=&gt; 6</span><br></pre></td></tr></table></figure>\n<p>实例2：实现一个log方法来代理console.log方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//arguments为一个对应于传递给函数参数的类数组对象Arguments，它是所有非箭头函数中可用的局部变量</span><br><span class=\"line\">function log() &#123;</span><br><span class=\"line\">  console.log.apply(null, arguments)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// </span><br><span class=\"line\">log(1, 2);</span><br><span class=\"line\">=&gt; 1</span><br><span class=\"line\">=&gt; 2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>应用2-apply方法改变this指向的应用:<br>如下boy并没有getName方法，但是通过apply改变this的指向达到了在boy中调用girl的getName方法。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getName(firstName, lastName) &#123;</span><br><span class=\"line\">  console.log(`$&#123;firstName&#125;.$&#123;this.name&#125;.$&#123;lastName&#125;`)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const girl = &#123;</span><br><span class=\"line\">  name: &apos;lucy&apos;,</span><br><span class=\"line\">  getName,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const boy = &#123;</span><br><span class=\"line\">  name: &apos;Jeffrey&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//相当于boy.getName([&apos;Michael&apos;, &apos;Jordan&apos;])</span><br><span class=\"line\">girl.getName.apply(boy, [&apos;Michael&apos;, &apos;Jordan&apos;]);</span><br><span class=\"line\">=&gt; Michael.Jeffrey.Jordan</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>func.call(context, param)<br>func.call方法传入两个参数，第一个参数是上下文对象，第二个参数是传入的是一个参数列表，而不是单个数组。</p>\n<p>如下，给出了call函数源码大义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.call = function()&#123;</span><br><span class=\"line\">  var target = arguments[0] || window</span><br><span class=\"line\">  target.fn = this;</span><br><span class=\"line\">  var args = [];</span><br><span class=\"line\">  for(var i = 1; i &lt; arguments.length; i ++)&#123;</span><br><span class=\"line\">      args.push(&apos;arguments[&apos;+ i +&apos;]&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  var result = eval(&apos;target.fn(&apos; + args.join(&apos;,&apos;)+&apos;)&apos;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  delete target.fn;</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>应用1-call方法改变this指向的应用<br>获取<code>&lt;div&gt;&lt;ul&gt;1&lt;/ul&gt;&lt;ul&gt;2&lt;/ul&gt;&lt;/div&gt;</code>的ul的内容<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const nodes = document.querySelectorAll(&apos;ul&apos;);</span><br><span class=\"line\">// nodes为伪数组，没有数组的遍历方法，通过[].slice.call返回真数组</span><br><span class=\"line\">const realArr = [].slice.call(nodes);</span><br><span class=\"line\">realArr.forEach((node)=&gt; console.log(node.innerText))</span><br><span class=\"line\">=&gt; 1 </span><br><span class=\"line\">=&gt; 2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>bind函数</strong><br>bind方法不会立即执行，而是返回一个改变了上下文this后的函数。</p>\n<pre><code>const newGetName = girl.getName.bind(boy);\nnewGetName(&apos;Michael&apos;, &apos;Jordan&apos;)\n=&gt; Michael.Jeffrey.Jordan\n</code></pre><p>综上，this的指向由其具体的执行环境决定，同时也可以通过函数的原型方法apply、call以及bind来显式地改变this指向。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"this是什么\"><a href=\"#this是什么\" class=\"headerlink\" title=\"this是什么\"></a><strong>this是什么</strong></h3><p>在JavaScript中并没有OOP编程的概念，我们谈到的this不同于一些OOP编程里指向的实例化对象，它指的是运行时的上下文。所谓上下文，就是运行时所在的环境对象，比如你在公司，可能你的领导是你的部门经理，在家就是你媳妇儿一样，不同的场合上下文是不一样的。</p>\n<h3 id=\"this的应用场景\"><a href=\"#this的应用场景\" class=\"headerlink\" title=\"this的应用场景\"></a><strong>this的应用场景</strong></h3><p>在JavaScript中的函数具有定义时上下文、运行时上下文以及上下文可改变的特点，也就是说函数中的this在不同的场合对应不同的值，来看如下例子：</p>\n<p><strong>全局调用(非严格模式)</strong><br>全局调用即单纯的函数调用，如下: 例1中函数getName在全局调用，this指向全局对象，例2中尽管函数getNameFunc为boy对象的方法，但因其在全局调用，this同样指向全局对象。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 例1</span><br><span class=\"line\">var name = &apos;lily&apos;;</span><br><span class=\"line\">function getName() &#123;</span><br><span class=\"line\">  console.log(this.name)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">getName();</span><br><span class=\"line\">=&gt; lily</span><br><span class=\"line\"></span><br><span class=\"line\">// 例2</span><br><span class=\"line\">var boy = &#123;</span><br><span class=\"line\">  name: &apos;lucy&apos;,</span><br><span class=\"line\">  getName,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var getNameFunc = boy.getName;</span><br><span class=\"line\">getNameFunc();</span><br><span class=\"line\">=&gt; lily</span><br></pre></td></tr></table></figure></p>\n<p><strong>对象调用</strong></p>\n<p>实例对象调用自己的方法getName，this则指向改实例对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var boy = &#123;</span><br><span class=\"line\">  name: &apos;lucy&apos;,</span><br><span class=\"line\">  getName,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">boy.getName();</span><br><span class=\"line\">=&gt; lucy</span><br></pre></td></tr></table></figure>\n<p><strong>构造函数调用</strong></p>\n<p>构造函数生成一个新的对象，this就指向这个对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function person() &#123;</span><br><span class=\"line\">　this.name = &apos;xhm&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new person();</span><br><span class=\"line\">p.name // xhm</span><br></pre></td></tr></table></figure>\n<p><strong>func.call和func.apply</strong><br>func.call和func.apply的作用一样都是改变执行上下文，只是接收参数的形式不同。</p>\n<ul>\n<li><p>func.apply(context, param)<br>func.apply方法传入两个参数，第一个参数是上下文对象，为空则指向全局对象，第二个参数是函数参数组成的数组。<br>如下，给出了apply函数的源码大义，可以看到传入的数组参数会拼接成参数列表组成的一个字符串，并将需要执行的函数绑定到目标对象上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.apply = function(target, arr)&#123;</span><br><span class=\"line\">  target = target || window</span><br><span class=\"line\">  target.fn = this;</span><br><span class=\"line\">   if(arr == []) &#123;</span><br><span class=\"line\">      return target.fn;</span><br><span class=\"line\">      delete target.fn;</span><br><span class=\"line\">   &#125; else &#123;</span><br><span class=\"line\">      var args = [];</span><br><span class=\"line\">      for(var i = 0; i &lt; arr.length; i ++)&#123;</span><br><span class=\"line\">        args.push(&apos;arr[&apos;+ i + &apos;]&apos;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      //eval()函数会将传入的字符串当做JavaScript代码进行执行</span><br><span class=\"line\">      var result = eval(&apos;target.fn(&apos;+ args.join(&apos;,&apos;) +&apos;)&apos;);</span><br><span class=\"line\">      delete target.fn;</span><br><span class=\"line\">      return result;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>应用1-apply方法数组参数特性的应用<br>实例1：求数组a = [2, 4, 1, 6]的最大值，不要遍历数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> target = window，this = Math.max，target.fn = window.Math.max</span><br><span class=\"line\"> result = eval(target.fn(2,4,1,6))</span><br><span class=\"line\">*/</span><br><span class=\"line\">Math.max.apply(null, a);</span><br><span class=\"line\">=&gt; 6</span><br></pre></td></tr></table></figure>\n<p>实例2：实现一个log方法来代理console.log方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//arguments为一个对应于传递给函数参数的类数组对象Arguments，它是所有非箭头函数中可用的局部变量</span><br><span class=\"line\">function log() &#123;</span><br><span class=\"line\">  console.log.apply(null, arguments)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// </span><br><span class=\"line\">log(1, 2);</span><br><span class=\"line\">=&gt; 1</span><br><span class=\"line\">=&gt; 2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>应用2-apply方法改变this指向的应用:<br>如下boy并没有getName方法，但是通过apply改变this的指向达到了在boy中调用girl的getName方法。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getName(firstName, lastName) &#123;</span><br><span class=\"line\">  console.log(`$&#123;firstName&#125;.$&#123;this.name&#125;.$&#123;lastName&#125;`)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const girl = &#123;</span><br><span class=\"line\">  name: &apos;lucy&apos;,</span><br><span class=\"line\">  getName,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">const boy = &#123;</span><br><span class=\"line\">  name: &apos;Jeffrey&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">//相当于boy.getName([&apos;Michael&apos;, &apos;Jordan&apos;])</span><br><span class=\"line\">girl.getName.apply(boy, [&apos;Michael&apos;, &apos;Jordan&apos;]);</span><br><span class=\"line\">=&gt; Michael.Jeffrey.Jordan</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>func.call(context, param)<br>func.call方法传入两个参数，第一个参数是上下文对象，第二个参数是传入的是一个参数列表，而不是单个数组。</p>\n<p>如下，给出了call函数源码大义:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.prototype.call = function()&#123;</span><br><span class=\"line\">  var target = arguments[0] || window</span><br><span class=\"line\">  target.fn = this;</span><br><span class=\"line\">  var args = [];</span><br><span class=\"line\">  for(var i = 1; i &lt; arguments.length; i ++)&#123;</span><br><span class=\"line\">      args.push(&apos;arguments[&apos;+ i +&apos;]&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  var result = eval(&apos;target.fn(&apos; + args.join(&apos;,&apos;)+&apos;)&apos;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  delete target.fn;</span><br><span class=\"line\">  return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>应用1-call方法改变this指向的应用<br>获取<code>&lt;div&gt;&lt;ul&gt;1&lt;/ul&gt;&lt;ul&gt;2&lt;/ul&gt;&lt;/div&gt;</code>的ul的内容<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const nodes = document.querySelectorAll(&apos;ul&apos;);</span><br><span class=\"line\">// nodes为伪数组，没有数组的遍历方法，通过[].slice.call返回真数组</span><br><span class=\"line\">const realArr = [].slice.call(nodes);</span><br><span class=\"line\">realArr.forEach((node)=&gt; console.log(node.innerText))</span><br><span class=\"line\">=&gt; 1 </span><br><span class=\"line\">=&gt; 2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>bind函数</strong><br>bind方法不会立即执行，而是返回一个改变了上下文this后的函数。</p>\n<pre><code>const newGetName = girl.getName.bind(boy);\nnewGetName(&apos;Michael&apos;, &apos;Jordan&apos;)\n=&gt; Michael.Jeffrey.Jordan\n</code></pre><p>综上，this的指向由其具体的执行环境决定，同时也可以通过函数的原型方法apply、call以及bind来显式地改变this指向。</p>\n"},{"layout":"post","title":"Git常用命令","tagline":"Supporting tagline","description":"Git作为一种流行的版本管理系统已经广泛应用于我们的日常开发中，在这里记录下日常遇到的关于git的常见用法，以备后续查询。","date":"2016-06-24T15:30:09.000Z","_content":"\ngit的命令很多，为了减少后续查询的时间在这里列出了平常用到的一些命令。关于这些命令我们对git需要有一个基本的认识，如下图，git分为了几个区：\n<div align=center>\n![git structure sketch](/assets/gitSketch.png)\n\n\n#### 创建代码仓库\n\n```\n1）在当前文件夹创建仓库 \n$ git init \n\n2）新建文件夹并创建仓库\n$ git init [project-name]\n\n3）克隆远程分支，默认为master分支\n$ git clone [url] -b [branch-name] [your-folder]\n// 克隆远程dev分支到MyProject\n例: $ git clone https://github.com/fengyueran/Test.git -b dev MyProject\n```\n#### 配置\n\n通过git config可以配置git的环境变量，这些变量存在三个不同的地方\n- /etc/gitconfig文件：适用于所有用户。\n- ~/.gitconfig文件：适用于当前用户。\n- .git/config文件：\b当前项目中的配置文件，适用于当前项目。\n\n每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆/etc/gitconfig中的同名变量。\n```\n1）查看配置信息(包括用户名、邮箱等)\n$ git config --list\n\n2）编辑配置文件(--system/global)\n$ git config -e \n// 编辑当前用户的配置文件, --global:适用于当前用户， --system:适用于所有用户，不带参数: 当前项目\n例: $ git config -e --global\n\n3）设置当前用户信息\n$ git config --global user.name \"[name]\"\n$ git config --global user.email \"[email address]\"\n\n4）清除当前用户信息\n$ git config --unset --global user.name \"[name]\"\n$ git config --unset --global user.email \"[email address]\"\n```\n#### 文件\b操作\n```\n1）添加文件file1，file2...到暂存区\n$ git add [file1] [file2]\n\n2）添加当前目录所有文件到暂存区\n$ git add .\n\n3) 添加目录(包括子目录)到暂存区\n$ git add [dir]\n\n4) 删除当前目录没有track过的文件\n$ git clean -f\n\n5) 删除当前目录没有track过的文件和文件夹\n$ git clean -df\n\n6) 删除所有本地未提交的修改\n$ git checkout .\n\n7）提交暂存区到仓库区 \n$ git commit -m [message]\n\n8）追加到上一次提交 \n$ git commit --amend -m [message]\n//修改上次提交\n例: $ git commit --amend\n```\n\n9）撤销某次提交 \n$ git revert [commit] \n例: $ git revert fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff\n```\n#### 查看信息\n```\n1）查看当前分支及其所有父类的提交历史\n$ git log \n\n2）可以查看所有分支的所有操作记录(包括已经被删除的commit记录和reset操作）\n$ git reflog\n\n3）查看变更的文件\n$ git status\n\n4）查看b\b提交相对a提交的差异\n$ git diff [a-commit] [b-commit]\n\n5）查看工作区与最新commit的前一次commit的差异，当从远程拉取更新时即可查看变动的内容。\n$ git diff HEAD^\n\n```\n#### 远程操作\n```\n1）列出远程仓库名\n$ git remote\n\n2）列出远程仓库名及对应的地址\n$ git remote –v  \n-> origin\tgit@github.com:fengyueran/iOSNote.git (fetch)\n-> origin\tgit@github.com:fengyueran/iOSNote.git (push)\n\n3）推送当前本地分支到远程分支\n$ git push [remote-repository-name] [branch-name]\n// 将当前分支dev推送到远程仓库origin的remoteDev分支\n例: $ git push origin dev:remoteDev\n ->   * [new branch]      dev -> remoteDev\n// 省略远程仓库分支名则在远程创建当前同名分支dev\n例: $ git push origin dev\n ->   * [new branch]      dev -> dev\n\n4）删除远程仓库origin的分支dev\n例: $ git push origin --delete dev\n\n5）添加远程仓库\n$ git remote add [repository] [url]\n// 在远程添加名为pb的仓库\n例: $ git remote add pb git://github.com/fengyueran/test.git\n\n6）重设远程仓库\n$ git remote set-url [repository] [url]\n// 在远程添加名为pb的仓库\n例: $ git remote set-url origin git://github.com/fengyueran/test.git\n\n1) 拉取远端数据\n// 使你与另一仓库同步，提取你本地所没有的数据，不merge，拉取下来的数据在.git/FETCH_HEAD下\n$ git fetch \n// 将你的仓库与远端仓库origin同步，提取所有它独有的数据到本地分支以合并或者怎样。\n$ git fetch origin\n// 下面的fetch操作使用远程dev分支在本地创建localDev分支(但不会切换到该分支)，如果本地不存在localDev分支,则会自动创建一个新的localDev分支,\n如果本地存在localDev分支, 并且是`fast forward', 则自动合并两个分支, 否则, 会阻止以上操作。\n$ git fetch origin dev:localDev\n-> * [new branch]      dev        -> localDev\n\n8）从远程仓库提取数据并尝试合并到当前分支\n// 基本上，该命令就是在git fetch之后紧接着git merge远端分支到当前分支\n$ git pull \n\n//当新建分支时，如果直接pull或push需要参数远程仓库名和分支名\n$ git pull origin dev\n如果想省略仓库名和分支名则需要建立追踪关系，执行如下命令\n$ git pull --set-upstream origin dev\n\n\n//merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点, 因而能产生一个更为整洁的提交历史\n$ git pull --rebase\n//假设提交线图在执行pull前是这样的：\n      C1---D1---E1  remotes/origin/master\n      /\n  A---B---C2---D2  master\n执行git pull则提交线图会变成这样：\n      C1---D1---E1  remotes/origin/master\n      /          \\\n  A---B---C2---D2-F  master\n即会产生一个多余的合并历史，\n如果执行git pull --rebase则提交线图会变成这样：\n    remotes/origin/master\n                  |\n  A---B---C1---D1---C2'---D2'  master\n可以看到，应用rebase则不会有新的提交F。C2,D2删除后重新提交为C2',D2'了。\n```\n\n#### 分支操作\n\n```\n1）查看本地分支\n$ git branch\n\n2）查看远程分支,远程分支会用红色表示出来(如果你开了颜色支持的话）\n$ git branch -r\n\n3）新建分支\n$ git branch [branch-name]\n例: $ git branch dev\n\n4）切换分支\n$ git checkout [branch-name]\n例: $ git checkout dev\n\n5）新建并切换分支 \n$ git checkout -b [branch-name]\n// 当前分支的记录都会到新分支dev上\n例: $ git checkout -b dev\n\n6）删除分支 \n$ git branch -D [branch-name]\n\n7）叫起合并冲突工具kdiff3\n$ git mergetool -t kdiff3\n\n8) 合并某个分支到当前分支\n// 如果不是`fast forward'则会产生合并的提交历史\n$ git merge [branch-name]\n// 将hotfix分支合并到当前分支\n例: $ git merge hotfix\n// 无论是否是`fast forward'都产生合并的提交历史\n例: $ git merge hotfix --no-f\n\n9) 选择任意一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n10）合并提交历史 \n// 当我们由master分支切换到新的分支dev工作，工作结束后想merge回master，如果直接在master应用git merge dev，\ndev的提交历史就会出现在master中，有时这些记录很琐碎没有必要添加到master上，用squash就能解决这一问题。\na:squash后dev上的提交就变成了新的文件\n  $ git merge --squash dev\nb:重新commit代替之前所有提交\n  $ git commit -m \"dev\"\n\n```\n#### 版本回退\n\n```\n1）储存临时文件\n//当工作区有未提交的文件，又想切换到另一个branch时就可以用git stash暂时存储\n$ git stash \n\n2）查看存储了哪些文件\n$ git stash list\n\n3）应用存储的临时文件\n// 当回到之前的dirty工作区时可以通过git stash apply来恢复之前未提交的文件，也可以在其他branch应用这些存储的临时文件\n$ git stash apply\n\n4) 让单个文件回退到指定的版本\na:进入到文件所在文件目录，或者能找到文件的路径\n  $ git reflog test.js\n  -> 60e207a (HEAD -> master) HEAD@{0}: commit: test.js +2\n     1435819 HEAD@{1}: commit: test.js +1\nb:回退到指定的版本\n  $  git reset 1435819 test.js\n\n```\n#### tag\n\n```\n1) 轻量级tag\n$ git tag [version]\n例: $ git tag v1.0.0\n \n2) 创建一个含附注类型的标签非常简单\n$ git tag -a [version] -m \"[detail]\"\n$ git tag -a v1.1.1 -m \"CuraCloudMI version 1.1.1\"\n\n3) 查看tag\n$ git show [version]\n\n4) 删除tag\ngit tag -d [version]\n```\n#### 其他\n```\n1) 查看某个命令的帮助\ngit help [command-name]\n\n2) 保留空文件\n在空文件夹中新建.gitkeep文件\n\n3) 忽略某些文件\n在.gitignore文件中添加需要忽略的文件夹或文件\n例: \n//忽略Pods文件夹下的所有文件\nplatforms/ios/Pods\n\n//忽略www下的所有文件除了plugins\nplatforms/ios/www/*\n!platforms/ios/www/plugins\n\n```\n\n\n\n\n\n\n","source":"_posts/git的常用命令简介.md","raw":"---\nlayout: post\ntitle: Git常用命令\ncategory : Git\ntagline: \"Supporting tagline\"\ntags : [Git]\ndescription : Git作为一种流行的版本管理系统已经广泛应用于我们的日常开发中，在这里记录下日常遇到的关于git的常见用法，以备后续查询。\ndate: 2016-6-24 23:30:09\n---\n\ngit的命令很多，为了减少后续查询的时间在这里列出了平常用到的一些命令。关于这些命令我们对git需要有一个基本的认识，如下图，git分为了几个区：\n<div align=center>\n![git structure sketch](/assets/gitSketch.png)\n\n\n#### 创建代码仓库\n\n```\n1）在当前文件夹创建仓库 \n$ git init \n\n2）新建文件夹并创建仓库\n$ git init [project-name]\n\n3）克隆远程分支，默认为master分支\n$ git clone [url] -b [branch-name] [your-folder]\n// 克隆远程dev分支到MyProject\n例: $ git clone https://github.com/fengyueran/Test.git -b dev MyProject\n```\n#### 配置\n\n通过git config可以配置git的环境变量，这些变量存在三个不同的地方\n- /etc/gitconfig文件：适用于所有用户。\n- ~/.gitconfig文件：适用于当前用户。\n- .git/config文件：\b当前项目中的配置文件，适用于当前项目。\n\n每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆/etc/gitconfig中的同名变量。\n```\n1）查看配置信息(包括用户名、邮箱等)\n$ git config --list\n\n2）编辑配置文件(--system/global)\n$ git config -e \n// 编辑当前用户的配置文件, --global:适用于当前用户， --system:适用于所有用户，不带参数: 当前项目\n例: $ git config -e --global\n\n3）设置当前用户信息\n$ git config --global user.name \"[name]\"\n$ git config --global user.email \"[email address]\"\n\n4）清除当前用户信息\n$ git config --unset --global user.name \"[name]\"\n$ git config --unset --global user.email \"[email address]\"\n```\n#### 文件\b操作\n```\n1）添加文件file1，file2...到暂存区\n$ git add [file1] [file2]\n\n2）添加当前目录所有文件到暂存区\n$ git add .\n\n3) 添加目录(包括子目录)到暂存区\n$ git add [dir]\n\n4) 删除当前目录没有track过的文件\n$ git clean -f\n\n5) 删除当前目录没有track过的文件和文件夹\n$ git clean -df\n\n6) 删除所有本地未提交的修改\n$ git checkout .\n\n7）提交暂存区到仓库区 \n$ git commit -m [message]\n\n8）追加到上一次提交 \n$ git commit --amend -m [message]\n//修改上次提交\n例: $ git commit --amend\n```\n\n9）撤销某次提交 \n$ git revert [commit] \n例: $ git revert fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff\n```\n#### 查看信息\n```\n1）查看当前分支及其所有父类的提交历史\n$ git log \n\n2）可以查看所有分支的所有操作记录(包括已经被删除的commit记录和reset操作）\n$ git reflog\n\n3）查看变更的文件\n$ git status\n\n4）查看b\b提交相对a提交的差异\n$ git diff [a-commit] [b-commit]\n\n5）查看工作区与最新commit的前一次commit的差异，当从远程拉取更新时即可查看变动的内容。\n$ git diff HEAD^\n\n```\n#### 远程操作\n```\n1）列出远程仓库名\n$ git remote\n\n2）列出远程仓库名及对应的地址\n$ git remote –v  \n-> origin\tgit@github.com:fengyueran/iOSNote.git (fetch)\n-> origin\tgit@github.com:fengyueran/iOSNote.git (push)\n\n3）推送当前本地分支到远程分支\n$ git push [remote-repository-name] [branch-name]\n// 将当前分支dev推送到远程仓库origin的remoteDev分支\n例: $ git push origin dev:remoteDev\n ->   * [new branch]      dev -> remoteDev\n// 省略远程仓库分支名则在远程创建当前同名分支dev\n例: $ git push origin dev\n ->   * [new branch]      dev -> dev\n\n4）删除远程仓库origin的分支dev\n例: $ git push origin --delete dev\n\n5）添加远程仓库\n$ git remote add [repository] [url]\n// 在远程添加名为pb的仓库\n例: $ git remote add pb git://github.com/fengyueran/test.git\n\n6）重设远程仓库\n$ git remote set-url [repository] [url]\n// 在远程添加名为pb的仓库\n例: $ git remote set-url origin git://github.com/fengyueran/test.git\n\n1) 拉取远端数据\n// 使你与另一仓库同步，提取你本地所没有的数据，不merge，拉取下来的数据在.git/FETCH_HEAD下\n$ git fetch \n// 将你的仓库与远端仓库origin同步，提取所有它独有的数据到本地分支以合并或者怎样。\n$ git fetch origin\n// 下面的fetch操作使用远程dev分支在本地创建localDev分支(但不会切换到该分支)，如果本地不存在localDev分支,则会自动创建一个新的localDev分支,\n如果本地存在localDev分支, 并且是`fast forward', 则自动合并两个分支, 否则, 会阻止以上操作。\n$ git fetch origin dev:localDev\n-> * [new branch]      dev        -> localDev\n\n8）从远程仓库提取数据并尝试合并到当前分支\n// 基本上，该命令就是在git fetch之后紧接着git merge远端分支到当前分支\n$ git pull \n\n//当新建分支时，如果直接pull或push需要参数远程仓库名和分支名\n$ git pull origin dev\n如果想省略仓库名和分支名则需要建立追踪关系，执行如下命令\n$ git pull --set-upstream origin dev\n\n\n//merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点, 因而能产生一个更为整洁的提交历史\n$ git pull --rebase\n//假设提交线图在执行pull前是这样的：\n      C1---D1---E1  remotes/origin/master\n      /\n  A---B---C2---D2  master\n执行git pull则提交线图会变成这样：\n      C1---D1---E1  remotes/origin/master\n      /          \\\n  A---B---C2---D2-F  master\n即会产生一个多余的合并历史，\n如果执行git pull --rebase则提交线图会变成这样：\n    remotes/origin/master\n                  |\n  A---B---C1---D1---C2'---D2'  master\n可以看到，应用rebase则不会有新的提交F。C2,D2删除后重新提交为C2',D2'了。\n```\n\n#### 分支操作\n\n```\n1）查看本地分支\n$ git branch\n\n2）查看远程分支,远程分支会用红色表示出来(如果你开了颜色支持的话）\n$ git branch -r\n\n3）新建分支\n$ git branch [branch-name]\n例: $ git branch dev\n\n4）切换分支\n$ git checkout [branch-name]\n例: $ git checkout dev\n\n5）新建并切换分支 \n$ git checkout -b [branch-name]\n// 当前分支的记录都会到新分支dev上\n例: $ git checkout -b dev\n\n6）删除分支 \n$ git branch -D [branch-name]\n\n7）叫起合并冲突工具kdiff3\n$ git mergetool -t kdiff3\n\n8) 合并某个分支到当前分支\n// 如果不是`fast forward'则会产生合并的提交历史\n$ git merge [branch-name]\n// 将hotfix分支合并到当前分支\n例: $ git merge hotfix\n// 无论是否是`fast forward'都产生合并的提交历史\n例: $ git merge hotfix --no-f\n\n9) 选择任意一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n10）合并提交历史 \n// 当我们由master分支切换到新的分支dev工作，工作结束后想merge回master，如果直接在master应用git merge dev，\ndev的提交历史就会出现在master中，有时这些记录很琐碎没有必要添加到master上，用squash就能解决这一问题。\na:squash后dev上的提交就变成了新的文件\n  $ git merge --squash dev\nb:重新commit代替之前所有提交\n  $ git commit -m \"dev\"\n\n```\n#### 版本回退\n\n```\n1）储存临时文件\n//当工作区有未提交的文件，又想切换到另一个branch时就可以用git stash暂时存储\n$ git stash \n\n2）查看存储了哪些文件\n$ git stash list\n\n3）应用存储的临时文件\n// 当回到之前的dirty工作区时可以通过git stash apply来恢复之前未提交的文件，也可以在其他branch应用这些存储的临时文件\n$ git stash apply\n\n4) 让单个文件回退到指定的版本\na:进入到文件所在文件目录，或者能找到文件的路径\n  $ git reflog test.js\n  -> 60e207a (HEAD -> master) HEAD@{0}: commit: test.js +2\n     1435819 HEAD@{1}: commit: test.js +1\nb:回退到指定的版本\n  $  git reset 1435819 test.js\n\n```\n#### tag\n\n```\n1) 轻量级tag\n$ git tag [version]\n例: $ git tag v1.0.0\n \n2) 创建一个含附注类型的标签非常简单\n$ git tag -a [version] -m \"[detail]\"\n$ git tag -a v1.1.1 -m \"CuraCloudMI version 1.1.1\"\n\n3) 查看tag\n$ git show [version]\n\n4) 删除tag\ngit tag -d [version]\n```\n#### 其他\n```\n1) 查看某个命令的帮助\ngit help [command-name]\n\n2) 保留空文件\n在空文件夹中新建.gitkeep文件\n\n3) 忽略某些文件\n在.gitignore文件中添加需要忽略的文件夹或文件\n例: \n//忽略Pods文件夹下的所有文件\nplatforms/ios/Pods\n\n//忽略www下的所有文件除了plugins\nplatforms/ios/www/*\n!platforms/ios/www/plugins\n\n```\n\n\n\n\n\n\n","slug":"git的常用命令简介","published":1,"updated":"2018-12-23T12:31:33.510Z","comments":1,"photos":[],"link":"","_id":"cjq5aqcsd0007dszt6dv75i40","content":"<p>git的命令很多，为了减少后续查询的时间在这里列出了平常用到的一些命令。关于这些命令我们对git需要有一个基本的认识，如下图，git分为了几个区：</p>\n<p><div align=\"center\"><br><img src=\"/assets/gitSketch.png\" alt=\"git structure sketch\"></div></p>\n<h4 id=\"创建代码仓库\"><a href=\"#创建代码仓库\" class=\"headerlink\" title=\"创建代码仓库\"></a>创建代码仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）在当前文件夹创建仓库 </span><br><span class=\"line\">$ git init </span><br><span class=\"line\"></span><br><span class=\"line\">2）新建文件夹并创建仓库</span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\">3）克隆远程分支，默认为master分支</span><br><span class=\"line\">$ git clone [url] -b [branch-name] [your-folder]</span><br><span class=\"line\">// 克隆远程dev分支到MyProject</span><br><span class=\"line\">例: $ git clone https://github.com/fengyueran/Test.git -b dev MyProject</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>通过git config可以配置git的环境变量，这些变量存在三个不同的地方</p>\n<ul>\n<li>/etc/gitconfig文件：适用于所有用户。</li>\n<li>~/.gitconfig文件：适用于当前用户。</li>\n<li>.git/config文件：\b当前项目中的配置文件，适用于当前项目。</li>\n</ul>\n<p>每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆/etc/gitconfig中的同名变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）查看配置信息(包括用户名、邮箱等)</span><br><span class=\"line\">$ git config --list</span><br><span class=\"line\"></span><br><span class=\"line\">2）编辑配置文件(--system/global)</span><br><span class=\"line\">$ git config -e </span><br><span class=\"line\">// 编辑当前用户的配置文件, --global:适用于当前用户， --system:适用于所有用户，不带参数: 当前项目</span><br><span class=\"line\">例: $ git config -e --global</span><br><span class=\"line\"></span><br><span class=\"line\">3）设置当前用户信息</span><br><span class=\"line\">$ git config --global user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;[email address]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">4）清除当前用户信息</span><br><span class=\"line\">$ git config --unset --global user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config --unset --global user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件\b操作\"></a>文件\b操作</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）添加文件file1，file2...到暂存区</span><br><span class=\"line\">$ git add [file1] [file2]</span><br><span class=\"line\"></span><br><span class=\"line\">2）添加当前目录所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\">3) 添加目录(包括子目录)到暂存区</span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\">4) 删除当前目录没有track过的文件</span><br><span class=\"line\">$ git clean -f</span><br><span class=\"line\"></span><br><span class=\"line\">5) 删除当前目录没有track过的文件和文件夹</span><br><span class=\"line\">$ git clean -df</span><br><span class=\"line\"></span><br><span class=\"line\">6) 删除所有本地未提交的修改</span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\">7）提交暂存区到仓库区 </span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\">8）追加到上一次提交 </span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\">//修改上次提交</span><br><span class=\"line\">例: $ git commit --amend</span><br></pre></td></tr></table></figure>\n<p>9）撤销某次提交<br>$ git revert [commit]<br>例: $ git revert fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 查看信息</span><br></pre></td></tr></table></figure></p>\n<p>1）查看当前分支及其所有父类的提交历史<br>$ git log </p>\n<p>2）可以查看所有分支的所有操作记录(包括已经被删除的commit记录和reset操作）<br>$ git reflog</p>\n<p>3）查看变更的文件<br>$ git status</p>\n<p>4）查看b\b提交相对a提交的差异<br>$ git diff [a-commit] [b-commit]</p>\n<p>5）查看工作区与最新commit的前一次commit的差异，当从远程拉取更新时即可查看变动的内容。<br>$ git diff HEAD^</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 远程操作</span><br></pre></td></tr></table></figure>\n<p>1）列出远程仓库名<br>$ git remote</p>\n<p>2）列出远程仓库名及对应的地址<br>$ git remote –v<br>-&gt; origin    <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:fengyueran/iOSNote.git (fetch)<br>-&gt; origin    <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:fengyueran/iOSNote.git (push)</p>\n<p>3）推送当前本地分支到远程分支<br>$ git push [remote-repository-name] [branch-name]<br>// 将当前分支dev推送到远程仓库origin的remoteDev分支<br>例: $ git push origin dev:remoteDev<br> -&gt;   <em> [new branch]      dev -&gt; remoteDev<br>// 省略远程仓库分支名则在远程创建当前同名分支dev<br>例: $ git push origin dev<br> -&gt;   </em> [new branch]      dev -&gt; dev</p>\n<p>4）删除远程仓库origin的分支dev<br>例: $ git push origin –delete dev</p>\n<p>5）添加远程仓库<br>$ git remote add [repository] [url]<br>// 在远程添加名为pb的仓库<br>例: $ git remote add pb git://github.com/fengyueran/test.git</p>\n<p>6）重设远程仓库<br>$ git remote set-url [repository] [url]<br>// 在远程添加名为pb的仓库<br>例: $ git remote set-url origin git://github.com/fengyueran/test.git</p>\n<p>1) 拉取远端数据<br>// 使你与另一仓库同步，提取你本地所没有的数据，不merge，拉取下来的数据在.git/FETCH_HEAD下<br>$ git fetch<br>// 将你的仓库与远端仓库origin同步，提取所有它独有的数据到本地分支以合并或者怎样。<br>$ git fetch origin<br>// 下面的fetch操作使用远程dev分支在本地创建localDev分支(但不会切换到该分支)，如果本地不存在localDev分支,则会自动创建一个新的localDev分支,<br>如果本地存在localDev分支, 并且是`fast forward’, 则自动合并两个分支, 否则, 会阻止以上操作。<br>$ git fetch origin dev:localDev<br>-&gt; * [new branch]      dev        -&gt; localDev</p>\n<p>8）从远程仓库提取数据并尝试合并到当前分支<br>// 基本上，该命令就是在git fetch之后紧接着git merge远端分支到当前分支<br>$ git pull </p>\n<p>//当新建分支时，如果直接pull或push需要参数远程仓库名和分支名<br>$ git pull origin dev<br>如果想省略仓库名和分支名则需要建立追踪关系，执行如下命令<br>$ git pull –set-upstream origin dev</p>\n<p>//merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点, 因而能产生一个更为整洁的提交历史<br>$ git pull –rebase<br>//假设提交线图在执行pull前是这样的：<br>      C1—D1—E1  remotes/origin/master<br>      /<br>  A—B—C2—D2  master<br>执行git pull则提交线图会变成这样：<br>      C1—D1—E1  remotes/origin/master<br>      /          \\<br>  A—B—C2—D2-F  master<br>即会产生一个多余的合并历史，<br>如果执行git pull –rebase则提交线图会变成这样：<br>    remotes/origin/master<br>                  |<br>  A—B—C1—D1—C2’—D2’  master<br>可以看到，应用rebase则不会有新的提交F。C2,D2删除后重新提交为C2’,D2’了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 分支操作</span><br></pre></td></tr></table></figure></p>\n<p>1）查看本地分支<br>$ git branch</p>\n<p>2）查看远程分支,远程分支会用红色表示出来(如果你开了颜色支持的话）<br>$ git branch -r</p>\n<p>3）新建分支<br>$ git branch [branch-name]<br>例: $ git branch dev</p>\n<p>4）切换分支<br>$ git checkout [branch-name]<br>例: $ git checkout dev</p>\n<p>5）新建并切换分支<br>$ git checkout -b [branch-name]<br>// 当前分支的记录都会到新分支dev上<br>例: $ git checkout -b dev</p>\n<p>6）删除分支<br>$ git branch -D [branch-name]</p>\n<p>7）叫起合并冲突工具kdiff3<br>$ git mergetool -t kdiff3</p>\n<p>8) 合并某个分支到当前分支<br>// 如果不是<code>fast forward&#39;则会产生合并的提交历史\n$ git merge [branch-name]\n// 将hotfix分支合并到当前分支\n例: $ git merge hotfix\n// 无论是否是</code>fast forward’都产生合并的提交历史<br>例: $ git merge hotfix –no-f</p>\n<p>9) 选择任意一个commit，合并进当前分支<br>$ git cherry-pick [commit]</p>\n<p>10）合并提交历史<br>// 当我们由master分支切换到新的分支dev工作，工作结束后想merge回master，如果直接在master应用git merge dev，<br>dev的提交历史就会出现在master中，有时这些记录很琐碎没有必要添加到master上，用squash就能解决这一问题。<br>a:squash后dev上的提交就变成了新的文件<br>  $ git merge –squash dev<br>b:重新commit代替之前所有提交<br>  $ git commit -m “dev”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 版本回退</span><br></pre></td></tr></table></figure>\n<p>1）储存临时文件<br>//当工作区有未提交的文件，又想切换到另一个branch时就可以用git stash暂时存储<br>$ git stash </p>\n<p>2）查看存储了哪些文件<br>$ git stash list</p>\n<p>3）应用存储的临时文件<br>// 当回到之前的dirty工作区时可以通过git stash apply来恢复之前未提交的文件，也可以在其他branch应用这些存储的临时文件<br>$ git stash apply</p>\n<p>4) 让单个文件回退到指定的版本<br>a:进入到文件所在文件目录，或者能找到文件的路径<br>  $ git reflog test.js<br>  -&gt; 60e207a (HEAD -&gt; master) HEAD@{0}: commit: test.js +2<br>     1435819 HEAD@{1}: commit: test.js +1<br>b:回退到指定的版本<br>  $  git reset 1435819 test.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### tag</span><br></pre></td></tr></table></figure>\n<p>1) 轻量级tag<br>$ git tag [version]<br>例: $ git tag v1.0.0</p>\n<p>2) 创建一个含附注类型的标签非常简单<br>$ git tag -a [version] -m “[detail]”<br>$ git tag -a v1.1.1 -m “CuraCloudMI version 1.1.1”</p>\n<p>3) 查看tag<br>$ git show [version]</p>\n<p>4) 删除tag<br>git tag -d [version]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 其他</span><br></pre></td></tr></table></figure></p>\n<p>1) 查看某个命令的帮助<br>git help [command-name]</p>\n<p>2) 保留空文件<br>在空文件夹中新建.gitkeep文件</p>\n<p>3) 忽略某些文件<br>在.gitignore文件中添加需要忽略的文件夹或文件<br>例:<br>//忽略Pods文件夹下的所有文件<br>platforms/ios/Pods</p>\n<p>//忽略www下的所有文件除了plugins<br>platforms/ios/www/*<br>!platforms/ios/www/plugins</p>\n<p><code>`</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>git的命令很多，为了减少后续查询的时间在这里列出了平常用到的一些命令。关于这些命令我们对git需要有一个基本的认识，如下图，git分为了几个区：</p>\n<p><div align=\"center\"><br><img src=\"/assets/gitSketch.png\" alt=\"git structure sketch\"></div></p>\n<h4 id=\"创建代码仓库\"><a href=\"#创建代码仓库\" class=\"headerlink\" title=\"创建代码仓库\"></a>创建代码仓库</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）在当前文件夹创建仓库 </span><br><span class=\"line\">$ git init </span><br><span class=\"line\"></span><br><span class=\"line\">2）新建文件夹并创建仓库</span><br><span class=\"line\">$ git init [project-name]</span><br><span class=\"line\"></span><br><span class=\"line\">3）克隆远程分支，默认为master分支</span><br><span class=\"line\">$ git clone [url] -b [branch-name] [your-folder]</span><br><span class=\"line\">// 克隆远程dev分支到MyProject</span><br><span class=\"line\">例: $ git clone https://github.com/fengyueran/Test.git -b dev MyProject</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><p>通过git config可以配置git的环境变量，这些变量存在三个不同的地方</p>\n<ul>\n<li>/etc/gitconfig文件：适用于所有用户。</li>\n<li>~/.gitconfig文件：适用于当前用户。</li>\n<li>.git/config文件：\b当前项目中的配置文件，适用于当前项目。</li>\n</ul>\n<p>每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆/etc/gitconfig中的同名变量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）查看配置信息(包括用户名、邮箱等)</span><br><span class=\"line\">$ git config --list</span><br><span class=\"line\"></span><br><span class=\"line\">2）编辑配置文件(--system/global)</span><br><span class=\"line\">$ git config -e </span><br><span class=\"line\">// 编辑当前用户的配置文件, --global:适用于当前用户， --system:适用于所有用户，不带参数: 当前项目</span><br><span class=\"line\">例: $ git config -e --global</span><br><span class=\"line\"></span><br><span class=\"line\">3）设置当前用户信息</span><br><span class=\"line\">$ git config --global user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;[email address]&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">4）清除当前用户信息</span><br><span class=\"line\">$ git config --unset --global user.name &quot;[name]&quot;</span><br><span class=\"line\">$ git config --unset --global user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件\b操作\"></a>文件\b操作</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）添加文件file1，file2...到暂存区</span><br><span class=\"line\">$ git add [file1] [file2]</span><br><span class=\"line\"></span><br><span class=\"line\">2）添加当前目录所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\">3) 添加目录(包括子目录)到暂存区</span><br><span class=\"line\">$ git add [dir]</span><br><span class=\"line\"></span><br><span class=\"line\">4) 删除当前目录没有track过的文件</span><br><span class=\"line\">$ git clean -f</span><br><span class=\"line\"></span><br><span class=\"line\">5) 删除当前目录没有track过的文件和文件夹</span><br><span class=\"line\">$ git clean -df</span><br><span class=\"line\"></span><br><span class=\"line\">6) 删除所有本地未提交的修改</span><br><span class=\"line\">$ git checkout .</span><br><span class=\"line\"></span><br><span class=\"line\">7）提交暂存区到仓库区 </span><br><span class=\"line\">$ git commit -m [message]</span><br><span class=\"line\"></span><br><span class=\"line\">8）追加到上一次提交 </span><br><span class=\"line\">$ git commit --amend -m [message]</span><br><span class=\"line\">//修改上次提交</span><br><span class=\"line\">例: $ git commit --amend</span><br></pre></td></tr></table></figure>\n<p>9）撤销某次提交<br>$ git revert [commit]<br>例: $ git revert fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 查看信息</span><br></pre></td></tr></table></figure></p>\n<p>1）查看当前分支及其所有父类的提交历史<br>$ git log </p>\n<p>2）可以查看所有分支的所有操作记录(包括已经被删除的commit记录和reset操作）<br>$ git reflog</p>\n<p>3）查看变更的文件<br>$ git status</p>\n<p>4）查看b\b提交相对a提交的差异<br>$ git diff [a-commit] [b-commit]</p>\n<p>5）查看工作区与最新commit的前一次commit的差异，当从远程拉取更新时即可查看变动的内容。<br>$ git diff HEAD^</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 远程操作</span><br></pre></td></tr></table></figure>\n<p>1）列出远程仓库名<br>$ git remote</p>\n<p>2）列出远程仓库名及对应的地址<br>$ git remote –v<br>-&gt; origin    <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:fengyueran/iOSNote.git (fetch)<br>-&gt; origin    <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:fengyueran/iOSNote.git (push)</p>\n<p>3）推送当前本地分支到远程分支<br>$ git push [remote-repository-name] [branch-name]<br>// 将当前分支dev推送到远程仓库origin的remoteDev分支<br>例: $ git push origin dev:remoteDev<br> -&gt;   <em> [new branch]      dev -&gt; remoteDev<br>// 省略远程仓库分支名则在远程创建当前同名分支dev<br>例: $ git push origin dev<br> -&gt;   </em> [new branch]      dev -&gt; dev</p>\n<p>4）删除远程仓库origin的分支dev<br>例: $ git push origin –delete dev</p>\n<p>5）添加远程仓库<br>$ git remote add [repository] [url]<br>// 在远程添加名为pb的仓库<br>例: $ git remote add pb git://github.com/fengyueran/test.git</p>\n<p>6）重设远程仓库<br>$ git remote set-url [repository] [url]<br>// 在远程添加名为pb的仓库<br>例: $ git remote set-url origin git://github.com/fengyueran/test.git</p>\n<p>1) 拉取远端数据<br>// 使你与另一仓库同步，提取你本地所没有的数据，不merge，拉取下来的数据在.git/FETCH_HEAD下<br>$ git fetch<br>// 将你的仓库与远端仓库origin同步，提取所有它独有的数据到本地分支以合并或者怎样。<br>$ git fetch origin<br>// 下面的fetch操作使用远程dev分支在本地创建localDev分支(但不会切换到该分支)，如果本地不存在localDev分支,则会自动创建一个新的localDev分支,<br>如果本地存在localDev分支, 并且是`fast forward’, 则自动合并两个分支, 否则, 会阻止以上操作。<br>$ git fetch origin dev:localDev<br>-&gt; * [new branch]      dev        -&gt; localDev</p>\n<p>8）从远程仓库提取数据并尝试合并到当前分支<br>// 基本上，该命令就是在git fetch之后紧接着git merge远端分支到当前分支<br>$ git pull </p>\n<p>//当新建分支时，如果直接pull或push需要参数远程仓库名和分支名<br>$ git pull origin dev<br>如果想省略仓库名和分支名则需要建立追踪关系，执行如下命令<br>$ git pull –set-upstream origin dev</p>\n<p>//merge操作会生成一个新的节点，之前的提交分开显示。而rebase操作不会生成新的节点, 因而能产生一个更为整洁的提交历史<br>$ git pull –rebase<br>//假设提交线图在执行pull前是这样的：<br>      C1—D1—E1  remotes/origin/master<br>      /<br>  A—B—C2—D2  master<br>执行git pull则提交线图会变成这样：<br>      C1—D1—E1  remotes/origin/master<br>      /          \\<br>  A—B—C2—D2-F  master<br>即会产生一个多余的合并历史，<br>如果执行git pull –rebase则提交线图会变成这样：<br>    remotes/origin/master<br>                  |<br>  A—B—C1—D1—C2’—D2’  master<br>可以看到，应用rebase则不会有新的提交F。C2,D2删除后重新提交为C2’,D2’了。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 分支操作</span><br></pre></td></tr></table></figure></p>\n<p>1）查看本地分支<br>$ git branch</p>\n<p>2）查看远程分支,远程分支会用红色表示出来(如果你开了颜色支持的话）<br>$ git branch -r</p>\n<p>3）新建分支<br>$ git branch [branch-name]<br>例: $ git branch dev</p>\n<p>4）切换分支<br>$ git checkout [branch-name]<br>例: $ git checkout dev</p>\n<p>5）新建并切换分支<br>$ git checkout -b [branch-name]<br>// 当前分支的记录都会到新分支dev上<br>例: $ git checkout -b dev</p>\n<p>6）删除分支<br>$ git branch -D [branch-name]</p>\n<p>7）叫起合并冲突工具kdiff3<br>$ git mergetool -t kdiff3</p>\n<p>8) 合并某个分支到当前分支<br>// 如果不是<code>fast forward&#39;则会产生合并的提交历史\n$ git merge [branch-name]\n// 将hotfix分支合并到当前分支\n例: $ git merge hotfix\n// 无论是否是</code>fast forward’都产生合并的提交历史<br>例: $ git merge hotfix –no-f</p>\n<p>9) 选择任意一个commit，合并进当前分支<br>$ git cherry-pick [commit]</p>\n<p>10）合并提交历史<br>// 当我们由master分支切换到新的分支dev工作，工作结束后想merge回master，如果直接在master应用git merge dev，<br>dev的提交历史就会出现在master中，有时这些记录很琐碎没有必要添加到master上，用squash就能解决这一问题。<br>a:squash后dev上的提交就变成了新的文件<br>  $ git merge –squash dev<br>b:重新commit代替之前所有提交<br>  $ git commit -m “dev”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 版本回退</span><br></pre></td></tr></table></figure>\n<p>1）储存临时文件<br>//当工作区有未提交的文件，又想切换到另一个branch时就可以用git stash暂时存储<br>$ git stash </p>\n<p>2）查看存储了哪些文件<br>$ git stash list</p>\n<p>3）应用存储的临时文件<br>// 当回到之前的dirty工作区时可以通过git stash apply来恢复之前未提交的文件，也可以在其他branch应用这些存储的临时文件<br>$ git stash apply</p>\n<p>4) 让单个文件回退到指定的版本<br>a:进入到文件所在文件目录，或者能找到文件的路径<br>  $ git reflog test.js<br>  -&gt; 60e207a (HEAD -&gt; master) HEAD@{0}: commit: test.js +2<br>     1435819 HEAD@{1}: commit: test.js +1<br>b:回退到指定的版本<br>  $  git reset 1435819 test.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### tag</span><br></pre></td></tr></table></figure>\n<p>1) 轻量级tag<br>$ git tag [version]<br>例: $ git tag v1.0.0</p>\n<p>2) 创建一个含附注类型的标签非常简单<br>$ git tag -a [version] -m “[detail]”<br>$ git tag -a v1.1.1 -m “CuraCloudMI version 1.1.1”</p>\n<p>3) 查看tag<br>$ git show [version]</p>\n<p>4) 删除tag<br>git tag -d [version]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 其他</span><br></pre></td></tr></table></figure></p>\n<p>1) 查看某个命令的帮助<br>git help [command-name]</p>\n<p>2) 保留空文件<br>在空文件夹中新建.gitkeep文件</p>\n<p>3) 忽略某些文件<br>在.gitignore文件中添加需要忽略的文件夹或文件<br>例:<br>//忽略Pods文件夹下的所有文件<br>platforms/ios/Pods</p>\n<p>//忽略www下的所有文件除了plugins<br>platforms/ios/www/*<br>!platforms/ios/www/plugins</p>\n<p><code>`</code></p>\n"},{"layout":"post","title":"React最佳实践","tagline":"Supporting tagline","description":"在React应用的开发中遵循一定的基本准则，能使代码更加友好，提高代码质量。","date":"2017-06-20T12:10:07.000Z","_content":"### **引入css**\n\n直接引入组件对应的css以便于修改\n```\n//before\nbuild到一个main.css, 在主html引入\n\n//recommend\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport styles from './infocard.css';\n```\n\n### **初始化State**\n\nes7语法定义state更简洁\n```\n//before\nclass Main extends React.Component {\n  constructor() {\n    super();\n    this.state = {};\n  }\n  render() {\n\n  }\n} \n\n// recommend\nclass Main extends React.Component {\n  state = { step: 0 }\n  render() {\n\n  }\n} \n\n```\n\n### **propTypes书写顺序**\n\n```\n//before\nclass Main extends React.Component {\n  render() {\n\n  }\n} \nMain.propTypes = {\n}\nMain.defaultTypes = {\n}\n\n//recommend\n//class组件\nclass Main extends React.Component {\n  static propTypes = {\n\n  }\n  static defaultTypes = {\n    \n  }\n  render() {\n\n  }\n}\n\n//函数式组件\nconst mainProps = {};\nconst Main = () => {\n  return() {\n\n  }\n}\nMain.propTypes = mainProps;\n```\n\n### **用箭头函数绑定this**\n\nReact.Component创建组件时，类中的方法并不会绑定this而需要显示绑定，如下，用箭头函数可以自动绑定(es6语法糖)this。\n```\n//before\nconstructor() {\n  this.handleClick = this.handleClick.bind(this);\n}\n<div onClick={this.handleClick.bind(this)}>\n\n//recommend\nconst handleClick = () => {}\n\n```\n\n### **setState接受函数参数**\n\nreact设计时为了性能上的优化，采取了批次的思想，每次更改state并不直接更新，而是收到一波state合并后才更新，是一个异步的过程，所以当需要前一个state做后续运算时应该传一个函数而不是对象，如下就可以避免这一问题。\n\n```\n//before\nthis.setState({ num: 1 }) \nconsole.log(this.state.num) //undefined\n\n//recommend\nthis.setState((preState, props) => ({ num: 1 })); \nthis.setState((preState, props) => ({ num: preState.num + 1 })); \n最后this.state.num为2\n```\n\n### **使用Get/Set访问器属性来做数据处理**\n\n如果需要在组件内做数据处理尽量使用Get/Set\n```\n  // recommend\n  getSpeed () {\n    return `${this.props.speed} m/s`;\n  }\n \n  // re\n  get speed () {\n    return `${this.props.firstName} m/s`;\n  }\n```\n\n### **避免传递新的闭包给子组件**\n\n这里的闭包指通过这种形式(() => { alert('hit my heart');})创建的函数，每次父组件render时都会生成新的闭包，给子组件传递一个新的闭包prop，从而导致子组件重绘，即使子组件其他props并未更新。\n```\n//before\nclass Main extends React.Component {\n  render() {\n     <ViewHeart \n      onClick={() => {\n        alert('hit my heart');\n      }} />\n  }\n} \n\n//recommend\nclass Main extends React.Component {\n  hitMyHeart = () => {\n    alert('hit my heart');\n  }\n  render() {\n     <ViewHeart \n      onClick={this.hitMyHeart} />\n  }\n}\n```\n\n### **尽量使用函数式组件**\n\n函数式组件没有生命周期管理或状态管理，易于调试，不需要分配特定的内存。此外函数式组件尽量不用箭头函数，因其为匿名函数，错误很可能以<< anonymous >>的方式呈现，难以调试。\n```\n//before\nclass Main extends React.Component {\n  render() {\n\n  }\n} \n\n//bad\nconst Main = () => {\n  return {\n\n  }\n} \n\n// recommend\nfunction Main() {\n  return {\n\n  }\n} \n```\n\n### **布尔类型判断是否渲染的书写**\n\n如下当用一个布尔判断是否渲染时不需要用三目运算符，&&更简洁。\n\n```\n//before\n{\n  isActive ? <Active /> : null\n}\n\n//recommend\n{\n  isActive && <Active />\n}\n```\n\n### **必要的时候用高阶组件**\n\n无状态函数组件与高阶组件结合能使代码层次更加清晰，分工明确，调试更加容易。如下通过函数withMain将无状态组件WrappedComponent包裹了一层，这一层负责管理state或生命周期WrappedComponent只负责显示。\n\n```\nconst withMain = (mapPropsToData, WrappedComponent) => {\n  class MainWrapper extends React.Component {\n    componentDidMount() {}\n\n    componentWillUnmount() {}\n\n    shouldComponentUpdate(nextProps) {\n      return nextProps !== this.props;\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n\n@withMain({ title: '高阶组件' })\nclass Main extends React.Component {\n  render() {\n\n  }\n} \n\n```\n\n\n\n\n\n","source":"_posts/react最佳实践.md","raw":"---\nlayout: post\ntitle: React最佳实践\ncategory : react\ntagline: \"Supporting tagline\"\ntags : [react]\ndescription: 在React应用的开发中遵循一定的基本准则，能使代码更加友好，提高代码质量。\ndate: 2017-6-20 20:10:07\n---\n### **引入css**\n\n直接引入组件对应的css以便于修改\n```\n//before\nbuild到一个main.css, 在主html引入\n\n//recommend\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport styles from './infocard.css';\n```\n\n### **初始化State**\n\nes7语法定义state更简洁\n```\n//before\nclass Main extends React.Component {\n  constructor() {\n    super();\n    this.state = {};\n  }\n  render() {\n\n  }\n} \n\n// recommend\nclass Main extends React.Component {\n  state = { step: 0 }\n  render() {\n\n  }\n} \n\n```\n\n### **propTypes书写顺序**\n\n```\n//before\nclass Main extends React.Component {\n  render() {\n\n  }\n} \nMain.propTypes = {\n}\nMain.defaultTypes = {\n}\n\n//recommend\n//class组件\nclass Main extends React.Component {\n  static propTypes = {\n\n  }\n  static defaultTypes = {\n    \n  }\n  render() {\n\n  }\n}\n\n//函数式组件\nconst mainProps = {};\nconst Main = () => {\n  return() {\n\n  }\n}\nMain.propTypes = mainProps;\n```\n\n### **用箭头函数绑定this**\n\nReact.Component创建组件时，类中的方法并不会绑定this而需要显示绑定，如下，用箭头函数可以自动绑定(es6语法糖)this。\n```\n//before\nconstructor() {\n  this.handleClick = this.handleClick.bind(this);\n}\n<div onClick={this.handleClick.bind(this)}>\n\n//recommend\nconst handleClick = () => {}\n\n```\n\n### **setState接受函数参数**\n\nreact设计时为了性能上的优化，采取了批次的思想，每次更改state并不直接更新，而是收到一波state合并后才更新，是一个异步的过程，所以当需要前一个state做后续运算时应该传一个函数而不是对象，如下就可以避免这一问题。\n\n```\n//before\nthis.setState({ num: 1 }) \nconsole.log(this.state.num) //undefined\n\n//recommend\nthis.setState((preState, props) => ({ num: 1 })); \nthis.setState((preState, props) => ({ num: preState.num + 1 })); \n最后this.state.num为2\n```\n\n### **使用Get/Set访问器属性来做数据处理**\n\n如果需要在组件内做数据处理尽量使用Get/Set\n```\n  // recommend\n  getSpeed () {\n    return `${this.props.speed} m/s`;\n  }\n \n  // re\n  get speed () {\n    return `${this.props.firstName} m/s`;\n  }\n```\n\n### **避免传递新的闭包给子组件**\n\n这里的闭包指通过这种形式(() => { alert('hit my heart');})创建的函数，每次父组件render时都会生成新的闭包，给子组件传递一个新的闭包prop，从而导致子组件重绘，即使子组件其他props并未更新。\n```\n//before\nclass Main extends React.Component {\n  render() {\n     <ViewHeart \n      onClick={() => {\n        alert('hit my heart');\n      }} />\n  }\n} \n\n//recommend\nclass Main extends React.Component {\n  hitMyHeart = () => {\n    alert('hit my heart');\n  }\n  render() {\n     <ViewHeart \n      onClick={this.hitMyHeart} />\n  }\n}\n```\n\n### **尽量使用函数式组件**\n\n函数式组件没有生命周期管理或状态管理，易于调试，不需要分配特定的内存。此外函数式组件尽量不用箭头函数，因其为匿名函数，错误很可能以<< anonymous >>的方式呈现，难以调试。\n```\n//before\nclass Main extends React.Component {\n  render() {\n\n  }\n} \n\n//bad\nconst Main = () => {\n  return {\n\n  }\n} \n\n// recommend\nfunction Main() {\n  return {\n\n  }\n} \n```\n\n### **布尔类型判断是否渲染的书写**\n\n如下当用一个布尔判断是否渲染时不需要用三目运算符，&&更简洁。\n\n```\n//before\n{\n  isActive ? <Active /> : null\n}\n\n//recommend\n{\n  isActive && <Active />\n}\n```\n\n### **必要的时候用高阶组件**\n\n无状态函数组件与高阶组件结合能使代码层次更加清晰，分工明确，调试更加容易。如下通过函数withMain将无状态组件WrappedComponent包裹了一层，这一层负责管理state或生命周期WrappedComponent只负责显示。\n\n```\nconst withMain = (mapPropsToData, WrappedComponent) => {\n  class MainWrapper extends React.Component {\n    componentDidMount() {}\n\n    componentWillUnmount() {}\n\n    shouldComponentUpdate(nextProps) {\n      return nextProps !== this.props;\n    }\n    render() {\n      return <WrappedComponent {...this.props} />;\n    }\n  }\n\n\n@withMain({ title: '高阶组件' })\nclass Main extends React.Component {\n  render() {\n\n  }\n} \n\n```\n\n\n\n\n\n","slug":"react最佳实践","published":1,"updated":"2018-12-05T14:07:29.559Z","comments":1,"photos":[],"link":"","_id":"cjq5aqcsg000bdsztk60hxxll","content":"<h3 id=\"引入css\"><a href=\"#引入css\" class=\"headerlink\" title=\"引入css\"></a><strong>引入css</strong></h3><p>直接引入组件对应的css以便于修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">build到一个main.css, 在主html引入</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import PropTypes from &apos;prop-types&apos;;</span><br><span class=\"line\">import styles from &apos;./infocard.css&apos;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"初始化State\"><a href=\"#初始化State\" class=\"headerlink\" title=\"初始化State\"></a><strong>初始化State</strong></h3><p>es7语法定义state更简洁<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">// recommend</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  state = &#123; step: 0 &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"propTypes书写顺序\"><a href=\"#propTypes书写顺序\" class=\"headerlink\" title=\"propTypes书写顺序\"></a><strong>propTypes书写顺序</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">Main.propTypes = &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Main.defaultTypes = &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">//class组件</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  static propTypes = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  static defaultTypes = &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//函数式组件</span><br><span class=\"line\">const mainProps = &#123;&#125;;</span><br><span class=\"line\">const Main = () =&gt; &#123;</span><br><span class=\"line\">  return() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Main.propTypes = mainProps;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用箭头函数绑定this\"><a href=\"#用箭头函数绑定this\" class=\"headerlink\" title=\"用箭头函数绑定this\"></a><strong>用箭头函数绑定this</strong></h3><p>React.Component创建组件时，类中的方法并不会绑定this而需要显示绑定，如下，用箭头函数可以自动绑定(es6语法糖)this。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">constructor() &#123;</span><br><span class=\"line\">  this.handleClick = this.handleClick.bind(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">const handleClick = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"setState接受函数参数\"><a href=\"#setState接受函数参数\" class=\"headerlink\" title=\"setState接受函数参数\"></a><strong>setState接受函数参数</strong></h3><p>react设计时为了性能上的优化，采取了批次的思想，每次更改state并不直接更新，而是收到一波state合并后才更新，是一个异步的过程，所以当需要前一个state做后续运算时应该传一个函数而不是对象，如下就可以避免这一问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">this.setState(&#123; num: 1 &#125;) </span><br><span class=\"line\">console.log(this.state.num) //undefined</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">this.setState((preState, props) =&gt; (&#123; num: 1 &#125;)); </span><br><span class=\"line\">this.setState((preState, props) =&gt; (&#123; num: preState.num + 1 &#125;)); </span><br><span class=\"line\">最后this.state.num为2</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Get-Set访问器属性来做数据处理\"><a href=\"#使用Get-Set访问器属性来做数据处理\" class=\"headerlink\" title=\"使用Get/Set访问器属性来做数据处理\"></a><strong>使用Get/Set访问器属性来做数据处理</strong></h3><p>如果需要在组件内做数据处理尽量使用Get/Set<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// recommend</span><br><span class=\"line\">getSpeed () &#123;</span><br><span class=\"line\">  return `$&#123;this.props.speed&#125; m/s`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// re</span><br><span class=\"line\">get speed () &#123;</span><br><span class=\"line\">  return `$&#123;this.props.firstName&#125; m/s`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"避免传递新的闭包给子组件\"><a href=\"#避免传递新的闭包给子组件\" class=\"headerlink\" title=\"避免传递新的闭包给子组件\"></a><strong>避免传递新的闭包给子组件</strong></h3><p>这里的闭包指通过这种形式(() =&gt; { alert(‘hit my heart’);})创建的函数，每次父组件render时都会生成新的闭包，给子组件传递一个新的闭包prop，从而导致子组件重绘，即使子组件其他props并未更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">     &lt;ViewHeart </span><br><span class=\"line\">      onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">        alert(&apos;hit my heart&apos;);</span><br><span class=\"line\">      &#125;&#125; /&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  hitMyHeart = () =&gt; &#123;</span><br><span class=\"line\">    alert(&apos;hit my heart&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">     &lt;ViewHeart </span><br><span class=\"line\">      onClick=&#123;this.hitMyHeart&#125; /&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"尽量使用函数式组件\"><a href=\"#尽量使用函数式组件\" class=\"headerlink\" title=\"尽量使用函数式组件\"></a><strong>尽量使用函数式组件</strong></h3><p>函数式组件没有生命周期管理或状态管理，易于调试，不需要分配特定的内存。此外函数式组件尽量不用箭头函数，因其为匿名函数，错误很可能以&lt;&lt; anonymous &gt;&gt;的方式呈现，难以调试。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//bad</span><br><span class=\"line\">const Main = () =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">// recommend</span><br><span class=\"line\">function Main() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"布尔类型判断是否渲染的书写\"><a href=\"#布尔类型判断是否渲染的书写\" class=\"headerlink\" title=\"布尔类型判断是否渲染的书写\"></a><strong>布尔类型判断是否渲染的书写</strong></h3><p>如下当用一个布尔判断是否渲染时不需要用三目运算符，&amp;&amp;更简洁。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  isActive ? &lt;Active /&gt; : null</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  isActive &amp;&amp; &lt;Active /&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"必要的时候用高阶组件\"><a href=\"#必要的时候用高阶组件\" class=\"headerlink\" title=\"必要的时候用高阶组件\"></a><strong>必要的时候用高阶组件</strong></h3><p>无状态函数组件与高阶组件结合能使代码层次更加清晰，分工明确，调试更加容易。如下通过函数withMain将无状态组件WrappedComponent包裹了一层，这一层负责管理state或生命周期WrappedComponent只负责显示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const withMain = (mapPropsToData, WrappedComponent) =&gt; &#123;</span><br><span class=\"line\">  class MainWrapper extends React.Component &#123;</span><br><span class=\"line\">    componentDidMount() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    shouldComponentUpdate(nextProps) &#123;</span><br><span class=\"line\">      return nextProps !== this.props;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@withMain(&#123; title: &apos;高阶组件&apos; &#125;)</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"引入css\"><a href=\"#引入css\" class=\"headerlink\" title=\"引入css\"></a><strong>引入css</strong></h3><p>直接引入组件对应的css以便于修改<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">build到一个main.css, 在主html引入</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">import React from &apos;react&apos;;</span><br><span class=\"line\">import PropTypes from &apos;prop-types&apos;;</span><br><span class=\"line\">import styles from &apos;./infocard.css&apos;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"初始化State\"><a href=\"#初始化State\" class=\"headerlink\" title=\"初始化State\"></a><strong>初始化State</strong></h3><p>es7语法定义state更简洁<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">// recommend</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  state = &#123; step: 0 &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"propTypes书写顺序\"><a href=\"#propTypes书写顺序\" class=\"headerlink\" title=\"propTypes书写顺序\"></a><strong>propTypes书写顺序</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">Main.propTypes = &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Main.defaultTypes = &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">//class组件</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  static propTypes = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  static defaultTypes = &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//函数式组件</span><br><span class=\"line\">const mainProps = &#123;&#125;;</span><br><span class=\"line\">const Main = () =&gt; &#123;</span><br><span class=\"line\">  return() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Main.propTypes = mainProps;</span><br></pre></td></tr></table></figure>\n<h3 id=\"用箭头函数绑定this\"><a href=\"#用箭头函数绑定this\" class=\"headerlink\" title=\"用箭头函数绑定this\"></a><strong>用箭头函数绑定this</strong></h3><p>React.Component创建组件时，类中的方法并不会绑定this而需要显示绑定，如下，用箭头函数可以自动绑定(es6语法糖)this。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">constructor() &#123;</span><br><span class=\"line\">  this.handleClick = this.handleClick.bind(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;div onClick=&#123;this.handleClick.bind(this)&#125;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">const handleClick = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"setState接受函数参数\"><a href=\"#setState接受函数参数\" class=\"headerlink\" title=\"setState接受函数参数\"></a><strong>setState接受函数参数</strong></h3><p>react设计时为了性能上的优化，采取了批次的思想，每次更改state并不直接更新，而是收到一波state合并后才更新，是一个异步的过程，所以当需要前一个state做后续运算时应该传一个函数而不是对象，如下就可以避免这一问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">this.setState(&#123; num: 1 &#125;) </span><br><span class=\"line\">console.log(this.state.num) //undefined</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">this.setState((preState, props) =&gt; (&#123; num: 1 &#125;)); </span><br><span class=\"line\">this.setState((preState, props) =&gt; (&#123; num: preState.num + 1 &#125;)); </span><br><span class=\"line\">最后this.state.num为2</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用Get-Set访问器属性来做数据处理\"><a href=\"#使用Get-Set访问器属性来做数据处理\" class=\"headerlink\" title=\"使用Get/Set访问器属性来做数据处理\"></a><strong>使用Get/Set访问器属性来做数据处理</strong></h3><p>如果需要在组件内做数据处理尽量使用Get/Set<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// recommend</span><br><span class=\"line\">getSpeed () &#123;</span><br><span class=\"line\">  return `$&#123;this.props.speed&#125; m/s`;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">// re</span><br><span class=\"line\">get speed () &#123;</span><br><span class=\"line\">  return `$&#123;this.props.firstName&#125; m/s`;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"避免传递新的闭包给子组件\"><a href=\"#避免传递新的闭包给子组件\" class=\"headerlink\" title=\"避免传递新的闭包给子组件\"></a><strong>避免传递新的闭包给子组件</strong></h3><p>这里的闭包指通过这种形式(() =&gt; { alert(‘hit my heart’);})创建的函数，每次父组件render时都会生成新的闭包，给子组件传递一个新的闭包prop，从而导致子组件重绘，即使子组件其他props并未更新。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">     &lt;ViewHeart </span><br><span class=\"line\">      onClick=&#123;() =&gt; &#123;</span><br><span class=\"line\">        alert(&apos;hit my heart&apos;);</span><br><span class=\"line\">      &#125;&#125; /&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  hitMyHeart = () =&gt; &#123;</span><br><span class=\"line\">    alert(&apos;hit my heart&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">     &lt;ViewHeart </span><br><span class=\"line\">      onClick=&#123;this.hitMyHeart&#125; /&gt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"尽量使用函数式组件\"><a href=\"#尽量使用函数式组件\" class=\"headerlink\" title=\"尽量使用函数式组件\"></a><strong>尽量使用函数式组件</strong></h3><p>函数式组件没有生命周期管理或状态管理，易于调试，不需要分配特定的内存。此外函数式组件尽量不用箭头函数，因其为匿名函数，错误很可能以&lt;&lt; anonymous &gt;&gt;的方式呈现，难以调试。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">//bad</span><br><span class=\"line\">const Main = () =&gt; &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">// recommend</span><br><span class=\"line\">function Main() &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"布尔类型判断是否渲染的书写\"><a href=\"#布尔类型判断是否渲染的书写\" class=\"headerlink\" title=\"布尔类型判断是否渲染的书写\"></a><strong>布尔类型判断是否渲染的书写</strong></h3><p>如下当用一个布尔判断是否渲染时不需要用三目运算符，&amp;&amp;更简洁。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//before</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  isActive ? &lt;Active /&gt; : null</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//recommend</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  isActive &amp;&amp; &lt;Active /&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"必要的时候用高阶组件\"><a href=\"#必要的时候用高阶组件\" class=\"headerlink\" title=\"必要的时候用高阶组件\"></a><strong>必要的时候用高阶组件</strong></h3><p>无状态函数组件与高阶组件结合能使代码层次更加清晰，分工明确，调试更加容易。如下通过函数withMain将无状态组件WrappedComponent包裹了一层，这一层负责管理state或生命周期WrappedComponent只负责显示。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const withMain = (mapPropsToData, WrappedComponent) =&gt; &#123;</span><br><span class=\"line\">  class MainWrapper extends React.Component &#123;</span><br><span class=\"line\">    componentDidMount() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentWillUnmount() &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    shouldComponentUpdate(nextProps) &#123;</span><br><span class=\"line\">      return nextProps !== this.props;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      return &lt;WrappedComponent &#123;...this.props&#125; /&gt;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">@withMain(&#123; title: &apos;高阶组件&apos; &#125;)</span><br><span class=\"line\">class Main extends React.Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"树的深度遍历与广度遍历","tagline":"Supporting tagline","description":"作为一个非科班出生的前端开发人员，平时对数据结构与算法了解得相对较少，当谈到深度遍历与广度遍历时就一脸懵逼，于是查阅相关资料对其有一个基本认识并能够实现深度、广度遍历的方法。","date":"2017-06-26T18:11:08.000Z","_content":"### **基本概念**\n\n树是一种数据结构，之所以称之为树是因为其结构类似于🌲，它的根在上，枝叶在下。\n树中一个最基本的数据称为节点(Node)，对应于🌲中的每一个分叉。树具有一个根节点(root)，根节点之下可能具有多个节点，节点间通过边(edge)相连，表示它们之间的关系。这种结构类似于Html文档，公司的组织结构...\n\n<center>![结构树示意图]](/images/tree.png)<center>\n<center>图1.结构树示意图 <center>\n\n\n### **树相关的术语**\n- 根结点: 树最顶层结点，也是树中唯一一个没有父节点的节点，如图1中的0节点\n- 边: 两个结点之间的连接\n- 父结点: 一个节点有子节点则称这个节点是其子结点的父节点\n- 兄弟结点: 具有相同父节点的节点互为兄弟节点，如图中的6、7、8\n- 叶子结点: 树中没有子结点的结点(树得末端)，如图1中的6、7、8、9、5\n- 层次: 节点的层次从根开始定义，根为第一层，根的子节点为第二层，依次类推\n- 深度: 树中结点的最大层次称为树的深度\n\n### **操作树**\n在计算机科学中树是一种用来模拟分层数据的数据结构，树由多个节点构成，而每个节点都有自身的数据(data)及指向其他节点(parent、children)的指针，如下定义了节点和树。\n\n#### 节点\n- data: 节点的数据\n- parent: 节点的父亲\n- children: 节点的子节点\n\n```\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.parent = null;\n    this.children = [];\n  }\n}\n```\n\n#### 树\n\n树有一个根节点root\n```\nclass Tree {\n  constructor(data) {\n    this._root = new Node(data);\n  }\n}\n```\n\n#### Tree的方法\n接下来我们将要创建以下五种方法。\n\n- traverseDF(callback)\n\n- traverseBF(callback)\n\n- contains(callback, traversalType)\n\n- add(data, toId, traversalType)\n\n- remove(node, parent)\n\n**方法1/5: traverseDF(callback)**\n这种方法以深度优先遍历树：从根节点出发，沿着左子树方向进行遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树的遍历，直到遍历完所有可到达的节点为止。对于图1来说深度优先遍历的结果是:\n```\n  traverseDF(callback) {\n    const recuseNode = (node) => {\n      for (let i = 0; i < node.children.length; i++) {\n        recuseNode(node.children[i]);\n      }\n      callback(node);\n    };\n    recuseNode(this._root);\n  }\n```\n\n**方法2/5: traverseBF(callback)**\n\n这种方法以广度优先遍历树：从根节点出发，对每一层节点依次访问，访问一层进入下一层，而且每个节点只能访问一次。对于图1来说广度优先遍历的结果是:\n\n```\n  class Queue {\n    constructor() {\n        this.dataStore = [];\n    }\n\n    add(element) {\n        this.dataStore.push(element);\n    }\n\n    pop() {\n        return this.dataStore.shift();\n    }\n  }\n\n  traverseBF(callback) {\n    let currentTree = this._root;\n    const queue = new Queue();\n    while (currentTree) {\n      for (let i = 0; i < currentTree.children.length; i++) {\n        queue.add(currentTree.children[i]);\n      }\n      callback(currentTree);\n      currentTree = queue.pop();\n    }\n  }\n```\n\n**方法3/5: contains(callback, traversalType)**\ncontains方法用于在树中搜索特定的值，它有两个参数，第一个为回调函数，每遍历到一个节点就会以该节点为回调参数回调，第二个为遍历的类型(深度遍历或广度遍历)\n```\n contains(callback, traversalType) {\n    const traverse = this[traversalType];\n    traverse.call(this, callback);\n  }\n\n```\n\n搜索特定id的节点就可以这样写：\n```\ntree.contains((node) => {\n  if (node.id === '12345') {\n    console.log(node);\n  }\n}, 'traverseDF');\n```\n\n**方法4/5: add(data, toId, traversalType)**\n\n该方法用于在指定节点添加节点。\n```\n  add(data, toId, traversalType) {\n    let parent = null;\n    //遍历是否有目标节点\n    this.contains((node) => {\n      if (node.data === toId) {\n        parent = node.parent;\n      }\n    }, traversalType);\n    //有目标节点则添加节点\n    if (parent) {\n      const newNode = new Node(data);\n      newNode.parent = parent;\n      parent.children.push(newNode);\n    } else {\n      throw new Error(`can't find the target node`);\n    }\n  }\n```\n\n**方法5/5: remove(fromId, traversalType)**\n\n该方法用于在指定节点下的节点。\n```\n  remove(fromId, traversalType) {\n    let parent = null;\n    let deleteNode = null;\n    //遍历是否有目标节点\n    this.contains((node) => {\n      if (node.id === fromId) {\n        parent = node.parent;\n        deleteNode = node;\n      }\n    }, traversalType);\n\n    //有目标节点则遍历目标节点的子节点是否有要删除的节点，有则删除\n    if (parent) {\n      const findIndex = parent.children.findIndex(node => deleteNode.id === node.id);\n      if (findIndex >= 0) {\n        parent.children.splice(findIndex, 1);\n      }\n    } else {\n      throw new Error(`can't find the target node`);\n    }\n  }\n```\n\n#### 树的完整实现\n\n```\nclass Queue {\n  constructor() {\n    this.dataStore = [];\n  }\n  \n  add(element) {\n    this.dataStore.push(element);\n  }\n\n  pop() {\n    return this.dataStore.shift();\n  }\n}\n\n\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.parent = null;\n    this.children = [];\n  }\n}\n\nclass Tree {\n  constructor(data) {\n    this._root = new Node(data);\n  }\n\n  traverseDF(callback) {\n    const recuseNode = (node) => {\n      for (let i = 0; i < node.children.length; i++) {\n        recuseNode(node.children[i]);\n      }\n      callback(node);\n    };\n    recuseNode(this._root);\n  }\n\n  traverseBF(callback) {\n    let currentTree = this._root;\n    const queue = new Queue();\n    while (currentTree) {\n      for (let i = 0; i < currentTree.children.length; i++) {\n        queue.add(currentTree.children[i]);\n      }\n      callback(currentTree);\n      currentTree = queue.pop();\n    }\n  }\n\n  contains(callback, traversalType) {\n    const traverse = this[traversalType];\n    traverse.call(this, callback);\n  }\n\n  add(data, toId, traversalType) {\n    let parent = null;\n    this.contains((node) => {\n      if (node.data === toId) {\n        parent = node.parent;\n      }\n    }, traversalType);\n    if (parent) {\n      const newNode = new Node(data);\n      newNode.parent = parent;\n      parent.children.push(newNode);\n    } else {\n      throw new Error(`can't find the target node`);\n    }\n  }\n\n  remove(fromId, traversalType) {\n    let parent = null;\n    let deleteNode = null;\n    this.contains((node) => {\n      if (node.id === fromId) {\n        parent = node.parent;\n        deleteNode = node;\n      }\n    }, traversalType);\n\n    if (parent) {\n      const findIndex = parent.children.findIndex(node => deleteNode.data === node.data);\n      if (findIndex >= 0) {\n        parent.children.splice(findIndex, 1);\n      }\n    } else {\n      throw new Error(`can't find the target node`);\n    }\n  }\n}\n\n\n/*\n遍历文件夹\nRootDir\n   ┆------DirA\n   ┆       ┆──DirA1\n   ┆       └──DirA2 \n   ┆            └──DirA21            \n   ┆------DirB\n   ┆        └──DirB1\n   └──------DirC\n    \n*/\n\nconst tree = new Tree('RootDir');\n\nconst nodeDirA = new Node('DirA');\nconst nodeDirA1 = new Node('DirA1');\nconst nodeDirA2 = new Node('DirA2');\nconst nodeDirA21 = new Node('DirA21');\nnodeDirA.children.push(nodeDirA1);\nnodeDirA1.parent = nodeDirA;\nnodeDirA.children.push(nodeDirA2);\nnodeDirA2.parent = nodeDirA;\nnodeDirA2.children.push(nodeDirA21);\nnodeDirA21.parent = nodeDirA2;\nnodeDirA.parent = tree._root;\ntree._root.children.push(nodeDirA);\n\nconst nodeDirB = new Node('DirB');\nconst nodeDirB1 = new Node('DirB1');\nnodeDirB.children.push(nodeDirB1);\nnodeDirB1.parent = nodeDirB;\nnodeDirB.parent = tree._root;\ntree._root.children.push(nodeDirB);\n\nconst nodeDirC = new Node('DirC');\nnodeDirC.parent = tree._root;\ntree._root.children.push(nodeDirC);\n\ntree.traverseDF((node) => {\n  console.log(node.data);\n  /*\n  => \n      DirA1\n        DirA21\n      DirA2\n    DirA\n      DirB1\n    DirB\n    DirC\n  RootDir\n  */\n});\n\ntree.traverseBF((node) => {\n  console.log(node.data);\n  /*\n  => \n  RootDir\n    DirA\n    DirB\n    DirC\n      DirA1\n      DirA2\n      DirB1\n        DirA21\n  */\n});\n\ntree.contains((node) => {\n  if (node.data === 'DirA1') {\n    console.log(node);\n  }\n}, 'traverseDF');\n\ntree.add('DirC1', 'DirC', 'traverseBF');\ntree.traverseDF((node) => {\n  console.log(node.data);\n});\ntree.remove('DirC1', 'traverseBF');\ntree.traverseDF((node) => {\n  console.log(node.data);\n});","source":"_posts/树的深度遍历与广度遍历.md","raw":"---\nlayout: post\ntitle: 树的深度遍历与广度遍历\ncategory : js\ntagline: \"Supporting tagline\"\ntags : [js]\ndescription: 作为一个非科班出生的前端开发人员，平时对数据结构与算法了解得相对较少，当谈到深度遍历与广度遍历时就一脸懵逼，于是查阅相关资料对其有一个基本认识并能够实现深度、广度遍历的方法。\ndate: 2017-6-26 26:11:08\n---\n### **基本概念**\n\n树是一种数据结构，之所以称之为树是因为其结构类似于🌲，它的根在上，枝叶在下。\n树中一个最基本的数据称为节点(Node)，对应于🌲中的每一个分叉。树具有一个根节点(root)，根节点之下可能具有多个节点，节点间通过边(edge)相连，表示它们之间的关系。这种结构类似于Html文档，公司的组织结构...\n\n<center>![结构树示意图]](/images/tree.png)<center>\n<center>图1.结构树示意图 <center>\n\n\n### **树相关的术语**\n- 根结点: 树最顶层结点，也是树中唯一一个没有父节点的节点，如图1中的0节点\n- 边: 两个结点之间的连接\n- 父结点: 一个节点有子节点则称这个节点是其子结点的父节点\n- 兄弟结点: 具有相同父节点的节点互为兄弟节点，如图中的6、7、8\n- 叶子结点: 树中没有子结点的结点(树得末端)，如图1中的6、7、8、9、5\n- 层次: 节点的层次从根开始定义，根为第一层，根的子节点为第二层，依次类推\n- 深度: 树中结点的最大层次称为树的深度\n\n### **操作树**\n在计算机科学中树是一种用来模拟分层数据的数据结构，树由多个节点构成，而每个节点都有自身的数据(data)及指向其他节点(parent、children)的指针，如下定义了节点和树。\n\n#### 节点\n- data: 节点的数据\n- parent: 节点的父亲\n- children: 节点的子节点\n\n```\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.parent = null;\n    this.children = [];\n  }\n}\n```\n\n#### 树\n\n树有一个根节点root\n```\nclass Tree {\n  constructor(data) {\n    this._root = new Node(data);\n  }\n}\n```\n\n#### Tree的方法\n接下来我们将要创建以下五种方法。\n\n- traverseDF(callback)\n\n- traverseBF(callback)\n\n- contains(callback, traversalType)\n\n- add(data, toId, traversalType)\n\n- remove(node, parent)\n\n**方法1/5: traverseDF(callback)**\n这种方法以深度优先遍历树：从根节点出发，沿着左子树方向进行遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树的遍历，直到遍历完所有可到达的节点为止。对于图1来说深度优先遍历的结果是:\n```\n  traverseDF(callback) {\n    const recuseNode = (node) => {\n      for (let i = 0; i < node.children.length; i++) {\n        recuseNode(node.children[i]);\n      }\n      callback(node);\n    };\n    recuseNode(this._root);\n  }\n```\n\n**方法2/5: traverseBF(callback)**\n\n这种方法以广度优先遍历树：从根节点出发，对每一层节点依次访问，访问一层进入下一层，而且每个节点只能访问一次。对于图1来说广度优先遍历的结果是:\n\n```\n  class Queue {\n    constructor() {\n        this.dataStore = [];\n    }\n\n    add(element) {\n        this.dataStore.push(element);\n    }\n\n    pop() {\n        return this.dataStore.shift();\n    }\n  }\n\n  traverseBF(callback) {\n    let currentTree = this._root;\n    const queue = new Queue();\n    while (currentTree) {\n      for (let i = 0; i < currentTree.children.length; i++) {\n        queue.add(currentTree.children[i]);\n      }\n      callback(currentTree);\n      currentTree = queue.pop();\n    }\n  }\n```\n\n**方法3/5: contains(callback, traversalType)**\ncontains方法用于在树中搜索特定的值，它有两个参数，第一个为回调函数，每遍历到一个节点就会以该节点为回调参数回调，第二个为遍历的类型(深度遍历或广度遍历)\n```\n contains(callback, traversalType) {\n    const traverse = this[traversalType];\n    traverse.call(this, callback);\n  }\n\n```\n\n搜索特定id的节点就可以这样写：\n```\ntree.contains((node) => {\n  if (node.id === '12345') {\n    console.log(node);\n  }\n}, 'traverseDF');\n```\n\n**方法4/5: add(data, toId, traversalType)**\n\n该方法用于在指定节点添加节点。\n```\n  add(data, toId, traversalType) {\n    let parent = null;\n    //遍历是否有目标节点\n    this.contains((node) => {\n      if (node.data === toId) {\n        parent = node.parent;\n      }\n    }, traversalType);\n    //有目标节点则添加节点\n    if (parent) {\n      const newNode = new Node(data);\n      newNode.parent = parent;\n      parent.children.push(newNode);\n    } else {\n      throw new Error(`can't find the target node`);\n    }\n  }\n```\n\n**方法5/5: remove(fromId, traversalType)**\n\n该方法用于在指定节点下的节点。\n```\n  remove(fromId, traversalType) {\n    let parent = null;\n    let deleteNode = null;\n    //遍历是否有目标节点\n    this.contains((node) => {\n      if (node.id === fromId) {\n        parent = node.parent;\n        deleteNode = node;\n      }\n    }, traversalType);\n\n    //有目标节点则遍历目标节点的子节点是否有要删除的节点，有则删除\n    if (parent) {\n      const findIndex = parent.children.findIndex(node => deleteNode.id === node.id);\n      if (findIndex >= 0) {\n        parent.children.splice(findIndex, 1);\n      }\n    } else {\n      throw new Error(`can't find the target node`);\n    }\n  }\n```\n\n#### 树的完整实现\n\n```\nclass Queue {\n  constructor() {\n    this.dataStore = [];\n  }\n  \n  add(element) {\n    this.dataStore.push(element);\n  }\n\n  pop() {\n    return this.dataStore.shift();\n  }\n}\n\n\nclass Node {\n  constructor(data) {\n    this.data = data;\n    this.parent = null;\n    this.children = [];\n  }\n}\n\nclass Tree {\n  constructor(data) {\n    this._root = new Node(data);\n  }\n\n  traverseDF(callback) {\n    const recuseNode = (node) => {\n      for (let i = 0; i < node.children.length; i++) {\n        recuseNode(node.children[i]);\n      }\n      callback(node);\n    };\n    recuseNode(this._root);\n  }\n\n  traverseBF(callback) {\n    let currentTree = this._root;\n    const queue = new Queue();\n    while (currentTree) {\n      for (let i = 0; i < currentTree.children.length; i++) {\n        queue.add(currentTree.children[i]);\n      }\n      callback(currentTree);\n      currentTree = queue.pop();\n    }\n  }\n\n  contains(callback, traversalType) {\n    const traverse = this[traversalType];\n    traverse.call(this, callback);\n  }\n\n  add(data, toId, traversalType) {\n    let parent = null;\n    this.contains((node) => {\n      if (node.data === toId) {\n        parent = node.parent;\n      }\n    }, traversalType);\n    if (parent) {\n      const newNode = new Node(data);\n      newNode.parent = parent;\n      parent.children.push(newNode);\n    } else {\n      throw new Error(`can't find the target node`);\n    }\n  }\n\n  remove(fromId, traversalType) {\n    let parent = null;\n    let deleteNode = null;\n    this.contains((node) => {\n      if (node.id === fromId) {\n        parent = node.parent;\n        deleteNode = node;\n      }\n    }, traversalType);\n\n    if (parent) {\n      const findIndex = parent.children.findIndex(node => deleteNode.data === node.data);\n      if (findIndex >= 0) {\n        parent.children.splice(findIndex, 1);\n      }\n    } else {\n      throw new Error(`can't find the target node`);\n    }\n  }\n}\n\n\n/*\n遍历文件夹\nRootDir\n   ┆------DirA\n   ┆       ┆──DirA1\n   ┆       └──DirA2 \n   ┆            └──DirA21            \n   ┆------DirB\n   ┆        └──DirB1\n   └──------DirC\n    \n*/\n\nconst tree = new Tree('RootDir');\n\nconst nodeDirA = new Node('DirA');\nconst nodeDirA1 = new Node('DirA1');\nconst nodeDirA2 = new Node('DirA2');\nconst nodeDirA21 = new Node('DirA21');\nnodeDirA.children.push(nodeDirA1);\nnodeDirA1.parent = nodeDirA;\nnodeDirA.children.push(nodeDirA2);\nnodeDirA2.parent = nodeDirA;\nnodeDirA2.children.push(nodeDirA21);\nnodeDirA21.parent = nodeDirA2;\nnodeDirA.parent = tree._root;\ntree._root.children.push(nodeDirA);\n\nconst nodeDirB = new Node('DirB');\nconst nodeDirB1 = new Node('DirB1');\nnodeDirB.children.push(nodeDirB1);\nnodeDirB1.parent = nodeDirB;\nnodeDirB.parent = tree._root;\ntree._root.children.push(nodeDirB);\n\nconst nodeDirC = new Node('DirC');\nnodeDirC.parent = tree._root;\ntree._root.children.push(nodeDirC);\n\ntree.traverseDF((node) => {\n  console.log(node.data);\n  /*\n  => \n      DirA1\n        DirA21\n      DirA2\n    DirA\n      DirB1\n    DirB\n    DirC\n  RootDir\n  */\n});\n\ntree.traverseBF((node) => {\n  console.log(node.data);\n  /*\n  => \n  RootDir\n    DirA\n    DirB\n    DirC\n      DirA1\n      DirA2\n      DirB1\n        DirA21\n  */\n});\n\ntree.contains((node) => {\n  if (node.data === 'DirA1') {\n    console.log(node);\n  }\n}, 'traverseDF');\n\ntree.add('DirC1', 'DirC', 'traverseBF');\ntree.traverseDF((node) => {\n  console.log(node.data);\n});\ntree.remove('DirC1', 'traverseBF');\ntree.traverseDF((node) => {\n  console.log(node.data);\n});","slug":"树的深度遍历与广度遍历","published":1,"updated":"2019-01-04T08:12:13.525Z","_id":"cjq5aqcsi000cdsztpaia87p1","comments":1,"photos":[],"link":"","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a><strong>基本概念</strong></h3><p>树是一种数据结构，之所以称之为树是因为其结构类似于🌲，它的根在上，枝叶在下。<br>树中一个最基本的数据称为节点(Node)，对应于🌲中的每一个分叉。树具有一个根节点(root)，根节点之下可能具有多个节点，节点间通过边(edge)相连，表示它们之间的关系。这种结构类似于Html文档，公司的组织结构…</p>\n<p><center><img src=\"/images/tree.png\" alt=\"结构树示意图]\"><center></center></center></p>\n<p><center>图1.结构树示意图 <center></center></center></p>\n<h3 id=\"树相关的术语\"><a href=\"#树相关的术语\" class=\"headerlink\" title=\"树相关的术语\"></a><strong>树相关的术语</strong></h3><ul>\n<li>根结点: 树最顶层结点，也是树中唯一一个没有父节点的节点，如图1中的0节点</li>\n<li>边: 两个结点之间的连接</li>\n<li>父结点: 一个节点有子节点则称这个节点是其子结点的父节点</li>\n<li>兄弟结点: 具有相同父节点的节点互为兄弟节点，如图中的6、7、8</li>\n<li>叶子结点: 树中没有子结点的结点(树得末端)，如图1中的6、7、8、9、5</li>\n<li>层次: 节点的层次从根开始定义，根为第一层，根的子节点为第二层，依次类推</li>\n<li>深度: 树中结点的最大层次称为树的深度</li>\n</ul>\n<h3 id=\"操作树\"><a href=\"#操作树\" class=\"headerlink\" title=\"操作树\"></a><strong>操作树</strong></h3><p>在计算机科学中树是一种用来模拟分层数据的数据结构，树由多个节点构成，而每个节点都有自身的数据(data)及指向其他节点(parent、children)的指针，如下定义了节点和树。</p>\n<h4 id=\"节点\"><a href=\"#节点\" class=\"headerlink\" title=\"节点\"></a>节点</h4><ul>\n<li>data: 节点的数据</li>\n<li>parent: 节点的父亲</li>\n<li>children: 节点的子节点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Node &#123;</span><br><span class=\"line\">  constructor(data) &#123;</span><br><span class=\"line\">    this.data = data;</span><br><span class=\"line\">    this.parent = null;</span><br><span class=\"line\">    this.children = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h4><p>树有一个根节点root<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Tree &#123;</span><br><span class=\"line\">  constructor(data) &#123;</span><br><span class=\"line\">    this._root = new Node(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Tree的方法\"><a href=\"#Tree的方法\" class=\"headerlink\" title=\"Tree的方法\"></a>Tree的方法</h4><p>接下来我们将要创建以下五种方法。</p>\n<ul>\n<li><p>traverseDF(callback)</p>\n</li>\n<li><p>traverseBF(callback)</p>\n</li>\n<li><p>contains(callback, traversalType)</p>\n</li>\n<li><p>add(data, toId, traversalType)</p>\n</li>\n<li><p>remove(node, parent)</p>\n</li>\n</ul>\n<p><strong>方法1/5: traverseDF(callback)</strong><br>这种方法以深度优先遍历树：从根节点出发，沿着左子树方向进行遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树的遍历，直到遍历完所有可到达的节点为止。对于图1来说深度优先遍历的结果是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">traverseDF(callback) &#123;</span><br><span class=\"line\">  const recuseNode = (node) =&gt; &#123;</span><br><span class=\"line\">    for (let i = 0; i &lt; node.children.length; i++) &#123;</span><br><span class=\"line\">      recuseNode(node.children[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callback(node);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  recuseNode(this._root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法2/5: traverseBF(callback)</strong></p>\n<p>这种方法以广度优先遍历树：从根节点出发，对每一层节点依次访问，访问一层进入下一层，而且每个节点只能访问一次。对于图1来说广度优先遍历的结果是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Queue &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">      this.dataStore = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add(element) &#123;</span><br><span class=\"line\">      this.dataStore.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">      return this.dataStore.shift();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">traverseBF(callback) &#123;</span><br><span class=\"line\">  let currentTree = this._root;</span><br><span class=\"line\">  const queue = new Queue();</span><br><span class=\"line\">  while (currentTree) &#123;</span><br><span class=\"line\">    for (let i = 0; i &lt; currentTree.children.length; i++) &#123;</span><br><span class=\"line\">      queue.add(currentTree.children[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callback(currentTree);</span><br><span class=\"line\">    currentTree = queue.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法3/5: contains(callback, traversalType)</strong><br>contains方法用于在树中搜索特定的值，它有两个参数，第一个为回调函数，每遍历到一个节点就会以该节点为回调参数回调，第二个为遍历的类型(深度遍历或广度遍历)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contains(callback, traversalType) &#123;</span><br><span class=\"line\">   const traverse = this[traversalType];</span><br><span class=\"line\">   traverse.call(this, callback);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>搜索特定id的节点就可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree.contains((node) =&gt; &#123;</span><br><span class=\"line\">  if (node.id === &apos;12345&apos;) &#123;</span><br><span class=\"line\">    console.log(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, &apos;traverseDF&apos;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法4/5: add(data, toId, traversalType)</strong></p>\n<p>该方法用于在指定节点添加节点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(data, toId, traversalType) &#123;</span><br><span class=\"line\">  let parent = null;</span><br><span class=\"line\">  //遍历是否有目标节点</span><br><span class=\"line\">  this.contains((node) =&gt; &#123;</span><br><span class=\"line\">    if (node.data === toId) &#123;</span><br><span class=\"line\">      parent = node.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, traversalType);</span><br><span class=\"line\">  //有目标节点则添加节点</span><br><span class=\"line\">  if (parent) &#123;</span><br><span class=\"line\">    const newNode = new Node(data);</span><br><span class=\"line\">    newNode.parent = parent;</span><br><span class=\"line\">    parent.children.push(newNode);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    throw new Error(`can&apos;t find the target node`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法5/5: remove(fromId, traversalType)</strong></p>\n<p>该方法用于在指定节点下的节点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remove(fromId, traversalType) &#123;</span><br><span class=\"line\">  let parent = null;</span><br><span class=\"line\">  let deleteNode = null;</span><br><span class=\"line\">  //遍历是否有目标节点</span><br><span class=\"line\">  this.contains((node) =&gt; &#123;</span><br><span class=\"line\">    if (node.id === fromId) &#123;</span><br><span class=\"line\">      parent = node.parent;</span><br><span class=\"line\">      deleteNode = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, traversalType);</span><br><span class=\"line\"></span><br><span class=\"line\">  //有目标节点则遍历目标节点的子节点是否有要删除的节点，有则删除</span><br><span class=\"line\">  if (parent) &#123;</span><br><span class=\"line\">    const findIndex = parent.children.findIndex(node =&gt; deleteNode.id === node.id);</span><br><span class=\"line\">    if (findIndex &gt;= 0) &#123;</span><br><span class=\"line\">      parent.children.splice(findIndex, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    throw new Error(`can&apos;t find the target node`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"树的完整实现\"><a href=\"#树的完整实现\" class=\"headerlink\" title=\"树的完整实现\"></a>树的完整实现</h4><p><code>`</code><br>class Queue {<br>  constructor() {<br>    this.dataStore = [];<br>  }</p>\n<p>  add(element) {<br>    this.dataStore.push(element);<br>  }</p>\n<p>  pop() {<br>    return this.dataStore.shift();<br>  }<br>}</p>\n<p>class Node {<br>  constructor(data) {<br>    this.data = data;<br>    this.parent = null;<br>    this.children = [];<br>  }<br>}</p>\n<p>class Tree {<br>  constructor(data) {<br>    this._root = new Node(data);<br>  }</p>\n<p>  traverseDF(callback) {<br>    const recuseNode = (node) =&gt; {<br>      for (let i = 0; i &lt; node.children.length; i++) {<br>        recuseNode(node.children[i]);<br>      }<br>      callback(node);<br>    };<br>    recuseNode(this._root);<br>  }</p>\n<p>  traverseBF(callback) {<br>    let currentTree = this._root;<br>    const queue = new Queue();<br>    while (currentTree) {<br>      for (let i = 0; i &lt; currentTree.children.length; i++) {<br>        queue.add(currentTree.children[i]);<br>      }<br>      callback(currentTree);<br>      currentTree = queue.pop();<br>    }<br>  }</p>\n<p>  contains(callback, traversalType) {<br>    const traverse = this[traversalType];<br>    traverse.call(this, callback);<br>  }</p>\n<p>  add(data, toId, traversalType) {<br>    let parent = null;<br>    this.contains((node) =&gt; {<br>      if (node.data === toId) {<br>        parent = node.parent;<br>      }<br>    }, traversalType);<br>    if (parent) {<br>      const newNode = new Node(data);<br>      newNode.parent = parent;<br>      parent.children.push(newNode);<br>    } else {<br>      throw new Error(<code>can&#39;t find the target node</code>);<br>    }<br>  }</p>\n<p>  remove(fromId, traversalType) {<br>    let parent = null;<br>    let deleteNode = null;<br>    this.contains((node) =&gt; {<br>      if (node.id === fromId) {<br>        parent = node.parent;<br>        deleteNode = node;<br>      }<br>    }, traversalType);</p>\n<pre><code>if (parent) {\n  const findIndex = parent.children.findIndex(node =&gt; deleteNode.data === node.data);\n  if (findIndex &gt;= 0) {\n    parent.children.splice(findIndex, 1);\n  }\n} else {\n  throw new Error(`can&apos;t find the target node`);\n}\n</code></pre><p>  }<br>}</p>\n<p>/*<br>遍历文件夹<br>RootDir<br>   ┆——DirA<br>   ┆       ┆──DirA1<br>   ┆       └──DirA2<br>   ┆            └──DirA21<br>   ┆——DirB<br>   ┆        └──DirB1<br>   └──——DirC</p>\n<p>*/</p>\n<p>const tree = new Tree(‘RootDir’);</p>\n<p>const nodeDirA = new Node(‘DirA’);<br>const nodeDirA1 = new Node(‘DirA1’);<br>const nodeDirA2 = new Node(‘DirA2’);<br>const nodeDirA21 = new Node(‘DirA21’);<br>nodeDirA.children.push(nodeDirA1);<br>nodeDirA1.parent = nodeDirA;<br>nodeDirA.children.push(nodeDirA2);<br>nodeDirA2.parent = nodeDirA;<br>nodeDirA2.children.push(nodeDirA21);<br>nodeDirA21.parent = nodeDirA2;<br>nodeDirA.parent = tree._root;<br>tree._root.children.push(nodeDirA);</p>\n<p>const nodeDirB = new Node(‘DirB’);<br>const nodeDirB1 = new Node(‘DirB1’);<br>nodeDirB.children.push(nodeDirB1);<br>nodeDirB1.parent = nodeDirB;<br>nodeDirB.parent = tree._root;<br>tree._root.children.push(nodeDirB);</p>\n<p>const nodeDirC = new Node(‘DirC’);<br>nodeDirC.parent = tree._root;<br>tree._root.children.push(nodeDirC);</p>\n<p>tree.traverseDF((node) =&gt; {<br>  console.log(node.data);<br>  /<em><br>  =&gt;<br>      DirA1<br>        DirA21<br>      DirA2<br>    DirA<br>      DirB1<br>    DirB<br>    DirC<br>  RootDir\n  </em>/<br>});</p>\n<p>tree.traverseBF((node) =&gt; {<br>  console.log(node.data);<br>  /<em><br>  =&gt;<br>  RootDir<br>    DirA<br>    DirB<br>    DirC<br>      DirA1<br>      DirA2<br>      DirB1<br>        DirA21\n  </em>/<br>});</p>\n<p>tree.contains((node) =&gt; {<br>  if (node.data === ‘DirA1’) {<br>    console.log(node);<br>  }<br>}, ‘traverseDF’);</p>\n<p>tree.add(‘DirC1’, ‘DirC’, ‘traverseBF’);<br>tree.traverseDF((node) =&gt; {<br>  console.log(node.data);<br>});<br>tree.remove(‘DirC1’, ‘traverseBF’);<br>tree.traverseDF((node) =&gt; {<br>  console.log(node.data);<br>});</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a><strong>基本概念</strong></h3><p>树是一种数据结构，之所以称之为树是因为其结构类似于🌲，它的根在上，枝叶在下。<br>树中一个最基本的数据称为节点(Node)，对应于🌲中的每一个分叉。树具有一个根节点(root)，根节点之下可能具有多个节点，节点间通过边(edge)相连，表示它们之间的关系。这种结构类似于Html文档，公司的组织结构…</p>\n<p><center><img src=\"/images/tree.png\" alt=\"结构树示意图]\"><center></center></center></p>\n<p><center>图1.结构树示意图 <center></center></center></p>\n<h3 id=\"树相关的术语\"><a href=\"#树相关的术语\" class=\"headerlink\" title=\"树相关的术语\"></a><strong>树相关的术语</strong></h3><ul>\n<li>根结点: 树最顶层结点，也是树中唯一一个没有父节点的节点，如图1中的0节点</li>\n<li>边: 两个结点之间的连接</li>\n<li>父结点: 一个节点有子节点则称这个节点是其子结点的父节点</li>\n<li>兄弟结点: 具有相同父节点的节点互为兄弟节点，如图中的6、7、8</li>\n<li>叶子结点: 树中没有子结点的结点(树得末端)，如图1中的6、7、8、9、5</li>\n<li>层次: 节点的层次从根开始定义，根为第一层，根的子节点为第二层，依次类推</li>\n<li>深度: 树中结点的最大层次称为树的深度</li>\n</ul>\n<h3 id=\"操作树\"><a href=\"#操作树\" class=\"headerlink\" title=\"操作树\"></a><strong>操作树</strong></h3><p>在计算机科学中树是一种用来模拟分层数据的数据结构，树由多个节点构成，而每个节点都有自身的数据(data)及指向其他节点(parent、children)的指针，如下定义了节点和树。</p>\n<h4 id=\"节点\"><a href=\"#节点\" class=\"headerlink\" title=\"节点\"></a>节点</h4><ul>\n<li>data: 节点的数据</li>\n<li>parent: 节点的父亲</li>\n<li>children: 节点的子节点</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Node &#123;</span><br><span class=\"line\">  constructor(data) &#123;</span><br><span class=\"line\">    this.data = data;</span><br><span class=\"line\">    this.parent = null;</span><br><span class=\"line\">    this.children = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h4><p>树有一个根节点root<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Tree &#123;</span><br><span class=\"line\">  constructor(data) &#123;</span><br><span class=\"line\">    this._root = new Node(data);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Tree的方法\"><a href=\"#Tree的方法\" class=\"headerlink\" title=\"Tree的方法\"></a>Tree的方法</h4><p>接下来我们将要创建以下五种方法。</p>\n<ul>\n<li><p>traverseDF(callback)</p>\n</li>\n<li><p>traverseBF(callback)</p>\n</li>\n<li><p>contains(callback, traversalType)</p>\n</li>\n<li><p>add(data, toId, traversalType)</p>\n</li>\n<li><p>remove(node, parent)</p>\n</li>\n</ul>\n<p><strong>方法1/5: traverseDF(callback)</strong><br>这种方法以深度优先遍历树：从根节点出发，沿着左子树方向进行遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树的遍历，直到遍历完所有可到达的节点为止。对于图1来说深度优先遍历的结果是:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">traverseDF(callback) &#123;</span><br><span class=\"line\">  const recuseNode = (node) =&gt; &#123;</span><br><span class=\"line\">    for (let i = 0; i &lt; node.children.length; i++) &#123;</span><br><span class=\"line\">      recuseNode(node.children[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callback(node);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  recuseNode(this._root);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法2/5: traverseBF(callback)</strong></p>\n<p>这种方法以广度优先遍历树：从根节点出发，对每一层节点依次访问，访问一层进入下一层，而且每个节点只能访问一次。对于图1来说广度优先遍历的结果是:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Queue &#123;</span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">      this.dataStore = [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  add(element) &#123;</span><br><span class=\"line\">      this.dataStore.push(element);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  pop() &#123;</span><br><span class=\"line\">      return this.dataStore.shift();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">traverseBF(callback) &#123;</span><br><span class=\"line\">  let currentTree = this._root;</span><br><span class=\"line\">  const queue = new Queue();</span><br><span class=\"line\">  while (currentTree) &#123;</span><br><span class=\"line\">    for (let i = 0; i &lt; currentTree.children.length; i++) &#123;</span><br><span class=\"line\">      queue.add(currentTree.children[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    callback(currentTree);</span><br><span class=\"line\">    currentTree = queue.pop();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法3/5: contains(callback, traversalType)</strong><br>contains方法用于在树中搜索特定的值，它有两个参数，第一个为回调函数，每遍历到一个节点就会以该节点为回调参数回调，第二个为遍历的类型(深度遍历或广度遍历)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">contains(callback, traversalType) &#123;</span><br><span class=\"line\">   const traverse = this[traversalType];</span><br><span class=\"line\">   traverse.call(this, callback);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></p>\n<p>搜索特定id的节点就可以这样写：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tree.contains((node) =&gt; &#123;</span><br><span class=\"line\">  if (node.id === &apos;12345&apos;) &#123;</span><br><span class=\"line\">    console.log(node);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;, &apos;traverseDF&apos;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法4/5: add(data, toId, traversalType)</strong></p>\n<p>该方法用于在指定节点添加节点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(data, toId, traversalType) &#123;</span><br><span class=\"line\">  let parent = null;</span><br><span class=\"line\">  //遍历是否有目标节点</span><br><span class=\"line\">  this.contains((node) =&gt; &#123;</span><br><span class=\"line\">    if (node.data === toId) &#123;</span><br><span class=\"line\">      parent = node.parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, traversalType);</span><br><span class=\"line\">  //有目标节点则添加节点</span><br><span class=\"line\">  if (parent) &#123;</span><br><span class=\"line\">    const newNode = new Node(data);</span><br><span class=\"line\">    newNode.parent = parent;</span><br><span class=\"line\">    parent.children.push(newNode);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    throw new Error(`can&apos;t find the target node`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>方法5/5: remove(fromId, traversalType)</strong></p>\n<p>该方法用于在指定节点下的节点。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">remove(fromId, traversalType) &#123;</span><br><span class=\"line\">  let parent = null;</span><br><span class=\"line\">  let deleteNode = null;</span><br><span class=\"line\">  //遍历是否有目标节点</span><br><span class=\"line\">  this.contains((node) =&gt; &#123;</span><br><span class=\"line\">    if (node.id === fromId) &#123;</span><br><span class=\"line\">      parent = node.parent;</span><br><span class=\"line\">      deleteNode = node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, traversalType);</span><br><span class=\"line\"></span><br><span class=\"line\">  //有目标节点则遍历目标节点的子节点是否有要删除的节点，有则删除</span><br><span class=\"line\">  if (parent) &#123;</span><br><span class=\"line\">    const findIndex = parent.children.findIndex(node =&gt; deleteNode.id === node.id);</span><br><span class=\"line\">    if (findIndex &gt;= 0) &#123;</span><br><span class=\"line\">      parent.children.splice(findIndex, 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    throw new Error(`can&apos;t find the target node`);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"树的完整实现\"><a href=\"#树的完整实现\" class=\"headerlink\" title=\"树的完整实现\"></a>树的完整实现</h4><p><code>`</code><br>class Queue {<br>  constructor() {<br>    this.dataStore = [];<br>  }</p>\n<p>  add(element) {<br>    this.dataStore.push(element);<br>  }</p>\n<p>  pop() {<br>    return this.dataStore.shift();<br>  }<br>}</p>\n<p>class Node {<br>  constructor(data) {<br>    this.data = data;<br>    this.parent = null;<br>    this.children = [];<br>  }<br>}</p>\n<p>class Tree {<br>  constructor(data) {<br>    this._root = new Node(data);<br>  }</p>\n<p>  traverseDF(callback) {<br>    const recuseNode = (node) =&gt; {<br>      for (let i = 0; i &lt; node.children.length; i++) {<br>        recuseNode(node.children[i]);<br>      }<br>      callback(node);<br>    };<br>    recuseNode(this._root);<br>  }</p>\n<p>  traverseBF(callback) {<br>    let currentTree = this._root;<br>    const queue = new Queue();<br>    while (currentTree) {<br>      for (let i = 0; i &lt; currentTree.children.length; i++) {<br>        queue.add(currentTree.children[i]);<br>      }<br>      callback(currentTree);<br>      currentTree = queue.pop();<br>    }<br>  }</p>\n<p>  contains(callback, traversalType) {<br>    const traverse = this[traversalType];<br>    traverse.call(this, callback);<br>  }</p>\n<p>  add(data, toId, traversalType) {<br>    let parent = null;<br>    this.contains((node) =&gt; {<br>      if (node.data === toId) {<br>        parent = node.parent;<br>      }<br>    }, traversalType);<br>    if (parent) {<br>      const newNode = new Node(data);<br>      newNode.parent = parent;<br>      parent.children.push(newNode);<br>    } else {<br>      throw new Error(<code>can&#39;t find the target node</code>);<br>    }<br>  }</p>\n<p>  remove(fromId, traversalType) {<br>    let parent = null;<br>    let deleteNode = null;<br>    this.contains((node) =&gt; {<br>      if (node.id === fromId) {<br>        parent = node.parent;<br>        deleteNode = node;<br>      }<br>    }, traversalType);</p>\n<pre><code>if (parent) {\n  const findIndex = parent.children.findIndex(node =&gt; deleteNode.data === node.data);\n  if (findIndex &gt;= 0) {\n    parent.children.splice(findIndex, 1);\n  }\n} else {\n  throw new Error(`can&apos;t find the target node`);\n}\n</code></pre><p>  }<br>}</p>\n<p>/*<br>遍历文件夹<br>RootDir<br>   ┆——DirA<br>   ┆       ┆──DirA1<br>   ┆       └──DirA2<br>   ┆            └──DirA21<br>   ┆——DirB<br>   ┆        └──DirB1<br>   └──——DirC</p>\n<p>*/</p>\n<p>const tree = new Tree(‘RootDir’);</p>\n<p>const nodeDirA = new Node(‘DirA’);<br>const nodeDirA1 = new Node(‘DirA1’);<br>const nodeDirA2 = new Node(‘DirA2’);<br>const nodeDirA21 = new Node(‘DirA21’);<br>nodeDirA.children.push(nodeDirA1);<br>nodeDirA1.parent = nodeDirA;<br>nodeDirA.children.push(nodeDirA2);<br>nodeDirA2.parent = nodeDirA;<br>nodeDirA2.children.push(nodeDirA21);<br>nodeDirA21.parent = nodeDirA2;<br>nodeDirA.parent = tree._root;<br>tree._root.children.push(nodeDirA);</p>\n<p>const nodeDirB = new Node(‘DirB’);<br>const nodeDirB1 = new Node(‘DirB1’);<br>nodeDirB.children.push(nodeDirB1);<br>nodeDirB1.parent = nodeDirB;<br>nodeDirB.parent = tree._root;<br>tree._root.children.push(nodeDirB);</p>\n<p>const nodeDirC = new Node(‘DirC’);<br>nodeDirC.parent = tree._root;<br>tree._root.children.push(nodeDirC);</p>\n<p>tree.traverseDF((node) =&gt; {<br>  console.log(node.data);<br>  /<em><br>  =&gt;<br>      DirA1<br>        DirA21<br>      DirA2<br>    DirA<br>      DirB1<br>    DirB<br>    DirC<br>  RootDir\n  </em>/<br>});</p>\n<p>tree.traverseBF((node) =&gt; {<br>  console.log(node.data);<br>  /<em><br>  =&gt;<br>  RootDir<br>    DirA<br>    DirB<br>    DirC<br>      DirA1<br>      DirA2<br>      DirB1<br>        DirA21\n  </em>/<br>});</p>\n<p>tree.contains((node) =&gt; {<br>  if (node.data === ‘DirA1’) {<br>    console.log(node);<br>  }<br>}, ‘traverseDF’);</p>\n<p>tree.add(‘DirC1’, ‘DirC’, ‘traverseBF’);<br>tree.traverseDF((node) =&gt; {<br>  console.log(node.data);<br>});<br>tree.remove(‘DirC1’, ‘traverseBF’);<br>tree.traverseDF((node) =&gt; {<br>  console.log(node.data);<br>});</p>\n"},{"layout":"post","title":"正则表达式","tagline":"Supporting tagline","description":"正则表达式，对于前端同学的我来说用得不多，也就一直没去研究，当需要写正则时候就是一头雾水，包括配置webpack,jest等。于是在这里整理了一些JavaScritpt正则相关的内容，以此对正则表达式有一个基本的认识并能够运用正则处理日常需求。","date":"2017-02-25T12:10:00.000Z","_content":"\n### **基本概念**\n\n- **正则表达式**\n  它描述了一种字符串匹配的模式，即\b要寻找符合这一模式(某种规则)的子串，找到后进行提取或替换。\n\n- **元字符**\n在正则表达式中具有特殊含义的字符，如`+`号，代表前面的字符必须至少出现一次（1次或多次），runoo+b，可以匹配 runoob、runooob、runoooooob等。\n`*` 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）\nrunoo*b，可以匹配 runob、runoob、runoooooob 等。\n如果要匹配字符串中的特殊符号，则需要对其进行转义，即在其前加一个` \\`，如`runo\\+ob` 匹配 `runo+ob`。\n以下是正则中的特殊字符：\n  ```\n  ( ) [ ] { } \\ ^ $ | ? * + . \n  ```\n\n- **子模式**\n 在正则表达式中，可以使用括号()将模式中的子字符串括起来，以形成一个子模式。将子模式视为一个整体时，那么它就相当于一个单个字符。\n\n\n### **正则表达式形式**\n\n正则表达式是包含在两个斜杠之间的一个或多个字符，在后一个斜杠的后面，可以指定一个或多个选项。正则表达式也可以通过对象RegExp的构造函数来生成，带有变量的字符串通过RegExp能够比较简单生成正则表达式，而采用‘/pattern/’的方式变量会识别成字面量。\n```\n var regExp = /pattern/flags\n 或 var regExpStr = new RegExp(regStr, pattern)\n```\n其中，“pattern”为指定的匹配模式，flags为0个或多个可选项，这些选项及其含义如下：\n\ni：表示忽略大小写，就是在字符串匹配的时候不区分大小写。\ng：表示全局匹配，即匹配字符串中出现的所有模式。\nm：表示进行多行匹配。\n\n\n### **JS中字符串匹配和替换**\n\n- 字符串匹配\n语法：str.match(regExp)\n参数：regExp为一个正则表达式\n返回值：如果字符串匹配到了表达式则返回一个数组，数组的第一个元素为匹配到的内容，之后的项是小括号\n捕获的内容，如果没有匹配到则返回null。\n例：匹配数字\n```\nvar str = \"you know that I am 17 years old\";\n//\\d表示数字+号表示出现多次，即可匹配数字17\nvar patt = /I am (\\d+)/;\n\nstr.match(patt)\n//17为小括号捕获的内容，index为匹配的位置(字符I的位置)\n=>  [\"I am 17\", \"17\", index: 0, input: \"I am 17 years old\", groups: undefined]\n\n```\n\n- 字符串替换\n语法：str.replace(regexp|str, newSubstr|func)\n参数：第一个参数为一个正则表达式或子串，第二个参数为要替换的内容或一个返回替换内容的函数\n例：匹配数字\n```\nfunction replacer(match, s1, s2, offset, string) {\n  //match为匹配的结果, s1(67),s2(123)为小括号匹配到的内容,offset为匹配到的位置(1，即a67bc123中6的位置)\n  return [s1, s2].join(' - ');\n}\nvar newString = 'a67bc123'.replace(/a(\\d+)bc(\\d+)/, replacer);\n或var newString = 'a67bc123'.replace(/a(\\d+)bc(\\d+)/, `$1 - $2`);\n=> newString: \"67 - 123\"\n```\n### **特殊字符用法**\n\n- `\\` 标记其后的字符为特殊字符、转义字符\n  \n  如`\\r`代表回车符，`\\b`表示一个字符边界，反斜杠`\\`也可以将其后的特殊字符转义为字面量，例如模式`/a*/`代表会匹配0个或者多个a。相反，模式`/a\\*/`将`*`的特殊性移除，从而可以匹配像`a*`这样的字符串。`\\\\`表示一个`\\`,第一个`\\`为转义字符，第二个`\\`为特殊字符`\\`。\n  \n- `^` 匹配输入的开始位置\n  如果多行标志为true时也匹配换行符后紧跟的位置。\n  \n  匹配以snow开头的字符串\n  ```\n  //如下/^snow/匹配snow is my name但不匹配my name is snow\n  var str = \"snow is my name\";\n  var patt = /^snow/;\n  ```\n- `$` 匹配输入结束的位置\n  匹配输入的结束。如果多行标示为true时也匹配换行符前的位置。\n  ```\n  //如下/snow$/匹配my name is snow但不匹配snow is my name\n  var str = \"my name is snow\";\n  var patt = /snow$/;\n  ```\n  匹配snow这个字符串, 如下^$结合可以匹配snow(snow为开始和结束即仅匹配snow，不匹配snow is snow)\n  ```\n  var str = \"snow\";\n  var patt = /^snow$/;\n  ```\n\n- `|` 类似或，指明两项之间的一个选择\n  \n  匹配苹果或香蕉\n  ```\n  var str = \"banana\";\n  var patt = /apple|banana/;\n  ```\n- `{n}` 匹配前一项连续出现n次\n  如，/p{2}/不会匹配aple中的p,但会匹配apple中所有的p。\n  ```\n  var str = \"apple is a apple\";\n  var patt = /(apple){2}/;\n  console.log(str.match(patt)); => null\n\n  var str = \"appleapple 2 apple\";\n  var patt = /(apple){2}/;\n  console.log(str.match(patt)); => appleapple\n  ```\n- `{m,n}` 匹配前一项连续出现m到n次，包括m、n次\n    ```\n  var str = \"apple is a apple\";\n  var patt = /(apple){2,3}/;\n  console.log(str.match(patt)); => null\n\n  var str = \"appleapple 2 apple\";\n  var patt = /(apple){2,3}/;\n  console.log(str.match(patt)); => appleapple\n  ```\n- `.` 默认情况下, 句点匹配除新行符(换行符`\\n`和回车符`\\r`)外的任何单个字符\n\n  匹配snow_，如下/snow./可以匹配snow1，snowa，snow_等。\n  ```\n  var str = \"snow_\";\n  var patt = /snow./;\n  ```\n\n- `*` 匹配零个或多个前一项,等价于 {0,}。\n\n  匹配a，如下a*可以匹配aabc，aaaabc，甚至不包含 \"a\" 的任意字符串.\n  ```\n  var str = \"aaaabaac\";\n  var patt = /ba*/;\n  console.log(str.match(patt)) => baa\n  ```\n  通配符: 句点星号模式 .* 可以匹配零个或多个任意字符 (除了新行符: `\\r` 和 `\\n`). 例如, snow.*123 可以匹配 snowAnything123, 也能匹配 snow123.\n\n- `+` 匹配前一项一个或多个,等价于 {1,}。 \n  例如，/p+/匹配了在 \"apppppple\" 中的 'p'。\n  \n- `?` 匹配零个或一个前面的字符，可以理解为\"前面的那项是可选的\". 例如, colou?r 可以匹配color和colour, 因为 \"u\" 是可选的, abcd(efg)?hij可以匹配abcdhij和abcdefghij。\n\n\n- `()` 标记一个子表达式(分组)的开始和结束位置\n  每一个子表达式会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推\n  子表达式的结果可以获取供以后使用, 如下子表达式的值为phone\n  ```\n  var str = \"apple is a iphone\";\n  var patt = /i(phone$)/;\n  console.log(str.match(patt));\n  => [ 'iphone', 'phone', index: 11, input: 'apple is a iphone' ]\n\n  var str = \"there is a iphonePlus called iphonePlus\";\n  var patt = /(iphone)(Plus).*\\1\\2$/; //\\1、\\2表示子表达式1、2的结果，即iphone、Plus\n  console.log(str.match(patt));\n  => [ 'iphonePlus called iphonePlus',\n       'iphone',\n       'Plus',\n       index: 11,\n       input: 'there is a iphonePlus called iphonePlus' ]\n\n  ```\n\n- `(x)` 匹配'x'并且记住匹配项，括号被称为捕获括号。\n  ```\n  var str = \"there is a iphone called iphone\";\n  var patt = /(iphone).*\\1$/; //因为记住了匹配项，所有\\1能够拿到子表达式1的结果iphone\n  console.log(str.match(patt));\n  =>[ 'iphone called iphone',\n  'iphone',\n  index: 11,\n  input: 'there is a iphone called iphone' ]\n  ```\n\n- `(?:x)` 匹配 'x' 但是不记住匹配项。这种叫作非捕获括号\n  ```\n  var str = \"there is a iphone called iphone\";\n  var patt = /(?:iphone).*\\1$/; //因为没有记住匹配项，所有\\1不能拿到子表达式1的结果，匹配为null\n  console.log(str.match(patt));\n  =>null\n  ```\n- `x(?=y)` 匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。\n  ```\n  var str = \"iphoneX and iphonePlus\";\n  var patt = /iphone(?=Plus)/; //匹配iphonePlus的iphone\n  console.log(str.match(patt));\n  =>[ 'iphone', index: 12, input: 'iphoneX and iphonePlus' ]\n  ```\n\n- `x(?!y)` 匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。\n  ```\n  var str = \"iphoneX and iphonePlus\";\n  var patt = /iphone(?!Plus)/;//匹配iphoneX的iphone\n  console.log(str.match(patt));\n  => [ 'iphone', index: 0, input: 'iphoneX and iphonePlus' ]\n  ```\n\n- `[xyz]`\n字符类：元字符`[`和`]`指定正则表达式中的字符类。\n字符类“[123]\"将匹配字符1，2或3.例如，字符串“man\"或“men\"将匹配正则表达式“m[ae]n\"。\n可以使用连字符-来指定字符范围，如[A-Z]表示所有大写任何字母;[0-9]表示0和9之间的任何数字。[a-ex-z]\t字符a到d或x到z，其将包括a，b，c，d, x，y或z。\n\n- `[^xyz]`\n一个反向字符集。^表示除也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。\n[^abc]，[^a-c] \t除a，b和c以外的字符\n\n- `[\\b]` 匹配一个退格(U+0008)。（不要和\\b混淆了）\n\n- `\\b` 匹配一个单词的边界，一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置\n例子：\n/\\bm/匹配“moon”中得‘m’；\n/oo\\b/并不匹配\"moon\"中得'oo'，因为'oo'被一个“字”字符'n'紧跟着。\n/oon\\b/匹配\"moon\"中得'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”符紧跟着。\n\n- `\\B` 匹配一个非单词边界\n例如，/\\Bday/匹配\"noonday\"中的'oon', 而/y\\B./匹配\"possibly yesterday\"中的’y‘\n\n- `\\d`\t\n匹配一个数字。\n等价于[0-9]。\n例如， /\\d/ 或者 /[0-9]/ 匹配\"B2 is the suite number.\"中的'2'。\n\n- `\\D`\t\n匹配一个非数字字符。\n等价于[^0-9]。\n例如， /\\D/ 或者 /[^0-9]/ 匹配\"B2 is the suite number.\"中的'B' 。\n\n- `\\f`\t匹配一个换页符 (U+000C)。\n- `\\n`\t匹配一个换行符 (U+000A)或捕获的子串。\n在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。\n比如 /apple(,)\\sorange\\1/ 匹配\"apple, orange, cherry, peach.\"中的'apple, orange,' 。\n- `\\r`\t匹配一个回车符 (U+000D)。\n- `\\s`\t\n匹配一个空白字符，包括空格、制表符、换页符和换行符。\n等价于[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。\n例如, /\\s\\w*/ 匹配\"foo bar.\"中的' bar'。\n\n- `\\S`\t\n匹配一个非空白字符。\n等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。\n例如， /\\S\\w*/ 匹配\"foo bar.\"中的'foo'。\n\n- `\\t`\t匹配一个水平制表符 (U+0009)。\n- `\\v`\t匹配一个垂直制表符 (U+000B)。\n- `\\w`\t\n匹配一个单字字符（字母、数字或者下划线）。\n等价于[A-Za-z0-9_]。\n例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3'。\n\n- `\\W`\n匹配一个非单字字符。\n等价于[^A-Za-z0-9_]。\n例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%'。\n\n- `\\0`\t匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \\0<digits> 是一个八进制转义序列。\n- `\\xhh`\t与代码 hh 匹配字符（两个十六进制数字）\n- `\\uhhhh`\t与代码 hhhh 匹配字符（四个十六进制数字）。\n\n- `?#comment`注释\n```\nvar patt = /\\/(?#匹配斜杠/)/;\n```\n\n\n### **实例**\n \n- 匹配斜杠/\n```\nvar str = \"/public/image/a.png\";\nvar patt = /\\//;\nconsole.log(str.match(patt));\n=>[\"/\", index: 0, input: \"/public/image/a.png\", groups: undefined]\n```\n\n- 匹配最后一个斜杠后的，最后一个点前的内容\n```\nvar s = 'http://i2.xxx.com/wx/images_2016/monkey/m4_1e3thtr.png';\n\n//要匹配目标内容，可以从后往回推，首先是后缀名(.*表示)，后缀名前跟着一个'.'(\\.表示)，'.'前则是目标内容，用括号捕获，目标内容前为斜杠(\\/表示)，斜杠前为任意内容，正则表达式如下：\nvar r =/.*\\/(.*)\\..*/;\nvar m = s.match(r);\nconsole.log(str.match(patt));\n=> [\"http://i2.xxx.com/wx/images_2016/monkey/m4_1e3thtr.png\",\"m4_1e3thtr\"]\n```\n\n- 验证字符串组成，第一个为数字，后面可以是字母、数字、下划线组成的1到50位的字符。\n  \n`str.match(/\\d\\w{1,50}$/)`\n\n- js将一浮点数小数点左边的数字每三位加一个逗号\n  \n```\n//当一个字符串中某个数字后跟着n对三个数字(\\d{3})就匹配这个数字\nconst formateNum = (num) => {\n  const numStr = num.toString();\n  //替换小数点左边的数字\n  return numStr.replace(/\\d+/, (match) => {\n    //替换目标数字为`${matchNum},`\n    return match.replace(/(\\d)(?=(\\d{3}+$))/, (s1) => `${s1},`);\n  })\n}\n\nformateNum(435345.656)\n=> \"435,345.656\"\n```\n\n\n","source":"_posts/正则表达式.md","raw":"---\nlayout: post\ntitle: 正则表达式\ncategory : JS\ntagline: \"Supporting tagline\"\ntags : [JS]\ndescription: 正则表达式，对于前端同学的我来说用得不多，也就一直没去研究，当需要写正则时候就是一头雾水，包括配置webpack,jest等。于是在这里整理了一些JavaScritpt正则相关的内容，以此对正则表达式有一个基本的认识并能够运用正则处理日常需求。\ndate: 2017-2-25 20:10:00\n---\n\n### **基本概念**\n\n- **正则表达式**\n  它描述了一种字符串匹配的模式，即\b要寻找符合这一模式(某种规则)的子串，找到后进行提取或替换。\n\n- **元字符**\n在正则表达式中具有特殊含义的字符，如`+`号，代表前面的字符必须至少出现一次（1次或多次），runoo+b，可以匹配 runoob、runooob、runoooooob等。\n`*` 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）\nrunoo*b，可以匹配 runob、runoob、runoooooob 等。\n如果要匹配字符串中的特殊符号，则需要对其进行转义，即在其前加一个` \\`，如`runo\\+ob` 匹配 `runo+ob`。\n以下是正则中的特殊字符：\n  ```\n  ( ) [ ] { } \\ ^ $ | ? * + . \n  ```\n\n- **子模式**\n 在正则表达式中，可以使用括号()将模式中的子字符串括起来，以形成一个子模式。将子模式视为一个整体时，那么它就相当于一个单个字符。\n\n\n### **正则表达式形式**\n\n正则表达式是包含在两个斜杠之间的一个或多个字符，在后一个斜杠的后面，可以指定一个或多个选项。正则表达式也可以通过对象RegExp的构造函数来生成，带有变量的字符串通过RegExp能够比较简单生成正则表达式，而采用‘/pattern/’的方式变量会识别成字面量。\n```\n var regExp = /pattern/flags\n 或 var regExpStr = new RegExp(regStr, pattern)\n```\n其中，“pattern”为指定的匹配模式，flags为0个或多个可选项，这些选项及其含义如下：\n\ni：表示忽略大小写，就是在字符串匹配的时候不区分大小写。\ng：表示全局匹配，即匹配字符串中出现的所有模式。\nm：表示进行多行匹配。\n\n\n### **JS中字符串匹配和替换**\n\n- 字符串匹配\n语法：str.match(regExp)\n参数：regExp为一个正则表达式\n返回值：如果字符串匹配到了表达式则返回一个数组，数组的第一个元素为匹配到的内容，之后的项是小括号\n捕获的内容，如果没有匹配到则返回null。\n例：匹配数字\n```\nvar str = \"you know that I am 17 years old\";\n//\\d表示数字+号表示出现多次，即可匹配数字17\nvar patt = /I am (\\d+)/;\n\nstr.match(patt)\n//17为小括号捕获的内容，index为匹配的位置(字符I的位置)\n=>  [\"I am 17\", \"17\", index: 0, input: \"I am 17 years old\", groups: undefined]\n\n```\n\n- 字符串替换\n语法：str.replace(regexp|str, newSubstr|func)\n参数：第一个参数为一个正则表达式或子串，第二个参数为要替换的内容或一个返回替换内容的函数\n例：匹配数字\n```\nfunction replacer(match, s1, s2, offset, string) {\n  //match为匹配的结果, s1(67),s2(123)为小括号匹配到的内容,offset为匹配到的位置(1，即a67bc123中6的位置)\n  return [s1, s2].join(' - ');\n}\nvar newString = 'a67bc123'.replace(/a(\\d+)bc(\\d+)/, replacer);\n或var newString = 'a67bc123'.replace(/a(\\d+)bc(\\d+)/, `$1 - $2`);\n=> newString: \"67 - 123\"\n```\n### **特殊字符用法**\n\n- `\\` 标记其后的字符为特殊字符、转义字符\n  \n  如`\\r`代表回车符，`\\b`表示一个字符边界，反斜杠`\\`也可以将其后的特殊字符转义为字面量，例如模式`/a*/`代表会匹配0个或者多个a。相反，模式`/a\\*/`将`*`的特殊性移除，从而可以匹配像`a*`这样的字符串。`\\\\`表示一个`\\`,第一个`\\`为转义字符，第二个`\\`为特殊字符`\\`。\n  \n- `^` 匹配输入的开始位置\n  如果多行标志为true时也匹配换行符后紧跟的位置。\n  \n  匹配以snow开头的字符串\n  ```\n  //如下/^snow/匹配snow is my name但不匹配my name is snow\n  var str = \"snow is my name\";\n  var patt = /^snow/;\n  ```\n- `$` 匹配输入结束的位置\n  匹配输入的结束。如果多行标示为true时也匹配换行符前的位置。\n  ```\n  //如下/snow$/匹配my name is snow但不匹配snow is my name\n  var str = \"my name is snow\";\n  var patt = /snow$/;\n  ```\n  匹配snow这个字符串, 如下^$结合可以匹配snow(snow为开始和结束即仅匹配snow，不匹配snow is snow)\n  ```\n  var str = \"snow\";\n  var patt = /^snow$/;\n  ```\n\n- `|` 类似或，指明两项之间的一个选择\n  \n  匹配苹果或香蕉\n  ```\n  var str = \"banana\";\n  var patt = /apple|banana/;\n  ```\n- `{n}` 匹配前一项连续出现n次\n  如，/p{2}/不会匹配aple中的p,但会匹配apple中所有的p。\n  ```\n  var str = \"apple is a apple\";\n  var patt = /(apple){2}/;\n  console.log(str.match(patt)); => null\n\n  var str = \"appleapple 2 apple\";\n  var patt = /(apple){2}/;\n  console.log(str.match(patt)); => appleapple\n  ```\n- `{m,n}` 匹配前一项连续出现m到n次，包括m、n次\n    ```\n  var str = \"apple is a apple\";\n  var patt = /(apple){2,3}/;\n  console.log(str.match(patt)); => null\n\n  var str = \"appleapple 2 apple\";\n  var patt = /(apple){2,3}/;\n  console.log(str.match(patt)); => appleapple\n  ```\n- `.` 默认情况下, 句点匹配除新行符(换行符`\\n`和回车符`\\r`)外的任何单个字符\n\n  匹配snow_，如下/snow./可以匹配snow1，snowa，snow_等。\n  ```\n  var str = \"snow_\";\n  var patt = /snow./;\n  ```\n\n- `*` 匹配零个或多个前一项,等价于 {0,}。\n\n  匹配a，如下a*可以匹配aabc，aaaabc，甚至不包含 \"a\" 的任意字符串.\n  ```\n  var str = \"aaaabaac\";\n  var patt = /ba*/;\n  console.log(str.match(patt)) => baa\n  ```\n  通配符: 句点星号模式 .* 可以匹配零个或多个任意字符 (除了新行符: `\\r` 和 `\\n`). 例如, snow.*123 可以匹配 snowAnything123, 也能匹配 snow123.\n\n- `+` 匹配前一项一个或多个,等价于 {1,}。 \n  例如，/p+/匹配了在 \"apppppple\" 中的 'p'。\n  \n- `?` 匹配零个或一个前面的字符，可以理解为\"前面的那项是可选的\". 例如, colou?r 可以匹配color和colour, 因为 \"u\" 是可选的, abcd(efg)?hij可以匹配abcdhij和abcdefghij。\n\n\n- `()` 标记一个子表达式(分组)的开始和结束位置\n  每一个子表达式会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推\n  子表达式的结果可以获取供以后使用, 如下子表达式的值为phone\n  ```\n  var str = \"apple is a iphone\";\n  var patt = /i(phone$)/;\n  console.log(str.match(patt));\n  => [ 'iphone', 'phone', index: 11, input: 'apple is a iphone' ]\n\n  var str = \"there is a iphonePlus called iphonePlus\";\n  var patt = /(iphone)(Plus).*\\1\\2$/; //\\1、\\2表示子表达式1、2的结果，即iphone、Plus\n  console.log(str.match(patt));\n  => [ 'iphonePlus called iphonePlus',\n       'iphone',\n       'Plus',\n       index: 11,\n       input: 'there is a iphonePlus called iphonePlus' ]\n\n  ```\n\n- `(x)` 匹配'x'并且记住匹配项，括号被称为捕获括号。\n  ```\n  var str = \"there is a iphone called iphone\";\n  var patt = /(iphone).*\\1$/; //因为记住了匹配项，所有\\1能够拿到子表达式1的结果iphone\n  console.log(str.match(patt));\n  =>[ 'iphone called iphone',\n  'iphone',\n  index: 11,\n  input: 'there is a iphone called iphone' ]\n  ```\n\n- `(?:x)` 匹配 'x' 但是不记住匹配项。这种叫作非捕获括号\n  ```\n  var str = \"there is a iphone called iphone\";\n  var patt = /(?:iphone).*\\1$/; //因为没有记住匹配项，所有\\1不能拿到子表达式1的结果，匹配为null\n  console.log(str.match(patt));\n  =>null\n  ```\n- `x(?=y)` 匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。\n  ```\n  var str = \"iphoneX and iphonePlus\";\n  var patt = /iphone(?=Plus)/; //匹配iphonePlus的iphone\n  console.log(str.match(patt));\n  =>[ 'iphone', index: 12, input: 'iphoneX and iphonePlus' ]\n  ```\n\n- `x(?!y)` 匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。\n  ```\n  var str = \"iphoneX and iphonePlus\";\n  var patt = /iphone(?!Plus)/;//匹配iphoneX的iphone\n  console.log(str.match(patt));\n  => [ 'iphone', index: 0, input: 'iphoneX and iphonePlus' ]\n  ```\n\n- `[xyz]`\n字符类：元字符`[`和`]`指定正则表达式中的字符类。\n字符类“[123]\"将匹配字符1，2或3.例如，字符串“man\"或“men\"将匹配正则表达式“m[ae]n\"。\n可以使用连字符-来指定字符范围，如[A-Z]表示所有大写任何字母;[0-9]表示0和9之间的任何数字。[a-ex-z]\t字符a到d或x到z，其将包括a，b，c，d, x，y或z。\n\n- `[^xyz]`\n一个反向字符集。^表示除也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。\n[^abc]，[^a-c] \t除a，b和c以外的字符\n\n- `[\\b]` 匹配一个退格(U+0008)。（不要和\\b混淆了）\n\n- `\\b` 匹配一个单词的边界，一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置\n例子：\n/\\bm/匹配“moon”中得‘m’；\n/oo\\b/并不匹配\"moon\"中得'oo'，因为'oo'被一个“字”字符'n'紧跟着。\n/oon\\b/匹配\"moon\"中得'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”符紧跟着。\n\n- `\\B` 匹配一个非单词边界\n例如，/\\Bday/匹配\"noonday\"中的'oon', 而/y\\B./匹配\"possibly yesterday\"中的’y‘\n\n- `\\d`\t\n匹配一个数字。\n等价于[0-9]。\n例如， /\\d/ 或者 /[0-9]/ 匹配\"B2 is the suite number.\"中的'2'。\n\n- `\\D`\t\n匹配一个非数字字符。\n等价于[^0-9]。\n例如， /\\D/ 或者 /[^0-9]/ 匹配\"B2 is the suite number.\"中的'B' 。\n\n- `\\f`\t匹配一个换页符 (U+000C)。\n- `\\n`\t匹配一个换行符 (U+000A)或捕获的子串。\n在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。\n比如 /apple(,)\\sorange\\1/ 匹配\"apple, orange, cherry, peach.\"中的'apple, orange,' 。\n- `\\r`\t匹配一个回车符 (U+000D)。\n- `\\s`\t\n匹配一个空白字符，包括空格、制表符、换页符和换行符。\n等价于[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。\n例如, /\\s\\w*/ 匹配\"foo bar.\"中的' bar'。\n\n- `\\S`\t\n匹配一个非空白字符。\n等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。\n例如， /\\S\\w*/ 匹配\"foo bar.\"中的'foo'。\n\n- `\\t`\t匹配一个水平制表符 (U+0009)。\n- `\\v`\t匹配一个垂直制表符 (U+000B)。\n- `\\w`\t\n匹配一个单字字符（字母、数字或者下划线）。\n等价于[A-Za-z0-9_]。\n例如, /\\w/ 匹配 \"apple,\" 中的 'a'，\"$5.28,\"中的 '5' 和 \"3D.\" 中的 '3'。\n\n- `\\W`\n匹配一个非单字字符。\n等价于[^A-Za-z0-9_]。\n例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 \"50%.\" 中的 '%'。\n\n- `\\0`\t匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \\0<digits> 是一个八进制转义序列。\n- `\\xhh`\t与代码 hh 匹配字符（两个十六进制数字）\n- `\\uhhhh`\t与代码 hhhh 匹配字符（四个十六进制数字）。\n\n- `?#comment`注释\n```\nvar patt = /\\/(?#匹配斜杠/)/;\n```\n\n\n### **实例**\n \n- 匹配斜杠/\n```\nvar str = \"/public/image/a.png\";\nvar patt = /\\//;\nconsole.log(str.match(patt));\n=>[\"/\", index: 0, input: \"/public/image/a.png\", groups: undefined]\n```\n\n- 匹配最后一个斜杠后的，最后一个点前的内容\n```\nvar s = 'http://i2.xxx.com/wx/images_2016/monkey/m4_1e3thtr.png';\n\n//要匹配目标内容，可以从后往回推，首先是后缀名(.*表示)，后缀名前跟着一个'.'(\\.表示)，'.'前则是目标内容，用括号捕获，目标内容前为斜杠(\\/表示)，斜杠前为任意内容，正则表达式如下：\nvar r =/.*\\/(.*)\\..*/;\nvar m = s.match(r);\nconsole.log(str.match(patt));\n=> [\"http://i2.xxx.com/wx/images_2016/monkey/m4_1e3thtr.png\",\"m4_1e3thtr\"]\n```\n\n- 验证字符串组成，第一个为数字，后面可以是字母、数字、下划线组成的1到50位的字符。\n  \n`str.match(/\\d\\w{1,50}$/)`\n\n- js将一浮点数小数点左边的数字每三位加一个逗号\n  \n```\n//当一个字符串中某个数字后跟着n对三个数字(\\d{3})就匹配这个数字\nconst formateNum = (num) => {\n  const numStr = num.toString();\n  //替换小数点左边的数字\n  return numStr.replace(/\\d+/, (match) => {\n    //替换目标数字为`${matchNum},`\n    return match.replace(/(\\d)(?=(\\d{3}+$))/, (s1) => `${s1},`);\n  })\n}\n\nformateNum(435345.656)\n=> \"435,345.656\"\n```\n\n\n","slug":"正则表达式","published":1,"updated":"2019-01-02T06:54:00.153Z","_id":"cjq5aqcsl000gdsztcchpk0dp","comments":1,"photos":[],"link":"","content":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a><strong>基本概念</strong></h3><ul>\n<li><p><strong>正则表达式</strong><br>它描述了一种字符串匹配的模式，即\b要寻找符合这一模式(某种规则)的子串，找到后进行提取或替换。</p>\n</li>\n<li><p><strong>元字符</strong><br>在正则表达式中具有特殊含义的字符，如<code>+</code>号，代表前面的字符必须至少出现一次（1次或多次），runoo+b，可以匹配 runoob、runooob、runoooooob等。<br><code>*</code> 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）<br>runoo*b，可以匹配 runob、runoob、runoooooob 等。<br>如果要匹配字符串中的特殊符号，则需要对其进行转义，即在其前加一个<code>\\</code>，如<code>runo\\+ob</code> 匹配 <code>runo+ob</code>。<br>以下是正则中的特殊字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( ) [ ] &#123; &#125; \\ ^ $ | ? * + .</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>子模式</strong><br>在正则表达式中，可以使用括号()将模式中的子字符串括起来，以形成一个子模式。将子模式视为一个整体时，那么它就相当于一个单个字符。</p>\n</li>\n</ul>\n<h3 id=\"正则表达式形式\"><a href=\"#正则表达式形式\" class=\"headerlink\" title=\"正则表达式形式\"></a><strong>正则表达式形式</strong></h3><p>正则表达式是包含在两个斜杠之间的一个或多个字符，在后一个斜杠的后面，可以指定一个或多个选项。正则表达式也可以通过对象RegExp的构造函数来生成，带有变量的字符串通过RegExp能够比较简单生成正则表达式，而采用‘/pattern/’的方式变量会识别成字面量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var regExp = /pattern/flags</span><br><span class=\"line\">或 var regExpStr = new RegExp(regStr, pattern)</span><br></pre></td></tr></table></figure></p>\n<p>其中，“pattern”为指定的匹配模式，flags为0个或多个可选项，这些选项及其含义如下：</p>\n<p>i：表示忽略大小写，就是在字符串匹配的时候不区分大小写。<br>g：表示全局匹配，即匹配字符串中出现的所有模式。<br>m：表示进行多行匹配。</p>\n<h3 id=\"JS中字符串匹配和替换\"><a href=\"#JS中字符串匹配和替换\" class=\"headerlink\" title=\"JS中字符串匹配和替换\"></a><strong>JS中字符串匹配和替换</strong></h3><ul>\n<li><p>字符串匹配<br>语法：str.match(regExp)<br>参数：regExp为一个正则表达式<br>返回值：如果字符串匹配到了表达式则返回一个数组，数组的第一个元素为匹配到的内容，之后的项是小括号<br>捕获的内容，如果没有匹配到则返回null。<br>例：匹配数字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;you know that I am 17 years old&quot;;</span><br><span class=\"line\">//\\d表示数字+号表示出现多次，即可匹配数字17</span><br><span class=\"line\">var patt = /I am (\\d+)/;</span><br><span class=\"line\"></span><br><span class=\"line\">str.match(patt)</span><br><span class=\"line\">//17为小括号捕获的内容，index为匹配的位置(字符I的位置)</span><br><span class=\"line\">=&gt;  [&quot;I am 17&quot;, &quot;17&quot;, index: 0, input: &quot;I am 17 years old&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串替换<br>语法：str.replace(regexp|str, newSubstr|func)<br>参数：第一个参数为一个正则表达式或子串，第二个参数为要替换的内容或一个返回替换内容的函数<br>例：匹配数字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function replacer(match, s1, s2, offset, string) &#123;</span><br><span class=\"line\">  //match为匹配的结果, s1(67),s2(123)为小括号匹配到的内容,offset为匹配到的位置(1，即a67bc123中6的位置)</span><br><span class=\"line\">  return [s1, s2].join(&apos; - &apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newString = &apos;a67bc123&apos;.replace(/a(\\d+)bc(\\d+)/, replacer);</span><br><span class=\"line\">或var newString = &apos;a67bc123&apos;.replace(/a(\\d+)bc(\\d+)/, `$1 - $2`);</span><br><span class=\"line\">=&gt; newString: &quot;67 - 123&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"特殊字符用法\"><a href=\"#特殊字符用法\" class=\"headerlink\" title=\"特殊字符用法\"></a><strong>特殊字符用法</strong></h3><ul>\n<li><p><code>\\</code> 标记其后的字符为特殊字符、转义字符</p>\n<p>如<code>\\r</code>代表回车符，<code>\\b</code>表示一个字符边界，反斜杠<code>\\</code>也可以将其后的特殊字符转义为字面量，例如模式<code>/a*/</code>代表会匹配0个或者多个a。相反，模式<code>/a\\*/</code>将<code>*</code>的特殊性移除，从而可以匹配像<code>a*</code>这样的字符串。<code>\\\\</code>表示一个<code>\\</code>,第一个<code>\\</code>为转义字符，第二个<code>\\</code>为特殊字符<code>\\</code>。</p>\n</li>\n<li><p><code>^</code> 匹配输入的开始位置<br>如果多行标志为true时也匹配换行符后紧跟的位置。</p>\n<p>匹配以snow开头的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如下/^snow/匹配snow is my name但不匹配my name is snow</span><br><span class=\"line\">var str = &quot;snow is my name&quot;;</span><br><span class=\"line\">var patt = /^snow/;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>$</code> 匹配输入结束的位置<br>匹配输入的结束。如果多行标示为true时也匹配换行符前的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如下/snow$/匹配my name is snow但不匹配snow is my name</span><br><span class=\"line\">var str = &quot;my name is snow&quot;;</span><br><span class=\"line\">var patt = /snow$/;</span><br></pre></td></tr></table></figure>\n<p>匹配snow这个字符串, 如下^$结合可以匹配snow(snow为开始和结束即仅匹配snow，不匹配snow is snow)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;snow&quot;;</span><br><span class=\"line\">var patt = /^snow$/;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>|</code> 类似或，指明两项之间的一个选择</p>\n<p>匹配苹果或香蕉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;banana&quot;;</span><br><span class=\"line\">var patt = /apple|banana/;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>{n}</code> 匹配前一项连续出现n次<br>如，/p{2}/不会匹配aple中的p,但会匹配apple中所有的p。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;apple is a apple&quot;;</span><br><span class=\"line\">var patt = /(apple)&#123;2&#125;/;</span><br><span class=\"line\">console.log(str.match(patt)); =&gt; null</span><br><span class=\"line\"></span><br><span class=\"line\">var str = &quot;appleapple 2 apple&quot;;</span><br><span class=\"line\">var patt = /(apple)&#123;2&#125;/;</span><br><span class=\"line\">console.log(str.match(patt)); =&gt; appleapple</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>{m,n}</code> 匹配前一项连续出现m到n次，包括m、n次</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;apple is a apple&quot;;</span><br><span class=\"line\">var patt = /(apple)&#123;2,3&#125;/;</span><br><span class=\"line\">console.log(str.match(patt)); =&gt; null</span><br><span class=\"line\"></span><br><span class=\"line\">var str = &quot;appleapple 2 apple&quot;;</span><br><span class=\"line\">var patt = /(apple)&#123;2,3&#125;/;</span><br><span class=\"line\">console.log(str.match(patt)); =&gt; appleapple</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>.</code> 默认情况下, 句点匹配除新行符(换行符<code>\\n</code>和回车符<code>\\r</code>)外的任何单个字符</p>\n<p>匹配snow_，如下/snow./可以匹配snow1，snowa，snow_等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;snow_&quot;;</span><br><span class=\"line\">var patt = /snow./;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>*</code> 匹配零个或多个前一项,等价于 {0,}。</p>\n<p>匹配a，如下a*可以匹配aabc，aaaabc，甚至不包含 “a” 的任意字符串.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;aaaabaac&quot;;</span><br><span class=\"line\">var patt = /ba*/;</span><br><span class=\"line\">console.log(str.match(patt)) =&gt; baa</span><br></pre></td></tr></table></figure>\n<p>通配符: 句点星号模式 .<em> 可以匹配零个或多个任意字符 (除了新行符: <code>\\r</code> 和 <code>\\n</code>). 例如, snow.</em>123 可以匹配 snowAnything123, 也能匹配 snow123.</p>\n</li>\n<li><p><code>+</code> 匹配前一项一个或多个,等价于 {1,}。<br>例如，/p+/匹配了在 “apppppple” 中的 ‘p’。</p>\n</li>\n<li><p><code>?</code> 匹配零个或一个前面的字符，可以理解为”前面的那项是可选的”. 例如, colou?r 可以匹配color和colour, 因为 “u” 是可选的, abcd(efg)?hij可以匹配abcdhij和abcdefghij。</p>\n</li>\n</ul>\n<ul>\n<li><p><code>()</code> 标记一个子表达式(分组)的开始和结束位置<br>每一个子表达式会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推<br>子表达式的结果可以获取供以后使用, 如下子表达式的值为phone</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;apple is a iphone&quot;;</span><br><span class=\"line\">var patt = /i(phone$)/;</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt; [ &apos;iphone&apos;, &apos;phone&apos;, index: 11, input: &apos;apple is a iphone&apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">var str = &quot;there is a iphonePlus called iphonePlus&quot;;</span><br><span class=\"line\">var patt = /(iphone)(Plus).*\\1\\2$/; //\\1、\\2表示子表达式1、2的结果，即iphone、Plus</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt; [ &apos;iphonePlus called iphonePlus&apos;,</span><br><span class=\"line\">     &apos;iphone&apos;,</span><br><span class=\"line\">     &apos;Plus&apos;,</span><br><span class=\"line\">     index: 11,</span><br><span class=\"line\">     input: &apos;there is a iphonePlus called iphonePlus&apos; ]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>(x)</code> 匹配’x’并且记住匹配项，括号被称为捕获括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;there is a iphone called iphone&quot;;</span><br><span class=\"line\">var patt = /(iphone).*\\1$/; //因为记住了匹配项，所有\\1能够拿到子表达式1的结果iphone</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt;[ &apos;iphone called iphone&apos;,</span><br><span class=\"line\">&apos;iphone&apos;,</span><br><span class=\"line\">index: 11,</span><br><span class=\"line\">input: &apos;there is a iphone called iphone&apos; ]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>(?:x)</code> 匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;there is a iphone called iphone&quot;;</span><br><span class=\"line\">var patt = /(?:iphone).*\\1$/; //因为没有记住匹配项，所有\\1不能拿到子表达式1的结果，匹配为null</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt;null</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>x(?=y)</code> 匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;iphoneX and iphonePlus&quot;;</span><br><span class=\"line\">var patt = /iphone(?=Plus)/; //匹配iphonePlus的iphone</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt;[ &apos;iphone&apos;, index: 12, input: &apos;iphoneX and iphonePlus&apos; ]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>x(?!y)</code> 匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;iphoneX and iphonePlus&quot;;</span><br><span class=\"line\">var patt = /iphone(?!Plus)/;//匹配iphoneX的iphone</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt; [ &apos;iphone&apos;, index: 0, input: &apos;iphoneX and iphonePlus&apos; ]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>[xyz]</code><br>字符类：元字符<code>[</code>和<code>]</code>指定正则表达式中的字符类。<br>字符类“[123]”将匹配字符1，2或3.例如，字符串“man”或“men”将匹配正则表达式“m[ae]n”。<br>可以使用连字符-来指定字符范围，如[A-Z]表示所有大写任何字母;[0-9]表示0和9之间的任何数字。[a-ex-z]    字符a到d或x到z，其将包括a，b，c，d, x，y或z。</p>\n</li>\n<li><p><code>[^xyz]</code><br>一个反向字符集。^表示除也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。<br>[^abc]，[^a-c]     除a，b和c以外的字符</p>\n</li>\n<li><p><code>[\\b]</code> 匹配一个退格(U+0008)。（不要和\\b混淆了）</p>\n</li>\n<li><p><code>\\b</code> 匹配一个单词的边界，一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置<br>例子：<br>/\\bm/匹配“moon”中得‘m’；<br>/oo\\b/并不匹配”moon”中得’oo’，因为’oo’被一个“字”字符’n’紧跟着。<br>/oon\\b/匹配”moon”中得’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”符紧跟着。</p>\n</li>\n<li><p><code>\\B</code> 匹配一个非单词边界<br>例如，/\\Bday/匹配”noonday”中的’oon’, 而/y\\B./匹配”possibly yesterday”中的’y‘</p>\n</li>\n<li><p><code>\\d</code><br>匹配一个数字。<br>等价于[0-9]。<br>例如， /\\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。</p>\n</li>\n<li><p><code>\\D</code><br>匹配一个非数字字符。<br>等价于[^0-9]。<br>例如， /\\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。</p>\n</li>\n<li><p><code>\\f</code>    匹配一个换页符 (U+000C)。</p>\n</li>\n<li><code>\\n</code>    匹配一个换行符 (U+000A)或捕获的子串。<br>在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。<br>比如 /apple(,)\\sorange\\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</li>\n<li><code>\\r</code>    匹配一个回车符 (U+000D)。</li>\n<li><p><code>\\s</code><br>匹配一个空白字符，包括空格、制表符、换页符和换行符。<br>等价于[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。<br>例如, /\\s\\w*/ 匹配”foo bar.”中的’ bar’。</p>\n</li>\n<li><p><code>\\S</code><br>匹配一个非空白字符。<br>等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。<br>例如， /\\S\\w*/ 匹配”foo bar.”中的’foo’。</p>\n</li>\n<li><p><code>\\t</code>    匹配一个水平制表符 (U+0009)。</p>\n</li>\n<li><code>\\v</code>    匹配一个垂直制表符 (U+000B)。</li>\n<li><p><code>\\w</code><br>匹配一个单字字符（字母、数字或者下划线）。<br>等价于[A-Za-z0-9_]。<br>例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p>\n</li>\n<li><p><code>\\W</code><br>匹配一个非单字字符。<br>等价于[^A-Za-z0-9_]。<br>例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</p>\n</li>\n<li><p><code>\\0</code>    匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \\0<digits> 是一个八进制转义序列。</digits></p>\n</li>\n<li><code>\\xhh</code>    与代码 hh 匹配字符（两个十六进制数字）</li>\n<li><p><code>\\uhhhh</code>    与代码 hhhh 匹配字符（四个十六进制数字）。</p>\n</li>\n<li><p><code>?#comment</code>注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var patt = /\\/(?#匹配斜杠/)/;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a><strong>实例</strong></h3><ul>\n<li><p>匹配斜杠/</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;/public/image/a.png&quot;;</span><br><span class=\"line\">var patt = /\\//;</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt;[&quot;/&quot;, index: 0, input: &quot;/public/image/a.png&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>匹配最后一个斜杠后的，最后一个点前的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = &apos;http://i2.xxx.com/wx/images_2016/monkey/m4_1e3thtr.png&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//要匹配目标内容，可以从后往回推，首先是后缀名(.*表示)，后缀名前跟着一个&apos;.&apos;(\\.表示)，&apos;.&apos;前则是目标内容，用括号捕获，目标内容前为斜杠(\\/表示)，斜杠前为任意内容，正则表达式如下：</span><br><span class=\"line\">var r =/.*\\/(.*)\\..*/;</span><br><span class=\"line\">var m = s.match(r);</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt; [&quot;http://i2.xxx.com/wx/images_2016/monkey/m4_1e3thtr.png&quot;,&quot;m4_1e3thtr&quot;]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>验证字符串组成，第一个为数字，后面可以是字母、数字、下划线组成的1到50位的字符。</p>\n</li>\n</ul>\n<p><code>str.match(/\\d\\w{1,50}$/)</code></p>\n<ul>\n<li>js将一浮点数小数点左边的数字每三位加一个逗号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//当一个字符串中某个数字后跟着n对三个数字(\\d&#123;3&#125;)就匹配这个数字</span><br><span class=\"line\">const formateNum = (num) =&gt; &#123;</span><br><span class=\"line\">  const numStr = num.toString();</span><br><span class=\"line\">  //替换小数点左边的数字</span><br><span class=\"line\">  return numStr.replace(/\\d+/, (match) =&gt; &#123;</span><br><span class=\"line\">    //替换目标数字为`$&#123;matchNum&#125;,`</span><br><span class=\"line\">    return match.replace(/(\\d)(?=(\\d&#123;3&#125;+$))/, (s1) =&gt; `$&#123;s1&#125;,`);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">formateNum(435345.656)</span><br><span class=\"line\">=&gt; &quot;435,345.656&quot;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a><strong>基本概念</strong></h3><ul>\n<li><p><strong>正则表达式</strong><br>它描述了一种字符串匹配的模式，即\b要寻找符合这一模式(某种规则)的子串，找到后进行提取或替换。</p>\n</li>\n<li><p><strong>元字符</strong><br>在正则表达式中具有特殊含义的字符，如<code>+</code>号，代表前面的字符必须至少出现一次（1次或多次），runoo+b，可以匹配 runoob、runooob、runoooooob等。<br><code>*</code> 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）<br>runoo*b，可以匹配 runob、runoob、runoooooob 等。<br>如果要匹配字符串中的特殊符号，则需要对其进行转义，即在其前加一个<code>\\</code>，如<code>runo\\+ob</code> 匹配 <code>runo+ob</code>。<br>以下是正则中的特殊字符：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">( ) [ ] &#123; &#125; \\ ^ $ | ? * + .</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>子模式</strong><br>在正则表达式中，可以使用括号()将模式中的子字符串括起来，以形成一个子模式。将子模式视为一个整体时，那么它就相当于一个单个字符。</p>\n</li>\n</ul>\n<h3 id=\"正则表达式形式\"><a href=\"#正则表达式形式\" class=\"headerlink\" title=\"正则表达式形式\"></a><strong>正则表达式形式</strong></h3><p>正则表达式是包含在两个斜杠之间的一个或多个字符，在后一个斜杠的后面，可以指定一个或多个选项。正则表达式也可以通过对象RegExp的构造函数来生成，带有变量的字符串通过RegExp能够比较简单生成正则表达式，而采用‘/pattern/’的方式变量会识别成字面量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var regExp = /pattern/flags</span><br><span class=\"line\">或 var regExpStr = new RegExp(regStr, pattern)</span><br></pre></td></tr></table></figure></p>\n<p>其中，“pattern”为指定的匹配模式，flags为0个或多个可选项，这些选项及其含义如下：</p>\n<p>i：表示忽略大小写，就是在字符串匹配的时候不区分大小写。<br>g：表示全局匹配，即匹配字符串中出现的所有模式。<br>m：表示进行多行匹配。</p>\n<h3 id=\"JS中字符串匹配和替换\"><a href=\"#JS中字符串匹配和替换\" class=\"headerlink\" title=\"JS中字符串匹配和替换\"></a><strong>JS中字符串匹配和替换</strong></h3><ul>\n<li><p>字符串匹配<br>语法：str.match(regExp)<br>参数：regExp为一个正则表达式<br>返回值：如果字符串匹配到了表达式则返回一个数组，数组的第一个元素为匹配到的内容，之后的项是小括号<br>捕获的内容，如果没有匹配到则返回null。<br>例：匹配数字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;you know that I am 17 years old&quot;;</span><br><span class=\"line\">//\\d表示数字+号表示出现多次，即可匹配数字17</span><br><span class=\"line\">var patt = /I am (\\d+)/;</span><br><span class=\"line\"></span><br><span class=\"line\">str.match(patt)</span><br><span class=\"line\">//17为小括号捕获的内容，index为匹配的位置(字符I的位置)</span><br><span class=\"line\">=&gt;  [&quot;I am 17&quot;, &quot;17&quot;, index: 0, input: &quot;I am 17 years old&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>字符串替换<br>语法：str.replace(regexp|str, newSubstr|func)<br>参数：第一个参数为一个正则表达式或子串，第二个参数为要替换的内容或一个返回替换内容的函数<br>例：匹配数字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function replacer(match, s1, s2, offset, string) &#123;</span><br><span class=\"line\">  //match为匹配的结果, s1(67),s2(123)为小括号匹配到的内容,offset为匹配到的位置(1，即a67bc123中6的位置)</span><br><span class=\"line\">  return [s1, s2].join(&apos; - &apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var newString = &apos;a67bc123&apos;.replace(/a(\\d+)bc(\\d+)/, replacer);</span><br><span class=\"line\">或var newString = &apos;a67bc123&apos;.replace(/a(\\d+)bc(\\d+)/, `$1 - $2`);</span><br><span class=\"line\">=&gt; newString: &quot;67 - 123&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"特殊字符用法\"><a href=\"#特殊字符用法\" class=\"headerlink\" title=\"特殊字符用法\"></a><strong>特殊字符用法</strong></h3><ul>\n<li><p><code>\\</code> 标记其后的字符为特殊字符、转义字符</p>\n<p>如<code>\\r</code>代表回车符，<code>\\b</code>表示一个字符边界，反斜杠<code>\\</code>也可以将其后的特殊字符转义为字面量，例如模式<code>/a*/</code>代表会匹配0个或者多个a。相反，模式<code>/a\\*/</code>将<code>*</code>的特殊性移除，从而可以匹配像<code>a*</code>这样的字符串。<code>\\\\</code>表示一个<code>\\</code>,第一个<code>\\</code>为转义字符，第二个<code>\\</code>为特殊字符<code>\\</code>。</p>\n</li>\n<li><p><code>^</code> 匹配输入的开始位置<br>如果多行标志为true时也匹配换行符后紧跟的位置。</p>\n<p>匹配以snow开头的字符串</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如下/^snow/匹配snow is my name但不匹配my name is snow</span><br><span class=\"line\">var str = &quot;snow is my name&quot;;</span><br><span class=\"line\">var patt = /^snow/;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>$</code> 匹配输入结束的位置<br>匹配输入的结束。如果多行标示为true时也匹配换行符前的位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//如下/snow$/匹配my name is snow但不匹配snow is my name</span><br><span class=\"line\">var str = &quot;my name is snow&quot;;</span><br><span class=\"line\">var patt = /snow$/;</span><br></pre></td></tr></table></figure>\n<p>匹配snow这个字符串, 如下^$结合可以匹配snow(snow为开始和结束即仅匹配snow，不匹配snow is snow)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;snow&quot;;</span><br><span class=\"line\">var patt = /^snow$/;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>|</code> 类似或，指明两项之间的一个选择</p>\n<p>匹配苹果或香蕉</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;banana&quot;;</span><br><span class=\"line\">var patt = /apple|banana/;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>{n}</code> 匹配前一项连续出现n次<br>如，/p{2}/不会匹配aple中的p,但会匹配apple中所有的p。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;apple is a apple&quot;;</span><br><span class=\"line\">var patt = /(apple)&#123;2&#125;/;</span><br><span class=\"line\">console.log(str.match(patt)); =&gt; null</span><br><span class=\"line\"></span><br><span class=\"line\">var str = &quot;appleapple 2 apple&quot;;</span><br><span class=\"line\">var patt = /(apple)&#123;2&#125;/;</span><br><span class=\"line\">console.log(str.match(patt)); =&gt; appleapple</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>{m,n}</code> 匹配前一项连续出现m到n次，包括m、n次</p>\n  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;apple is a apple&quot;;</span><br><span class=\"line\">var patt = /(apple)&#123;2,3&#125;/;</span><br><span class=\"line\">console.log(str.match(patt)); =&gt; null</span><br><span class=\"line\"></span><br><span class=\"line\">var str = &quot;appleapple 2 apple&quot;;</span><br><span class=\"line\">var patt = /(apple)&#123;2,3&#125;/;</span><br><span class=\"line\">console.log(str.match(patt)); =&gt; appleapple</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>.</code> 默认情况下, 句点匹配除新行符(换行符<code>\\n</code>和回车符<code>\\r</code>)外的任何单个字符</p>\n<p>匹配snow_，如下/snow./可以匹配snow1，snowa，snow_等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;snow_&quot;;</span><br><span class=\"line\">var patt = /snow./;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>*</code> 匹配零个或多个前一项,等价于 {0,}。</p>\n<p>匹配a，如下a*可以匹配aabc，aaaabc，甚至不包含 “a” 的任意字符串.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;aaaabaac&quot;;</span><br><span class=\"line\">var patt = /ba*/;</span><br><span class=\"line\">console.log(str.match(patt)) =&gt; baa</span><br></pre></td></tr></table></figure>\n<p>通配符: 句点星号模式 .<em> 可以匹配零个或多个任意字符 (除了新行符: <code>\\r</code> 和 <code>\\n</code>). 例如, snow.</em>123 可以匹配 snowAnything123, 也能匹配 snow123.</p>\n</li>\n<li><p><code>+</code> 匹配前一项一个或多个,等价于 {1,}。<br>例如，/p+/匹配了在 “apppppple” 中的 ‘p’。</p>\n</li>\n<li><p><code>?</code> 匹配零个或一个前面的字符，可以理解为”前面的那项是可选的”. 例如, colou?r 可以匹配color和colour, 因为 “u” 是可选的, abcd(efg)?hij可以匹配abcdhij和abcdefghij。</p>\n</li>\n</ul>\n<ul>\n<li><p><code>()</code> 标记一个子表达式(分组)的开始和结束位置<br>每一个子表达式会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推<br>子表达式的结果可以获取供以后使用, 如下子表达式的值为phone</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;apple is a iphone&quot;;</span><br><span class=\"line\">var patt = /i(phone$)/;</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt; [ &apos;iphone&apos;, &apos;phone&apos;, index: 11, input: &apos;apple is a iphone&apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\">var str = &quot;there is a iphonePlus called iphonePlus&quot;;</span><br><span class=\"line\">var patt = /(iphone)(Plus).*\\1\\2$/; //\\1、\\2表示子表达式1、2的结果，即iphone、Plus</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt; [ &apos;iphonePlus called iphonePlus&apos;,</span><br><span class=\"line\">     &apos;iphone&apos;,</span><br><span class=\"line\">     &apos;Plus&apos;,</span><br><span class=\"line\">     index: 11,</span><br><span class=\"line\">     input: &apos;there is a iphonePlus called iphonePlus&apos; ]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>(x)</code> 匹配’x’并且记住匹配项，括号被称为捕获括号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;there is a iphone called iphone&quot;;</span><br><span class=\"line\">var patt = /(iphone).*\\1$/; //因为记住了匹配项，所有\\1能够拿到子表达式1的结果iphone</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt;[ &apos;iphone called iphone&apos;,</span><br><span class=\"line\">&apos;iphone&apos;,</span><br><span class=\"line\">index: 11,</span><br><span class=\"line\">input: &apos;there is a iphone called iphone&apos; ]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>(?:x)</code> 匹配 ‘x’ 但是不记住匹配项。这种叫作非捕获括号</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;there is a iphone called iphone&quot;;</span><br><span class=\"line\">var patt = /(?:iphone).*\\1$/; //因为没有记住匹配项，所有\\1不能拿到子表达式1的结果，匹配为null</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt;null</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>x(?=y)</code> 匹配’x’仅仅当’x’后面跟着’y’.这种叫做正向肯定查找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;iphoneX and iphonePlus&quot;;</span><br><span class=\"line\">var patt = /iphone(?=Plus)/; //匹配iphonePlus的iphone</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt;[ &apos;iphone&apos;, index: 12, input: &apos;iphoneX and iphonePlus&apos; ]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>x(?!y)</code> 匹配’x’仅仅当’x’后面不跟着’y’,这个叫做正向否定查找。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;iphoneX and iphonePlus&quot;;</span><br><span class=\"line\">var patt = /iphone(?!Plus)/;//匹配iphoneX的iphone</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt; [ &apos;iphone&apos;, index: 0, input: &apos;iphoneX and iphonePlus&apos; ]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>[xyz]</code><br>字符类：元字符<code>[</code>和<code>]</code>指定正则表达式中的字符类。<br>字符类“[123]”将匹配字符1，2或3.例如，字符串“man”或“men”将匹配正则表达式“m[ae]n”。<br>可以使用连字符-来指定字符范围，如[A-Z]表示所有大写任何字母;[0-9]表示0和9之间的任何数字。[a-ex-z]    字符a到d或x到z，其将包括a，b，c，d, x，y或z。</p>\n</li>\n<li><p><code>[^xyz]</code><br>一个反向字符集。^表示除也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。<br>[^abc]，[^a-c]     除a，b和c以外的字符</p>\n</li>\n<li><p><code>[\\b]</code> 匹配一个退格(U+0008)。（不要和\\b混淆了）</p>\n</li>\n<li><p><code>\\b</code> 匹配一个单词的边界，一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置<br>例子：<br>/\\bm/匹配“moon”中得‘m’；<br>/oo\\b/并不匹配”moon”中得’oo’，因为’oo’被一个“字”字符’n’紧跟着。<br>/oon\\b/匹配”moon”中得’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”符紧跟着。</p>\n</li>\n<li><p><code>\\B</code> 匹配一个非单词边界<br>例如，/\\Bday/匹配”noonday”中的’oon’, 而/y\\B./匹配”possibly yesterday”中的’y‘</p>\n</li>\n<li><p><code>\\d</code><br>匹配一个数字。<br>等价于[0-9]。<br>例如， /\\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。</p>\n</li>\n<li><p><code>\\D</code><br>匹配一个非数字字符。<br>等价于[^0-9]。<br>例如， /\\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。</p>\n</li>\n<li><p><code>\\f</code>    匹配一个换页符 (U+000C)。</p>\n</li>\n<li><code>\\n</code>    匹配一个换行符 (U+000A)或捕获的子串。<br>在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。<br>比如 /apple(,)\\sorange\\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</li>\n<li><code>\\r</code>    匹配一个回车符 (U+000D)。</li>\n<li><p><code>\\s</code><br>匹配一个空白字符，包括空格、制表符、换页符和换行符。<br>等价于[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。<br>例如, /\\s\\w*/ 匹配”foo bar.”中的’ bar’。</p>\n</li>\n<li><p><code>\\S</code><br>匹配一个非空白字符。<br>等价于[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]。<br>例如， /\\S\\w*/ 匹配”foo bar.”中的’foo’。</p>\n</li>\n<li><p><code>\\t</code>    匹配一个水平制表符 (U+0009)。</p>\n</li>\n<li><code>\\v</code>    匹配一个垂直制表符 (U+000B)。</li>\n<li><p><code>\\w</code><br>匹配一个单字字符（字母、数字或者下划线）。<br>等价于[A-Za-z0-9_]。<br>例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p>\n</li>\n<li><p><code>\\W</code><br>匹配一个非单字字符。<br>等价于[^A-Za-z0-9_]。<br>例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。</p>\n</li>\n<li><p><code>\\0</code>    匹配 NULL (U+0000) 字符， 不要在这后面跟其它小数，因为 \\0<digits> 是一个八进制转义序列。</digits></p>\n</li>\n<li><code>\\xhh</code>    与代码 hh 匹配字符（两个十六进制数字）</li>\n<li><p><code>\\uhhhh</code>    与代码 hhhh 匹配字符（四个十六进制数字）。</p>\n</li>\n<li><p><code>?#comment</code>注释</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var patt = /\\/(?#匹配斜杠/)/;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a><strong>实例</strong></h3><ul>\n<li><p>匹配斜杠/</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var str = &quot;/public/image/a.png&quot;;</span><br><span class=\"line\">var patt = /\\//;</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt;[&quot;/&quot;, index: 0, input: &quot;/public/image/a.png&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>匹配最后一个斜杠后的，最后一个点前的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var s = &apos;http://i2.xxx.com/wx/images_2016/monkey/m4_1e3thtr.png&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//要匹配目标内容，可以从后往回推，首先是后缀名(.*表示)，后缀名前跟着一个&apos;.&apos;(\\.表示)，&apos;.&apos;前则是目标内容，用括号捕获，目标内容前为斜杠(\\/表示)，斜杠前为任意内容，正则表达式如下：</span><br><span class=\"line\">var r =/.*\\/(.*)\\..*/;</span><br><span class=\"line\">var m = s.match(r);</span><br><span class=\"line\">console.log(str.match(patt));</span><br><span class=\"line\">=&gt; [&quot;http://i2.xxx.com/wx/images_2016/monkey/m4_1e3thtr.png&quot;,&quot;m4_1e3thtr&quot;]</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>验证字符串组成，第一个为数字，后面可以是字母、数字、下划线组成的1到50位的字符。</p>\n</li>\n</ul>\n<p><code>str.match(/\\d\\w{1,50}$/)</code></p>\n<ul>\n<li>js将一浮点数小数点左边的数字每三位加一个逗号</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//当一个字符串中某个数字后跟着n对三个数字(\\d&#123;3&#125;)就匹配这个数字</span><br><span class=\"line\">const formateNum = (num) =&gt; &#123;</span><br><span class=\"line\">  const numStr = num.toString();</span><br><span class=\"line\">  //替换小数点左边的数字</span><br><span class=\"line\">  return numStr.replace(/\\d+/, (match) =&gt; &#123;</span><br><span class=\"line\">    //替换目标数字为`$&#123;matchNum&#125;,`</span><br><span class=\"line\">    return match.replace(/(\\d)(?=(\\d&#123;3&#125;+$))/, (s1) =&gt; `$&#123;s1&#125;,`);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">formateNum(435345.656)</span><br><span class=\"line\">=&gt; &quot;435,345.656&quot;</span><br></pre></td></tr></table></figure>\n"},{"layout":"post","title":"每日一题","tagline":"Supporting tagline","description":"前端题集","date":"2017-01-04T13:36:05.000Z","_content":"\n**1、** `<img>`的title和alt有什么区别\n\n- title是鼠标移动到元素显示的值\n- alt是`<img>`特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。\n\n**2、** 从浏览器地址栏输入url到显示页面的步骤\n\n- 浏览器根据请求的url，交给DNS解析域名找到真实的Ip，向服务器请求数据。\n- 服务器处理完成返回数据，浏览器接收数据(Html、js、css、image等)\n- 浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom等)\n- 载入解析到的资源文件，渲染页面、完成。\n\n\n**3、**js遍历li的内容\n```\n<ul>\n  <li>1</li>\n  <li>2</li>\n</ul>\n```\n=>\n```\n  const u = document.querySelector('ul');\n  const lis = u.children;\n  for(let i = 0; i < lis.length; i++) {\n    const li = lis[i];\n    console.log(li.innerText);\n  }\n  或\n  const realArr = [].slice.call(lis);\n  realArr.forEach((li) => {\n    console.log(li.innerText)\n  })\n\n```\n**4、** JavaScript`===`和`==`的区别\n`===`即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换\n`==`即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如相等则相等。\n需要指出的是NaN不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0等于(==或===)-0(对于0而言没有正负之分)。\n\n\n**5、** JavaScript中null和undefined的区别\n由于历史原因JavaScript中有null和undefined两个表示无的值，其区别很小，主要在于：\n- null的类型为Object，undefined的类型为undefined\n- Number(null)为0，Number(undefined)为NaN\n- null表示没有对象，此处不该有值，undefined表示此处应该有值暂时缺少这个值\n\n**6、** 常见http code及其含义\n- 信息响应(1xx)\n  表示服务器收到请求，需要请求者继续执行操作\n  - 100 Continue: 客户端应继续其请求。\n- 成功(2xx)\n  表示服务器成功接收请求并处理返回\n  - 200 Ok: 请求正常处理完毕。一般用于GET与POST请求\n  - 202 Accepted: 服务器已经接受到消息，当时尚未处理\n  - 204 No Content: 服务器成功处理了请求但未返回任何内容\n  - 206 Partial Content: 服务器成功处理了部分get请求\n- 重定向(3xx)\n  表示需要客户端进一步操作才能完成请求\n  - 301 Moved Permanently: 永久重定向，请求的资源已永久移动到新URI\n  - 302 Found: 临时重定向，资源临时移动到新的位置\n  - 304 Not Modified: 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。\n  - 307 Temporary Redirect: 临时重定向，不允许更改请求方法\n- 客户端错误(4xx)\n  表示客户端可能发生了错误\n  - 400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解\n  - 401 Unauthorized: 要求身份验证\n  - 403 Forbidden: 服务器理解请求但拒绝执行\n  - 404 Not Found: 服务器没有找到资源\n- 服务器错误(5xx)\n  表示服务器无法完成请求\n  - 500 Internal Server Error: 服务器遇到未知问题，无法处理请求\n  - 503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求\n\n\n**7、**  **Coo**kie, SessionStorage与LocalStorage区别\n\n[demo](https://github.com/fengyueran/web-cache-demo.git)\n- 储存大小\n  - Cookie: 4kb左右\n  - SessionStorage: 一般为5M\n  - LocalStorage: 一般为5M\n- 生命周期\n  - Cookie: 默认是关闭浏览器后失效，可以设置失效时间\n  - SessionStorage: 仅在当前会话有效，关闭tab页即失效\n  - LocalStorage: 持久缓存除非主动清除(通过浏览器或JS)\n- 与服务器通信\n  - 每次请求都会携带在http请求头中，可能带来性能问题\n  - SessionStorage: 只在客户端起作用\n  - LocalStorage: 只在客户端起作用\n\n**8、**  html代码中让链接在新窗口中打开的写法\n\n通过设置a标签的target属性为_blank可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过window.openner访问原页面的窗口对象，并且可以通过window.opener.location = newURL将原页面导航至不同的网址。因此需要通过ref=\"noopenner\"来禁用window.opener。\n```\n  <div>\n    <div>\n      <a href=\"http://www.xinghunm.com\">Welcome -  old window</a>\n    </div>\n    <div>\n        <a href=\"http://www.xinghunm.com\" target=\"_blank\" ref=\"noopenner\">Welcome -  new window</a>\n    </div>\n  </div>\n```\n\n**9、**  html5有哪些新特性，移除的元素有哪些\n新增:\n  - WebSocket\n  - 用于绘画的canvas元素\n  - 用于媒介回放的vedio和audio元素\n  - 新增sessionStorage和localStorage对离线缓存更好的支持\n  - 新的特殊内容元素，如article、header、footer、nav、section\n  - 新的表单控件，如calendar、date、time、email、url、search\n移除:\n  - basefont\n  - big\n  - center\n  - dir\n  - font\n  - frame\n  - frameset\n  - noframes\n  - strike\n  - tt\n\n**10、**  谈谈对盒模型的理解\n\n  浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为W3C标准盒模型和IE盒模型，W3C标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而IE盒模型的大小只由内容区域的大小(自定义的width和height)决定。css可以通过box-sizing来切换两种盒模型。\n  - 矩形盒子\n    - W3C标准盒模型(box-sizing: content-box)\n      size = content + border + padding\n    - IE盒模型(box-sizing: border-box)\n      size = content\n  我们在编写html时若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒模型，FireFox等会将其解释为W3C盒子模型，从而渲染出不同的结果。\n\n**11、**  主流的浏览器内核有哪些\n\n- Trident\n  Trident为在早期的IE内核，没有使用W3C标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。\n- Gecko\n  Gecko(火狐内核)，代码开源，也是一个跨平台内核。\n- Presto\n  Presto(Opera前内核)，渲染速度快兼容性差，现已废弃而采用Google Chrome的Blink内核。\n- Webkit\n  Webkit(Safari内核)，主要由渲染引擎WebCore和javascript解释引擎JSCore组成，代码开源。\n- Chromium/Blink\n  2008年谷歌发布了chrome浏览器，其内核被命名为chromium，chromium代码fork自开源引擎webkit并对其进行重新梳理。\n  2013年谷歌决定从WebKit衍生出自己的Blink(WebKit的分支)引擎，后由Google和Opera Software共同研发。\n  \n**12、**  前端页面分层\n\n- 结构层\n  由HTML或XHTML创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。\n- 表示层\n  由CSS创建，CSS对如何显示这些标签内容进行了回答。\n- 行为层\n  行为层回答了内容应该如何对事件作出反应\n\n**13、**  以下输出的内容\n\n函数作用域内var声明是局部变量\n```\nvar a = 1;\nfunction func(){console.log(a);var a = \"in\";}\nfunc();\n=> undefined\n```\n\n**14、**  以下输出的内容\n\n```\n(\n  function func() {\n    var a = b ='res';\n  }\n)();\n\n//b前面没有跟着var相当于全局变量，所有输出res\nconsole.log(b);//res\n//a前面没有跟着var所以a是局部变量，所有输出undefined\nconsole.log(a);\n```\n\n**15、**  用js写一个继承实例\n\n```\nfunction Parent(name, age) {\n  this.name = name;\n  this.age = age;\n  function getName() {\n    console.log(this.name);\n  }\n}\n\nfunction Child(name, age) {\n  Parent.call(this, name, age)\n  this.weight = 120;\n}\n\nconst snow = new Child('snow', '20');\nconsole.log(snow.name)\n```\n\n**16、**  匹配文档中的关键字\n\n```\n  const colorKeyWords = (node, targetValue) => {\n    const HIGHLIGHT_COLOR = \"orange\";  \n    const highlightTag = \"<span style='background-color: \"+HIGHLIGHT_COLOR+\";'>\" + targetValue + \"</span>\";\n    let htmlStr = node.innerHTML;\n\n    const targetReg = new RegExp(targetValue, \"ig\");\n    htmlStr = htmlStr.replace(targetReg, highlightTag);\n    node.innerHTML = htmlStr;\n  }\n```\n\n**17、**  单击以下node时获取node的属性title和内容`<div id=\"xhm\" title=\"blog\">my blog</div>`\n\n```\nconst node = document.getElementById(\"xhm\");\nnode.addEventListener('click', ()=> {\n  console.log(node.innerText); // my blog\n  console.log(node.getAttribute('title')); // blog\n})\n```\n\n**18、**  link和@import的区别\n\n- 从属关系不同\n  link属于XHTML提供的标签，除了加载CSS外还可以做其他事情，比如定义RSS、定义rel连接属性等，而@import只能用于加载CSS。\n\n- 加载时机不同\n  link引用CSS时，在页面加载的同时加载，而@import引用的CSS要在页面加载完后再加载。\n\n- 兼容性不同\n  link属于XHTML标签，无兼容性问题。而@import是在CSS2.1提出的，低版本浏览器不支持。\n\n- DOM可控性的不同\n  link支持使用JavaScript控制DOM去改变样式，而@import不支持。\n\n\n**19、** 修改chrome浏览器表单自动填充后的黄色背景\n\n- 取消chrome的自动填充\n\n```\n <input autoComplete=\"new-password\" />\n```\n\n- 设置内阴影来覆盖黄色背景\n  \n```\n&: -webkit-autofill {\n  -webkit-box-shadow: 0 0 0 1000px white inset;\n  -webkit-text-fill-color: black;\n}\n```\n\n- 设置动画\n  \n通过动画设置其背景永远为透明。\n  \n```\n &:-webkit-autofill {\n    animation: autofill-fix 1s infinite;\n  }\n \n @keyframes autofill-fix {\n   from {\n     background-color: transparent;\n   }\n   to {\n      background-color: transparent;\n   }\n }\n```\n\n**20、** JavaScript数据类型\n\n- 基本数据类型\n  - undefined\n  - Null\n  - Boolean\n  - String\n  - Number\n  - Symbol(new in ES6)\n- 引用数据类型(Object类型)\n  - Object\n  - Array\n  - Date\n  - RegRxp\n  - Function\n  \n\n**21、** js将一浮点数小数点左边的数字每三位加一个逗号\n\n- 利用parseInt的toLocaleString方法\n```\nconst formatNum = (num) => num.toString().replace(/(\\d+)(.*)/g, (match, s1, s2) => `${parseInt(s1).toLocaleString()}${s2}`)\n\nformatNum(15234555.55)\n=> \"15,234,555.55\"\n```\n\n- 完全用正则替换\n  \n```\n//当一个字符串中某个数字后跟着n对三个数字(\\d{3})就匹配这个数字\nconst formateNum = (num) => {\n  const numStr = num.toString();\n  //替换小数点左边的数字\n  return numStr.replace(/\\d+/, (match) => {\n    //替换目标数字为`${matchNum},`\n    return match.replace(/(\\d)(?=(\\d{3}+$))/, (s1) => `${s1},`);\n  })\n}\n\nformateNum(435345.656)\n=> \"435,345.656\"\n```\n\n**22、** HTML常见的内联元素和块级元素\n- 内联元素\n  - a\n  - img\n  - input\n  - label\n  - span\n  - br\n  - select\n  - strong\n  - textarea\n\n- 块级元素\n  - div\n  - h1-h6\n  - form\n  - hr\n  - p\n  - ul\n  - table\n  - option\n  - li\n\n**23、** 移动开发中使用rem的优点\n\nrem是CSS3新增的一个单位即root em，它与em的区别在于em是相对父元素的font-size，而rem相对的是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。因此对于移动开发而言，只要通过媒体查询来根据不同的屏幕宽度设置`<html>`元素的字体大小，就可以适配不同的屏幕。\n\n\n**24、** js模块化分哪些阶段\n\n- 无模块化\n  \n  js最初的作用只是进行表单验证或添加一些简单的动画，js文件通过`script`标签进行引用，没有模块化一说，随着前端复杂度提高想要引入更多的js文件就把多个`script`标签放在一起。\n  ```\n  　<script src=\"script1.js\"></script>\n　　<script src=\"script2.js\"></script>\n　　<script src=\"script3.js\"></script>\n  ```\n  - 优点\n    相对于把所有逻辑放入一个文件，这种引入多个js文件实现简单模块化的思想是进步的。\n  - 缺点\n    污染全局作用域，文件间依赖关系不明显。\n\n- CommonJS规范\n  CommonJS是一个JavaScript模块化规范，最初用于服务端的node。根据这个规范一个文件就是一个模块，其内部定义的变量函数只属于这个模块而不对外暴露。CommonJS通过export或module.exports来导出需要对外提供的接口，通过require方法来同步加载所要依赖的模块。\n\n  - 模块定义\n  ```\n  // util.js\n  var x = 0;\n  var add = function (value) {\n    return value + x;\n  };\n  module.exports.x = x;\n  module.exports.add = add;\n\n  ```\n  - 模块使用\n  ```\n   var util = require(./util.js); \n   console.log(util.x); // 0\n   console.log(util.add(1)); // 1\n  ```\n\n  - 优点\n    解决了全局污染及模块间依赖的问题\n  - 缺点\n    CommonJS为同步加载，在服务端因其文件都在本地，同步加载没有问题，但在浏览器端文件需要异步加载 CommonJS就不再适用了。\n\n- AMD规范\n  AMD(Asynchronous Module Definition)规范为异步加载模块，并允许指定回调函数，实现AMD规范的加载器JS主要有两个require.js 和 curl.js。\n  AMD标准中定义了两个API，define和require: \n  - 模块定义: define(id, [depends], callback)\n\n  ```\n  //math.js，定义了一个math模块\n  define(function () {\n    var add = function (x, y) {\n      return x + y;\n    }\n    return {\n      add: add,\n    };\n  });\n\n  ```\n  - 模块使用: require([module], callback)\n  ```\n    require(['math'], function (math){\n      console.log(math.add(1,1));\n    });\n        \n  ```\n\n  - 优点\n    适合在浏览器环境中异步加载模块，并可以并行加载多个模块。\n  - 缺点\n    提高了开发成本，且不能按需加载，而是必须提前加载所有的依赖。\n\n\n\n- CMD规范\n  CMD(Common Module Definition)规范是seajs推崇的规范，与requirejs类似，其不同点在于其加载模式为按需加载。\n\n  ```\n  define(function(require, exports, module) {\n    var a = require('pdf.js');\n    a.doSomething();\n    // 依赖就近书写，什么时候用到什么时候引入\n    var b = require('./b');\n    b.doSomething();\n  });\n  ```\n\n  - 优点\n    实现了异步加载模块，并可以按需加载。\n  - 缺点\n    依赖SPM打包，模块的加载逻辑偏重。\n\n- ES6模块化\n  前面的模块化方法都是社区自己实现的，而ES6的模块化方案是真正的规范。在ES6中通过import关键字引入模块，export关键字导出模块，目前浏览器尚不支持es6因此需要用babel将代码转换为广泛支持的require。\n  ```\n    import React, { Component } from 'react';\n    import Counter from '../counter';\n\n    class Home extends Component {\n      render() {\n        return (\n          <div>\n            <Counter />\n          </div>\n        );\n      }\n    }\n\n    export default Home;\n  ```\n\n\n**25、** 不用第三个变量，直接交换两个变量的值\n\n- 方法1: 利用技巧\n  \n```\n  var a = 5;\n  var b = 6;\n  a = a + b;\n  b = a - b;\n  a = a - b;\n\n  console.log(a); // 6\n  console.log(b); // 5\n```\n\n- 方法2: 利用位运算\n  位运算当且仅当只有一个表达式的某位上为1时，结果的该位才为1。否则结果的该位为0。\n\n```\n  var a = 5; // 二进制101\n  var b = 6; // 二进制110\n  a = a^b;\n=> \n  a = 101\n      110\n      ---\n      011\n\n  b = a^b;\n\n=>\n  b = 011\n      110\n      ---\n      101\n  \n  a = a^b;\n=>\n  a = 011\n      101\n      ---\n      110\n\n  console.log(a); // 6\n  console.log(b); // 5\n```\n  \n**26、** CSS创建平移动画\n\n  \n```\n  width: 100px;\n    height: 30px;\n    position: absolute;\n    background: blue;\n    left: 0;\n    top: 0;\n    animation: move 3s ease infinite; \n  \n    @keyframes move {\n      50% {\n        left: 100px;\n        top: 100px;\n      }\n    }\n    或\n    @keyframes move {\n      50% {\n        transform: translate(100px, 100px);\n      }\n    }\n```\n\n**27、** js选择select下的option\n\n```\n<select>\n  <option value=\"option1\">1</option>\n  <option value=\"option2\">2</option>\n</select>\n\nconst selectNode = document.querySelector('select');\n// 1.设置value的值等于option的value来选中option\nselectNode.value = option2;\n\n// 2.设置selectedIndex来选中option\nselectNode.selectedIndex = 1;\n\n```\n\n**28、** CSS实现超出部分内容显示`...`\n\n```\n{\n  //需限制其宽度\n  max-width: 100px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n```\n\n**29、** CSS postion定位有哪几种情况\n\n- static\n  static定位是默认的定位方式，元素出现在正常的文档流中，会忽略left、top、right、bottom以及z-index。\n\n- absolute\n  absolute定位即绝对定位，相对于除static定位元素的第一个父类元素进行定位，元素的位置通过left、top、right以及bottom 属性进行设置。\n\n- fixed\n  fixed定位即固定定位，类似于绝对定位，但它是相对于浏览器窗口进行定位的，元素的位置通过left、top、right以及bottom 属性进行设置。\n\n- relative\n  relative定位即相对定位，相对的参考位置为元素自身所在文档流的位置(static定位时的位置)，通过left、top、right以及bottom属性进行设置。相对定位虽然脱离了文档流，但计算其他元素在文档流中的位置时仍会以该元素正常的文档流位置进行计算，就好像元素还在原来的位置。\n\n- inherit\n  继承父类的postion值，不会继承其left、top、right及bottom值\n\n\n**30、** 内联元素和块级元素的区别\n\n**内联元素**\n - 和相邻的内联元素在同一行\n - 设置width和height无效\n - margin上下无效，padding上下虽然可以设置，但并不会挤压其他元素的空间，在其他元素看来好像没有设置一样\n\n**块级元素**\n\n - 块级元素总是各占一行，垂直排列\n - 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可设置\n\n内联元素可以通过该变display属性进行转换，\n- `display:block`: 表现形式如块级元素\n- `display:inline`: 表现形式如内联元素\n- `display:inline-block`: 表现形式如内联元素和块级元素，具有block元素可以设置宽高的特性，同时又具有内联元素的不换行等特性\n\n\n**31、** js判断一个变量是否是数组\n\n```\nfuction isArray(obj) {\n  Object.prototype.toString().call(obj) === \"[object Array]\";\n}\n现代浏览器\nArray.isArray(obj)\n```\n\n**32、** JavaScript由哪三部分构成\n\n- 核心(ECMAScript)\n  ECMAScript仅仅是一个描述，定义了脚本语言所有的属性、方法和对象，其他语言可以实现 ECMAScript 来作为功能的基准\n- 文档对模型(DOM)\n  它是HTML和XML的应用程序接口，DOM将整个页面规划成由节点层级构成的文档，HTML或XML页面的每个部分都是一个节点的衍生物\n- 浏览器对象模型(BOM)\n  它提供了一种特性，可以对浏览器窗口进行访问和操作，使用BOM开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。\n\n\n**33、** sql的注入原理及防范方法\n\n通常服务器端都会根据客户端的请求来动态构建sql执行语句，sql注入是通过将恶意的sql语句添加到应用的输入参数中，从而在sql服务器后台解析执行。\n防范方法:\n- sql语句预编译和绑定变量\n  sql执行命令必须先通过语法分析，生成执行计划，预编译后不管注入的参数是什么都不会再执行，而是当作字符串字面值进行处理。\n- 严格检查参数\n  只执行规定格式的参数可以避免部分的sql注入\n- 使用安全函数\n  安全函数将参数的特殊字符进行编码，这样sql引擎就不会将参数当成sql语句进行解析了。\n\n**34、** JavaScript的垃圾回收机制\n\nJavaScript有自动垃圾回收机制，当然这并不意味着你不需要关心内存管理。\n内存的生命周期大致分为内存的分配、内存的使用以及不需要时内存的释放。因此只要追踪内存的生命周期就能自动的对内存进行分配回收了，但是这并不容易，尤其要确定某块内存是否真的不需要了。因此，垃圾回收只能有限制的解决一般问题，主要有两种方法，引用计数和标记清除算法。\n\n- 引用计数法\n  在内存管理环境中，如果一个对象(包括函数作用域、全局词法作用域等)有访问另一个对象的权限，叫做一个对象访问另一个对象。当对象被引用的次数为0时就被回收。\n  ```\n  var a = { v: 1 }; // 对象{ v: 1 }被变量a引用一次，引用计数为1\n  var b = a; // 同样，对象{ v: 1 }被变量b引用一次，引用计数为2\n  a = null; // 对象引用次数减1\n  b = null;// 对象引用次数减1，此时引用计数为0，对象可以被释放\n  ```\n  引用计数有一个潜在的问题，就是无法解决循环引用的问题。\n  如下，a、b互相引用，引用计数一直为1，导致不能自动回收。\n  ```\n    function f() {\n      var a = {};\n      var b = {};\n      a.value = b;\n      b.value = a;\n    }\n    f();\n  ```\n- 标记清除算法\n\n 这个算法假定有一个叫跟(root)的对象(js中为window， node js为global)，垃圾回收器定期从根开始，找所有从根开始引用的对象，然后找这些引用对象引用的对象...将这些对象标记为active，其他的不能被根引用或间接引用的将被标记为garbage，最终将这些垃圾清除。\n 循环引用将不再是问题，上例中函数f执行完后，全局window就无法访问到对象a和b了，因此对象a、b将会被回收。\n <center>![标记清除意图]](/images/mark_sweep.gif)<center>\n <center>标记清除意图 <center>\n\n\n\n\n    \n\n\n\n\n\n\n","source":"_posts/每日一题.md","raw":"---\nlayout: post\ntitle: 每日一题\ncategory : subject\ntagline: \"Supporting tagline\"\ntags : [subject]\ndescription: 前端题集\ndate: 2017-1-04 21:36:05\n---\n\n**1、** `<img>`的title和alt有什么区别\n\n- title是鼠标移动到元素显示的值\n- alt是`<img>`特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。\n\n**2、** 从浏览器地址栏输入url到显示页面的步骤\n\n- 浏览器根据请求的url，交给DNS解析域名找到真实的Ip，向服务器请求数据。\n- 服务器处理完成返回数据，浏览器接收数据(Html、js、css、image等)\n- 浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom等)\n- 载入解析到的资源文件，渲染页面、完成。\n\n\n**3、**js遍历li的内容\n```\n<ul>\n  <li>1</li>\n  <li>2</li>\n</ul>\n```\n=>\n```\n  const u = document.querySelector('ul');\n  const lis = u.children;\n  for(let i = 0; i < lis.length; i++) {\n    const li = lis[i];\n    console.log(li.innerText);\n  }\n  或\n  const realArr = [].slice.call(lis);\n  realArr.forEach((li) => {\n    console.log(li.innerText)\n  })\n\n```\n**4、** JavaScript`===`和`==`的区别\n`===`即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换\n`==`即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如相等则相等。\n需要指出的是NaN不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0等于(==或===)-0(对于0而言没有正负之分)。\n\n\n**5、** JavaScript中null和undefined的区别\n由于历史原因JavaScript中有null和undefined两个表示无的值，其区别很小，主要在于：\n- null的类型为Object，undefined的类型为undefined\n- Number(null)为0，Number(undefined)为NaN\n- null表示没有对象，此处不该有值，undefined表示此处应该有值暂时缺少这个值\n\n**6、** 常见http code及其含义\n- 信息响应(1xx)\n  表示服务器收到请求，需要请求者继续执行操作\n  - 100 Continue: 客户端应继续其请求。\n- 成功(2xx)\n  表示服务器成功接收请求并处理返回\n  - 200 Ok: 请求正常处理完毕。一般用于GET与POST请求\n  - 202 Accepted: 服务器已经接受到消息，当时尚未处理\n  - 204 No Content: 服务器成功处理了请求但未返回任何内容\n  - 206 Partial Content: 服务器成功处理了部分get请求\n- 重定向(3xx)\n  表示需要客户端进一步操作才能完成请求\n  - 301 Moved Permanently: 永久重定向，请求的资源已永久移动到新URI\n  - 302 Found: 临时重定向，资源临时移动到新的位置\n  - 304 Not Modified: 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。\n  - 307 Temporary Redirect: 临时重定向，不允许更改请求方法\n- 客户端错误(4xx)\n  表示客户端可能发生了错误\n  - 400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解\n  - 401 Unauthorized: 要求身份验证\n  - 403 Forbidden: 服务器理解请求但拒绝执行\n  - 404 Not Found: 服务器没有找到资源\n- 服务器错误(5xx)\n  表示服务器无法完成请求\n  - 500 Internal Server Error: 服务器遇到未知问题，无法处理请求\n  - 503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求\n\n\n**7、**  **Coo**kie, SessionStorage与LocalStorage区别\n\n[demo](https://github.com/fengyueran/web-cache-demo.git)\n- 储存大小\n  - Cookie: 4kb左右\n  - SessionStorage: 一般为5M\n  - LocalStorage: 一般为5M\n- 生命周期\n  - Cookie: 默认是关闭浏览器后失效，可以设置失效时间\n  - SessionStorage: 仅在当前会话有效，关闭tab页即失效\n  - LocalStorage: 持久缓存除非主动清除(通过浏览器或JS)\n- 与服务器通信\n  - 每次请求都会携带在http请求头中，可能带来性能问题\n  - SessionStorage: 只在客户端起作用\n  - LocalStorage: 只在客户端起作用\n\n**8、**  html代码中让链接在新窗口中打开的写法\n\n通过设置a标签的target属性为_blank可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过window.openner访问原页面的窗口对象，并且可以通过window.opener.location = newURL将原页面导航至不同的网址。因此需要通过ref=\"noopenner\"来禁用window.opener。\n```\n  <div>\n    <div>\n      <a href=\"http://www.xinghunm.com\">Welcome -  old window</a>\n    </div>\n    <div>\n        <a href=\"http://www.xinghunm.com\" target=\"_blank\" ref=\"noopenner\">Welcome -  new window</a>\n    </div>\n  </div>\n```\n\n**9、**  html5有哪些新特性，移除的元素有哪些\n新增:\n  - WebSocket\n  - 用于绘画的canvas元素\n  - 用于媒介回放的vedio和audio元素\n  - 新增sessionStorage和localStorage对离线缓存更好的支持\n  - 新的特殊内容元素，如article、header、footer、nav、section\n  - 新的表单控件，如calendar、date、time、email、url、search\n移除:\n  - basefont\n  - big\n  - center\n  - dir\n  - font\n  - frame\n  - frameset\n  - noframes\n  - strike\n  - tt\n\n**10、**  谈谈对盒模型的理解\n\n  浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为W3C标准盒模型和IE盒模型，W3C标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而IE盒模型的大小只由内容区域的大小(自定义的width和height)决定。css可以通过box-sizing来切换两种盒模型。\n  - 矩形盒子\n    - W3C标准盒模型(box-sizing: content-box)\n      size = content + border + padding\n    - IE盒模型(box-sizing: border-box)\n      size = content\n  我们在编写html时若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒模型，FireFox等会将其解释为W3C盒子模型，从而渲染出不同的结果。\n\n**11、**  主流的浏览器内核有哪些\n\n- Trident\n  Trident为在早期的IE内核，没有使用W3C标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。\n- Gecko\n  Gecko(火狐内核)，代码开源，也是一个跨平台内核。\n- Presto\n  Presto(Opera前内核)，渲染速度快兼容性差，现已废弃而采用Google Chrome的Blink内核。\n- Webkit\n  Webkit(Safari内核)，主要由渲染引擎WebCore和javascript解释引擎JSCore组成，代码开源。\n- Chromium/Blink\n  2008年谷歌发布了chrome浏览器，其内核被命名为chromium，chromium代码fork自开源引擎webkit并对其进行重新梳理。\n  2013年谷歌决定从WebKit衍生出自己的Blink(WebKit的分支)引擎，后由Google和Opera Software共同研发。\n  \n**12、**  前端页面分层\n\n- 结构层\n  由HTML或XHTML创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。\n- 表示层\n  由CSS创建，CSS对如何显示这些标签内容进行了回答。\n- 行为层\n  行为层回答了内容应该如何对事件作出反应\n\n**13、**  以下输出的内容\n\n函数作用域内var声明是局部变量\n```\nvar a = 1;\nfunction func(){console.log(a);var a = \"in\";}\nfunc();\n=> undefined\n```\n\n**14、**  以下输出的内容\n\n```\n(\n  function func() {\n    var a = b ='res';\n  }\n)();\n\n//b前面没有跟着var相当于全局变量，所有输出res\nconsole.log(b);//res\n//a前面没有跟着var所以a是局部变量，所有输出undefined\nconsole.log(a);\n```\n\n**15、**  用js写一个继承实例\n\n```\nfunction Parent(name, age) {\n  this.name = name;\n  this.age = age;\n  function getName() {\n    console.log(this.name);\n  }\n}\n\nfunction Child(name, age) {\n  Parent.call(this, name, age)\n  this.weight = 120;\n}\n\nconst snow = new Child('snow', '20');\nconsole.log(snow.name)\n```\n\n**16、**  匹配文档中的关键字\n\n```\n  const colorKeyWords = (node, targetValue) => {\n    const HIGHLIGHT_COLOR = \"orange\";  \n    const highlightTag = \"<span style='background-color: \"+HIGHLIGHT_COLOR+\";'>\" + targetValue + \"</span>\";\n    let htmlStr = node.innerHTML;\n\n    const targetReg = new RegExp(targetValue, \"ig\");\n    htmlStr = htmlStr.replace(targetReg, highlightTag);\n    node.innerHTML = htmlStr;\n  }\n```\n\n**17、**  单击以下node时获取node的属性title和内容`<div id=\"xhm\" title=\"blog\">my blog</div>`\n\n```\nconst node = document.getElementById(\"xhm\");\nnode.addEventListener('click', ()=> {\n  console.log(node.innerText); // my blog\n  console.log(node.getAttribute('title')); // blog\n})\n```\n\n**18、**  link和@import的区别\n\n- 从属关系不同\n  link属于XHTML提供的标签，除了加载CSS外还可以做其他事情，比如定义RSS、定义rel连接属性等，而@import只能用于加载CSS。\n\n- 加载时机不同\n  link引用CSS时，在页面加载的同时加载，而@import引用的CSS要在页面加载完后再加载。\n\n- 兼容性不同\n  link属于XHTML标签，无兼容性问题。而@import是在CSS2.1提出的，低版本浏览器不支持。\n\n- DOM可控性的不同\n  link支持使用JavaScript控制DOM去改变样式，而@import不支持。\n\n\n**19、** 修改chrome浏览器表单自动填充后的黄色背景\n\n- 取消chrome的自动填充\n\n```\n <input autoComplete=\"new-password\" />\n```\n\n- 设置内阴影来覆盖黄色背景\n  \n```\n&: -webkit-autofill {\n  -webkit-box-shadow: 0 0 0 1000px white inset;\n  -webkit-text-fill-color: black;\n}\n```\n\n- 设置动画\n  \n通过动画设置其背景永远为透明。\n  \n```\n &:-webkit-autofill {\n    animation: autofill-fix 1s infinite;\n  }\n \n @keyframes autofill-fix {\n   from {\n     background-color: transparent;\n   }\n   to {\n      background-color: transparent;\n   }\n }\n```\n\n**20、** JavaScript数据类型\n\n- 基本数据类型\n  - undefined\n  - Null\n  - Boolean\n  - String\n  - Number\n  - Symbol(new in ES6)\n- 引用数据类型(Object类型)\n  - Object\n  - Array\n  - Date\n  - RegRxp\n  - Function\n  \n\n**21、** js将一浮点数小数点左边的数字每三位加一个逗号\n\n- 利用parseInt的toLocaleString方法\n```\nconst formatNum = (num) => num.toString().replace(/(\\d+)(.*)/g, (match, s1, s2) => `${parseInt(s1).toLocaleString()}${s2}`)\n\nformatNum(15234555.55)\n=> \"15,234,555.55\"\n```\n\n- 完全用正则替换\n  \n```\n//当一个字符串中某个数字后跟着n对三个数字(\\d{3})就匹配这个数字\nconst formateNum = (num) => {\n  const numStr = num.toString();\n  //替换小数点左边的数字\n  return numStr.replace(/\\d+/, (match) => {\n    //替换目标数字为`${matchNum},`\n    return match.replace(/(\\d)(?=(\\d{3}+$))/, (s1) => `${s1},`);\n  })\n}\n\nformateNum(435345.656)\n=> \"435,345.656\"\n```\n\n**22、** HTML常见的内联元素和块级元素\n- 内联元素\n  - a\n  - img\n  - input\n  - label\n  - span\n  - br\n  - select\n  - strong\n  - textarea\n\n- 块级元素\n  - div\n  - h1-h6\n  - form\n  - hr\n  - p\n  - ul\n  - table\n  - option\n  - li\n\n**23、** 移动开发中使用rem的优点\n\nrem是CSS3新增的一个单位即root em，它与em的区别在于em是相对父元素的font-size，而rem相对的是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。因此对于移动开发而言，只要通过媒体查询来根据不同的屏幕宽度设置`<html>`元素的字体大小，就可以适配不同的屏幕。\n\n\n**24、** js模块化分哪些阶段\n\n- 无模块化\n  \n  js最初的作用只是进行表单验证或添加一些简单的动画，js文件通过`script`标签进行引用，没有模块化一说，随着前端复杂度提高想要引入更多的js文件就把多个`script`标签放在一起。\n  ```\n  　<script src=\"script1.js\"></script>\n　　<script src=\"script2.js\"></script>\n　　<script src=\"script3.js\"></script>\n  ```\n  - 优点\n    相对于把所有逻辑放入一个文件，这种引入多个js文件实现简单模块化的思想是进步的。\n  - 缺点\n    污染全局作用域，文件间依赖关系不明显。\n\n- CommonJS规范\n  CommonJS是一个JavaScript模块化规范，最初用于服务端的node。根据这个规范一个文件就是一个模块，其内部定义的变量函数只属于这个模块而不对外暴露。CommonJS通过export或module.exports来导出需要对外提供的接口，通过require方法来同步加载所要依赖的模块。\n\n  - 模块定义\n  ```\n  // util.js\n  var x = 0;\n  var add = function (value) {\n    return value + x;\n  };\n  module.exports.x = x;\n  module.exports.add = add;\n\n  ```\n  - 模块使用\n  ```\n   var util = require(./util.js); \n   console.log(util.x); // 0\n   console.log(util.add(1)); // 1\n  ```\n\n  - 优点\n    解决了全局污染及模块间依赖的问题\n  - 缺点\n    CommonJS为同步加载，在服务端因其文件都在本地，同步加载没有问题，但在浏览器端文件需要异步加载 CommonJS就不再适用了。\n\n- AMD规范\n  AMD(Asynchronous Module Definition)规范为异步加载模块，并允许指定回调函数，实现AMD规范的加载器JS主要有两个require.js 和 curl.js。\n  AMD标准中定义了两个API，define和require: \n  - 模块定义: define(id, [depends], callback)\n\n  ```\n  //math.js，定义了一个math模块\n  define(function () {\n    var add = function (x, y) {\n      return x + y;\n    }\n    return {\n      add: add,\n    };\n  });\n\n  ```\n  - 模块使用: require([module], callback)\n  ```\n    require(['math'], function (math){\n      console.log(math.add(1,1));\n    });\n        \n  ```\n\n  - 优点\n    适合在浏览器环境中异步加载模块，并可以并行加载多个模块。\n  - 缺点\n    提高了开发成本，且不能按需加载，而是必须提前加载所有的依赖。\n\n\n\n- CMD规范\n  CMD(Common Module Definition)规范是seajs推崇的规范，与requirejs类似，其不同点在于其加载模式为按需加载。\n\n  ```\n  define(function(require, exports, module) {\n    var a = require('pdf.js');\n    a.doSomething();\n    // 依赖就近书写，什么时候用到什么时候引入\n    var b = require('./b');\n    b.doSomething();\n  });\n  ```\n\n  - 优点\n    实现了异步加载模块，并可以按需加载。\n  - 缺点\n    依赖SPM打包，模块的加载逻辑偏重。\n\n- ES6模块化\n  前面的模块化方法都是社区自己实现的，而ES6的模块化方案是真正的规范。在ES6中通过import关键字引入模块，export关键字导出模块，目前浏览器尚不支持es6因此需要用babel将代码转换为广泛支持的require。\n  ```\n    import React, { Component } from 'react';\n    import Counter from '../counter';\n\n    class Home extends Component {\n      render() {\n        return (\n          <div>\n            <Counter />\n          </div>\n        );\n      }\n    }\n\n    export default Home;\n  ```\n\n\n**25、** 不用第三个变量，直接交换两个变量的值\n\n- 方法1: 利用技巧\n  \n```\n  var a = 5;\n  var b = 6;\n  a = a + b;\n  b = a - b;\n  a = a - b;\n\n  console.log(a); // 6\n  console.log(b); // 5\n```\n\n- 方法2: 利用位运算\n  位运算当且仅当只有一个表达式的某位上为1时，结果的该位才为1。否则结果的该位为0。\n\n```\n  var a = 5; // 二进制101\n  var b = 6; // 二进制110\n  a = a^b;\n=> \n  a = 101\n      110\n      ---\n      011\n\n  b = a^b;\n\n=>\n  b = 011\n      110\n      ---\n      101\n  \n  a = a^b;\n=>\n  a = 011\n      101\n      ---\n      110\n\n  console.log(a); // 6\n  console.log(b); // 5\n```\n  \n**26、** CSS创建平移动画\n\n  \n```\n  width: 100px;\n    height: 30px;\n    position: absolute;\n    background: blue;\n    left: 0;\n    top: 0;\n    animation: move 3s ease infinite; \n  \n    @keyframes move {\n      50% {\n        left: 100px;\n        top: 100px;\n      }\n    }\n    或\n    @keyframes move {\n      50% {\n        transform: translate(100px, 100px);\n      }\n    }\n```\n\n**27、** js选择select下的option\n\n```\n<select>\n  <option value=\"option1\">1</option>\n  <option value=\"option2\">2</option>\n</select>\n\nconst selectNode = document.querySelector('select');\n// 1.设置value的值等于option的value来选中option\nselectNode.value = option2;\n\n// 2.设置selectedIndex来选中option\nselectNode.selectedIndex = 1;\n\n```\n\n**28、** CSS实现超出部分内容显示`...`\n\n```\n{\n  //需限制其宽度\n  max-width: 100px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n```\n\n**29、** CSS postion定位有哪几种情况\n\n- static\n  static定位是默认的定位方式，元素出现在正常的文档流中，会忽略left、top、right、bottom以及z-index。\n\n- absolute\n  absolute定位即绝对定位，相对于除static定位元素的第一个父类元素进行定位，元素的位置通过left、top、right以及bottom 属性进行设置。\n\n- fixed\n  fixed定位即固定定位，类似于绝对定位，但它是相对于浏览器窗口进行定位的，元素的位置通过left、top、right以及bottom 属性进行设置。\n\n- relative\n  relative定位即相对定位，相对的参考位置为元素自身所在文档流的位置(static定位时的位置)，通过left、top、right以及bottom属性进行设置。相对定位虽然脱离了文档流，但计算其他元素在文档流中的位置时仍会以该元素正常的文档流位置进行计算，就好像元素还在原来的位置。\n\n- inherit\n  继承父类的postion值，不会继承其left、top、right及bottom值\n\n\n**30、** 内联元素和块级元素的区别\n\n**内联元素**\n - 和相邻的内联元素在同一行\n - 设置width和height无效\n - margin上下无效，padding上下虽然可以设置，但并不会挤压其他元素的空间，在其他元素看来好像没有设置一样\n\n**块级元素**\n\n - 块级元素总是各占一行，垂直排列\n - 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可设置\n\n内联元素可以通过该变display属性进行转换，\n- `display:block`: 表现形式如块级元素\n- `display:inline`: 表现形式如内联元素\n- `display:inline-block`: 表现形式如内联元素和块级元素，具有block元素可以设置宽高的特性，同时又具有内联元素的不换行等特性\n\n\n**31、** js判断一个变量是否是数组\n\n```\nfuction isArray(obj) {\n  Object.prototype.toString().call(obj) === \"[object Array]\";\n}\n现代浏览器\nArray.isArray(obj)\n```\n\n**32、** JavaScript由哪三部分构成\n\n- 核心(ECMAScript)\n  ECMAScript仅仅是一个描述，定义了脚本语言所有的属性、方法和对象，其他语言可以实现 ECMAScript 来作为功能的基准\n- 文档对模型(DOM)\n  它是HTML和XML的应用程序接口，DOM将整个页面规划成由节点层级构成的文档，HTML或XML页面的每个部分都是一个节点的衍生物\n- 浏览器对象模型(BOM)\n  它提供了一种特性，可以对浏览器窗口进行访问和操作，使用BOM开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。\n\n\n**33、** sql的注入原理及防范方法\n\n通常服务器端都会根据客户端的请求来动态构建sql执行语句，sql注入是通过将恶意的sql语句添加到应用的输入参数中，从而在sql服务器后台解析执行。\n防范方法:\n- sql语句预编译和绑定变量\n  sql执行命令必须先通过语法分析，生成执行计划，预编译后不管注入的参数是什么都不会再执行，而是当作字符串字面值进行处理。\n- 严格检查参数\n  只执行规定格式的参数可以避免部分的sql注入\n- 使用安全函数\n  安全函数将参数的特殊字符进行编码，这样sql引擎就不会将参数当成sql语句进行解析了。\n\n**34、** JavaScript的垃圾回收机制\n\nJavaScript有自动垃圾回收机制，当然这并不意味着你不需要关心内存管理。\n内存的生命周期大致分为内存的分配、内存的使用以及不需要时内存的释放。因此只要追踪内存的生命周期就能自动的对内存进行分配回收了，但是这并不容易，尤其要确定某块内存是否真的不需要了。因此，垃圾回收只能有限制的解决一般问题，主要有两种方法，引用计数和标记清除算法。\n\n- 引用计数法\n  在内存管理环境中，如果一个对象(包括函数作用域、全局词法作用域等)有访问另一个对象的权限，叫做一个对象访问另一个对象。当对象被引用的次数为0时就被回收。\n  ```\n  var a = { v: 1 }; // 对象{ v: 1 }被变量a引用一次，引用计数为1\n  var b = a; // 同样，对象{ v: 1 }被变量b引用一次，引用计数为2\n  a = null; // 对象引用次数减1\n  b = null;// 对象引用次数减1，此时引用计数为0，对象可以被释放\n  ```\n  引用计数有一个潜在的问题，就是无法解决循环引用的问题。\n  如下，a、b互相引用，引用计数一直为1，导致不能自动回收。\n  ```\n    function f() {\n      var a = {};\n      var b = {};\n      a.value = b;\n      b.value = a;\n    }\n    f();\n  ```\n- 标记清除算法\n\n 这个算法假定有一个叫跟(root)的对象(js中为window， node js为global)，垃圾回收器定期从根开始，找所有从根开始引用的对象，然后找这些引用对象引用的对象...将这些对象标记为active，其他的不能被根引用或间接引用的将被标记为garbage，最终将这些垃圾清除。\n 循环引用将不再是问题，上例中函数f执行完后，全局window就无法访问到对象a和b了，因此对象a、b将会被回收。\n <center>![标记清除意图]](/images/mark_sweep.gif)<center>\n <center>标记清除意图 <center>\n\n\n\n\n    \n\n\n\n\n\n\n","slug":"每日一题","published":1,"updated":"2019-01-07T06:33:56.768Z","_id":"cjq5aqcso000idszt8swv9flx","comments":1,"photos":[],"link":"","content":"<p><strong>1、</strong> <code>&lt;img&gt;</code>的title和alt有什么区别</p>\n<ul>\n<li>title是鼠标移动到元素显示的值</li>\n<li>alt是<code>&lt;img&gt;</code>特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。</li>\n</ul>\n<p><strong>2、</strong> 从浏览器地址栏输入url到显示页面的步骤</p>\n<ul>\n<li>浏览器根据请求的url，交给DNS解析域名找到真实的Ip，向服务器请求数据。</li>\n<li>服务器处理完成返回数据，浏览器接收数据(Html、js、css、image等)</li>\n<li>浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom等)</li>\n<li>载入解析到的资源文件，渲染页面、完成。</li>\n</ul>\n<p><strong>3、</strong>js遍历li的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li&gt;1&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;2&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>\n<p>=&gt;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const u = document.querySelector(&apos;ul&apos;);</span><br><span class=\"line\">const lis = u.children;</span><br><span class=\"line\">for(let i = 0; i &lt; lis.length; i++) &#123;</span><br><span class=\"line\">  const li = lis[i];</span><br><span class=\"line\">  console.log(li.innerText);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或</span><br><span class=\"line\">const realArr = [].slice.call(lis);</span><br><span class=\"line\">realArr.forEach((li) =&gt; &#123;</span><br><span class=\"line\">  console.log(li.innerText)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>4、</strong> JavaScript<code>===</code>和<code>==</code>的区别<br><code>===</code>即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换<br><code>==</code>即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如相等则相等。<br>需要指出的是NaN不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0等于(==或===)-0(对于0而言没有正负之分)。</p>\n<p><strong>5、</strong> JavaScript中null和undefined的区别<br>由于历史原因JavaScript中有null和undefined两个表示无的值，其区别很小，主要在于：</p>\n<ul>\n<li>null的类型为Object，undefined的类型为undefined</li>\n<li>Number(null)为0，Number(undefined)为NaN</li>\n<li>null表示没有对象，此处不该有值，undefined表示此处应该有值暂时缺少这个值</li>\n</ul>\n<p><strong>6、</strong> 常见http code及其含义</p>\n<ul>\n<li>信息响应(1xx)<br>表示服务器收到请求，需要请求者继续执行操作<ul>\n<li>100 Continue: 客户端应继续其请求。</li>\n</ul>\n</li>\n<li>成功(2xx)<br>表示服务器成功接收请求并处理返回<ul>\n<li>200 Ok: 请求正常处理完毕。一般用于GET与POST请求</li>\n<li>202 Accepted: 服务器已经接受到消息，当时尚未处理</li>\n<li>204 No Content: 服务器成功处理了请求但未返回任何内容</li>\n<li>206 Partial Content: 服务器成功处理了部分get请求</li>\n</ul>\n</li>\n<li>重定向(3xx)<br>表示需要客户端进一步操作才能完成请求<ul>\n<li>301 Moved Permanently: 永久重定向，请求的资源已永久移动到新URI</li>\n<li>302 Found: 临时重定向，资源临时移动到新的位置</li>\n<li>304 Not Modified: 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。</li>\n<li>307 Temporary Redirect: 临时重定向，不允许更改请求方法</li>\n</ul>\n</li>\n<li>客户端错误(4xx)<br>表示客户端可能发生了错误<ul>\n<li>400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解</li>\n<li>401 Unauthorized: 要求身份验证</li>\n<li>403 Forbidden: 服务器理解请求但拒绝执行</li>\n<li>404 Not Found: 服务器没有找到资源</li>\n</ul>\n</li>\n<li>服务器错误(5xx)<br>表示服务器无法完成请求<ul>\n<li>500 Internal Server Error: 服务器遇到未知问题，无法处理请求</li>\n<li>503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求</li>\n</ul>\n</li>\n</ul>\n<p><strong>7、</strong>  <strong>Coo</strong>kie, SessionStorage与LocalStorage区别</p>\n<p><a href=\"https://github.com/fengyueran/web-cache-demo.git\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<ul>\n<li>储存大小<ul>\n<li>Cookie: 4kb左右</li>\n<li>SessionStorage: 一般为5M</li>\n<li>LocalStorage: 一般为5M</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>Cookie: 默认是关闭浏览器后失效，可以设置失效时间</li>\n<li>SessionStorage: 仅在当前会话有效，关闭tab页即失效</li>\n<li>LocalStorage: 持久缓存除非主动清除(通过浏览器或JS)</li>\n</ul>\n</li>\n<li>与服务器通信<ul>\n<li>每次请求都会携带在http请求头中，可能带来性能问题</li>\n<li>SessionStorage: 只在客户端起作用</li>\n<li>LocalStorage: 只在客户端起作用</li>\n</ul>\n</li>\n</ul>\n<p><strong>8、</strong>  html代码中让链接在新窗口中打开的写法</p>\n<p>通过设置a标签的target属性为_blank可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过window.openner访问原页面的窗口对象，并且可以通过window.opener.location = newURL将原页面导航至不同的网址。因此需要通过ref=”noopenner”来禁用window.opener。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;a href=&quot;http://www.xinghunm.com&quot;&gt;Welcome -  old window&lt;/a&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">      &lt;a href=&quot;http://www.xinghunm.com&quot; target=&quot;_blank&quot; ref=&quot;noopenner&quot;&gt;Welcome -  new window&lt;/a&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>9、</strong>  html5有哪些新特性，移除的元素有哪些<br>新增:</p>\n<ul>\n<li>WebSocket</li>\n<li>用于绘画的canvas元素</li>\n<li>用于媒介回放的vedio和audio元素</li>\n<li>新增sessionStorage和localStorage对离线缓存更好的支持</li>\n<li>新的特殊内容元素，如article、header、footer、nav、section</li>\n<li>新的表单控件，如calendar、date、time、email、url、search<br>移除:</li>\n<li>basefont</li>\n<li>big</li>\n<li>center</li>\n<li>dir</li>\n<li>font</li>\n<li>frame</li>\n<li>frameset</li>\n<li>noframes</li>\n<li>strike</li>\n<li>tt</li>\n</ul>\n<p><strong>10、</strong>  谈谈对盒模型的理解</p>\n<p>  浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为W3C标准盒模型和IE盒模型，W3C标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而IE盒模型的大小只由内容区域的大小(自定义的width和height)决定。css可以通过box-sizing来切换两种盒模型。</p>\n<ul>\n<li>矩形盒子<ul>\n<li>W3C标准盒模型(box-sizing: content-box)<br>size = content + border + padding</li>\n<li>IE盒模型(box-sizing: border-box)<br>size = content<br>我们在编写html时若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒模型，FireFox等会将其解释为W3C盒子模型，从而渲染出不同的结果。</li>\n</ul>\n</li>\n</ul>\n<p><strong>11、</strong>  主流的浏览器内核有哪些</p>\n<ul>\n<li>Trident<br>Trident为在早期的IE内核，没有使用W3C标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。</li>\n<li>Gecko<br>Gecko(火狐内核)，代码开源，也是一个跨平台内核。</li>\n<li>Presto<br>Presto(Opera前内核)，渲染速度快兼容性差，现已废弃而采用Google Chrome的Blink内核。</li>\n<li>Webkit<br>Webkit(Safari内核)，主要由渲染引擎WebCore和javascript解释引擎JSCore组成，代码开源。</li>\n<li>Chromium/Blink<br>2008年谷歌发布了chrome浏览器，其内核被命名为chromium，chromium代码fork自开源引擎webkit并对其进行重新梳理。<br>2013年谷歌决定从WebKit衍生出自己的Blink(WebKit的分支)引擎，后由Google和Opera Software共同研发。</li>\n</ul>\n<p><strong>12、</strong>  前端页面分层</p>\n<ul>\n<li>结构层<br>由HTML或XHTML创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。</li>\n<li>表示层<br>由CSS创建，CSS对如何显示这些标签内容进行了回答。</li>\n<li>行为层<br>行为层回答了内容应该如何对事件作出反应</li>\n</ul>\n<p><strong>13、</strong>  以下输出的内容</p>\n<p>函数作用域内var声明是局部变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">function func()&#123;console.log(a);var a = &quot;in&quot;;&#125;</span><br><span class=\"line\">func();</span><br><span class=\"line\">=&gt; undefined</span><br></pre></td></tr></table></figure></p>\n<p><strong>14、</strong>  以下输出的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(</span><br><span class=\"line\">  function func() &#123;</span><br><span class=\"line\">    var a = b =&apos;res&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)();</span><br><span class=\"line\"></span><br><span class=\"line\">//b前面没有跟着var相当于全局变量，所有输出res</span><br><span class=\"line\">console.log(b);//res</span><br><span class=\"line\">//a前面没有跟着var所以a是局部变量，所有输出undefined</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n<p><strong>15、</strong>  用js写一个继承实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent(name, age) &#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  function getName() &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child(name, age) &#123;</span><br><span class=\"line\">  Parent.call(this, name, age)</span><br><span class=\"line\">  this.weight = 120;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const snow = new Child(&apos;snow&apos;, &apos;20&apos;);</span><br><span class=\"line\">console.log(snow.name)</span><br></pre></td></tr></table></figure>\n<p><strong>16、</strong>  匹配文档中的关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const colorKeyWords = (node, targetValue) =&gt; &#123;</span><br><span class=\"line\">  const HIGHLIGHT_COLOR = &quot;orange&quot;;  </span><br><span class=\"line\">  const highlightTag = &quot;&lt;span style=&apos;background-color: &quot;+HIGHLIGHT_COLOR+&quot;;&apos;&gt;&quot; + targetValue + &quot;&lt;/span&gt;&quot;;</span><br><span class=\"line\">  let htmlStr = node.innerHTML;</span><br><span class=\"line\"></span><br><span class=\"line\">  const targetReg = new RegExp(targetValue, &quot;ig&quot;);</span><br><span class=\"line\">  htmlStr = htmlStr.replace(targetReg, highlightTag);</span><br><span class=\"line\">  node.innerHTML = htmlStr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>17、</strong>  单击以下node时获取node的属性title和内容<code>&lt;div id=&quot;xhm&quot; title=&quot;blog&quot;&gt;my blog&lt;/div&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const node = document.getElementById(&quot;xhm&quot;);</span><br><span class=\"line\">node.addEventListener(&apos;click&apos;, ()=&gt; &#123;</span><br><span class=\"line\">  console.log(node.innerText); // my blog</span><br><span class=\"line\">  console.log(node.getAttribute(&apos;title&apos;)); // blog</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>18、</strong>  link和@import的区别</p>\n<ul>\n<li><p>从属关系不同<br>link属于XHTML提供的标签，除了加载CSS外还可以做其他事情，比如定义RSS、定义rel连接属性等，而@import只能用于加载CSS。</p>\n</li>\n<li><p>加载时机不同<br>link引用CSS时，在页面加载的同时加载，而@import引用的CSS要在页面加载完后再加载。</p>\n</li>\n<li><p>兼容性不同<br>link属于XHTML标签，无兼容性问题。而@import是在CSS2.1提出的，低版本浏览器不支持。</p>\n</li>\n<li><p>DOM可控性的不同<br>link支持使用JavaScript控制DOM去改变样式，而@import不支持。</p>\n</li>\n</ul>\n<p><strong>19、</strong> 修改chrome浏览器表单自动填充后的黄色背景</p>\n<ul>\n<li>取消chrome的自动填充</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input autoComplete=&quot;new-password&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置内阴影来覆盖黄色背景</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;: -webkit-autofill &#123;</span><br><span class=\"line\">  -webkit-box-shadow: 0 0 0 1000px white inset;</span><br><span class=\"line\">  -webkit-text-fill-color: black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置动画</li>\n</ul>\n<p>通过动画设置其背景永远为透明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;:-webkit-autofill &#123;</span><br><span class=\"line\">   animation: autofill-fix 1s infinite;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes autofill-fix &#123;</span><br><span class=\"line\">  from &#123;</span><br><span class=\"line\">    background-color: transparent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  to &#123;</span><br><span class=\"line\">     background-color: transparent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>20、</strong> JavaScript数据类型</p>\n<ul>\n<li>基本数据类型<ul>\n<li>undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n<li>Symbol(new in ES6)</li>\n</ul>\n</li>\n<li>引用数据类型(Object类型)<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegRxp</li>\n<li>Function</li>\n</ul>\n</li>\n</ul>\n<p><strong>21、</strong> js将一浮点数小数点左边的数字每三位加一个逗号</p>\n<ul>\n<li><p>利用parseInt的toLocaleString方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const formatNum = (num) =&gt; num.toString().replace(/(\\d+)(.*)/g, (match, s1, s2) =&gt; `$&#123;parseInt(s1).toLocaleString()&#125;$&#123;s2&#125;`)</span><br><span class=\"line\"></span><br><span class=\"line\">formatNum(15234555.55)</span><br><span class=\"line\">=&gt; &quot;15,234,555.55&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完全用正则替换</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//当一个字符串中某个数字后跟着n对三个数字(\\d&#123;3&#125;)就匹配这个数字</span><br><span class=\"line\">const formateNum = (num) =&gt; &#123;</span><br><span class=\"line\">  const numStr = num.toString();</span><br><span class=\"line\">  //替换小数点左边的数字</span><br><span class=\"line\">  return numStr.replace(/\\d+/, (match) =&gt; &#123;</span><br><span class=\"line\">    //替换目标数字为`$&#123;matchNum&#125;,`</span><br><span class=\"line\">    return match.replace(/(\\d)(?=(\\d&#123;3&#125;+$))/, (s1) =&gt; `$&#123;s1&#125;,`);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">formateNum(435345.656)</span><br><span class=\"line\">=&gt; &quot;435,345.656&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>22、</strong> HTML常见的内联元素和块级元素</p>\n<ul>\n<li><p>内联元素</p>\n<ul>\n<li>a</li>\n<li>img</li>\n<li>input</li>\n<li>label</li>\n<li>span</li>\n<li>br</li>\n<li>select</li>\n<li>strong</li>\n<li>textarea</li>\n</ul>\n</li>\n<li><p>块级元素</p>\n<ul>\n<li>div</li>\n<li>h1-h6</li>\n<li>form</li>\n<li>hr</li>\n<li>p</li>\n<li>ul</li>\n<li>table</li>\n<li>option</li>\n<li>li</li>\n</ul>\n</li>\n</ul>\n<p><strong>23、</strong> 移动开发中使用rem的优点</p>\n<p>rem是CSS3新增的一个单位即root em，它与em的区别在于em是相对父元素的font-size，而rem相对的是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。因此对于移动开发而言，只要通过媒体查询来根据不同的屏幕宽度设置<code>&lt;html&gt;</code>元素的字体大小，就可以适配不同的屏幕。</p>\n<p><strong>24、</strong> js模块化分哪些阶段</p>\n<ul>\n<li><p>无模块化</p>\n<p>js最初的作用只是进行表单验证或添加一些简单的动画，js文件通过<code>script</code>标签进行引用，没有模块化一说，随着前端复杂度提高想要引入更多的js文件就把多个<code>script</code>标签放在一起。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  　&lt;script src=&quot;script1.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">　　&lt;script src=&quot;script2.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">　　&lt;script src=&quot;script3.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>优点<br>相对于把所有逻辑放入一个文件，这种引入多个js文件实现简单模块化的思想是进步的。</li>\n<li>缺点<br>污染全局作用域，文件间依赖关系不明显。</li>\n</ul>\n</li>\n<li><p>CommonJS规范<br>CommonJS是一个JavaScript模块化规范，最初用于服务端的node。根据这个规范一个文件就是一个模块，其内部定义的变量函数只属于这个模块而不对外暴露。CommonJS通过export或module.exports来导出需要对外提供的接口，通过require方法来同步加载所要依赖的模块。</p>\n<ul>\n<li><p>模块定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// util.js</span><br><span class=\"line\">var x = 0;</span><br><span class=\"line\">var add = function (value) &#123;</span><br><span class=\"line\">  return value + x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports.x = x;</span><br><span class=\"line\">module.exports.add = add;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模块使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var util = require(./util.js); </span><br><span class=\"line\">console.log(util.x); // 0</span><br><span class=\"line\">console.log(util.add(1)); // 1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>优点<br>解决了全局污染及模块间依赖的问题</p>\n</li>\n<li>缺点<br>CommonJS为同步加载，在服务端因其文件都在本地，同步加载没有问题，但在浏览器端文件需要异步加载 CommonJS就不再适用了。</li>\n</ul>\n</li>\n<li><p>AMD规范<br>AMD(Asynchronous Module Definition)规范为异步加载模块，并允许指定回调函数，实现AMD规范的加载器JS主要有两个require.js 和 curl.js。<br>AMD标准中定义了两个API，define和require: </p>\n<ul>\n<li>模块定义: define(id, [depends], callback)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//math.js，定义了一个math模块</span><br><span class=\"line\">define(function () &#123;</span><br><span class=\"line\">  var add = function (x, y) &#123;</span><br><span class=\"line\">    return x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    add: add,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>模块使用: require([module], callback)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require([&apos;math&apos;], function (math)&#123;</span><br><span class=\"line\">  console.log(math.add(1,1));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>优点<br>适合在浏览器环境中异步加载模块，并可以并行加载多个模块。</p>\n</li>\n<li>缺点<br>提高了开发成本，且不能按需加载，而是必须提前加载所有的依赖。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>CMD规范<br>CMD(Common Module Definition)规范是seajs推崇的规范，与requirejs类似，其不同点在于其加载模式为按需加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">  var a = require(&apos;pdf.js&apos;);</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 依赖就近书写，什么时候用到什么时候引入</span><br><span class=\"line\">  var b = require(&apos;./b&apos;);</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>优点<br>实现了异步加载模块，并可以按需加载。</li>\n<li>缺点<br>依赖SPM打包，模块的加载逻辑偏重。</li>\n</ul>\n</li>\n<li><p>ES6模块化<br>前面的模块化方法都是社区自己实现的，而ES6的模块化方案是真正的规范。在ES6中通过import关键字引入模块，export关键字导出模块，目前浏览器尚不支持es6因此需要用babel将代码转换为广泛支持的require。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">import Counter from &apos;../counter&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Home extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Counter /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Home;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>25、</strong> 不用第三个变量，直接交换两个变量的值</p>\n<ul>\n<li>方法1: 利用技巧</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 5;</span><br><span class=\"line\">var b = 6;</span><br><span class=\"line\">a = a + b;</span><br><span class=\"line\">b = a - b;</span><br><span class=\"line\">a = a - b;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a); // 6</span><br><span class=\"line\">console.log(b); // 5</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法2: 利用位运算<br>位运算当且仅当只有一个表达式的某位上为1时，结果的该位才为1。否则结果的该位为0。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  var a = 5; // 二进制101</span><br><span class=\"line\">  var b = 6; // 二进制110</span><br><span class=\"line\">  a = a^b;</span><br><span class=\"line\">=&gt; </span><br><span class=\"line\">  a = 101</span><br><span class=\"line\">      110</span><br><span class=\"line\">      ---</span><br><span class=\"line\">      011</span><br><span class=\"line\"></span><br><span class=\"line\">  b = a^b;</span><br><span class=\"line\"></span><br><span class=\"line\">=&gt;</span><br><span class=\"line\">  b = 011</span><br><span class=\"line\">      110</span><br><span class=\"line\">      ---</span><br><span class=\"line\">      101</span><br><span class=\"line\">  </span><br><span class=\"line\">  a = a^b;</span><br><span class=\"line\">=&gt;</span><br><span class=\"line\">  a = 011</span><br><span class=\"line\">      101</span><br><span class=\"line\">      ---</span><br><span class=\"line\">      110</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(a); // 6</span><br><span class=\"line\">  console.log(b); // 5</span><br></pre></td></tr></table></figure>\n<p><strong>26、</strong> CSS创建平移动画</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width: 100px;</span><br><span class=\"line\">  height: 30px;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  background: blue;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  animation: move 3s ease infinite; </span><br><span class=\"line\"></span><br><span class=\"line\">  @keyframes move &#123;</span><br><span class=\"line\">    50% &#123;</span><br><span class=\"line\">      left: 100px;</span><br><span class=\"line\">      top: 100px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  或</span><br><span class=\"line\">  @keyframes move &#123;</span><br><span class=\"line\">    50% &#123;</span><br><span class=\"line\">      transform: translate(100px, 100px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>27、</strong> js选择select下的option</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select&gt;</span><br><span class=\"line\">  &lt;option value=&quot;option1&quot;&gt;1&lt;/option&gt;</span><br><span class=\"line\">  &lt;option value=&quot;option2&quot;&gt;2&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">const selectNode = document.querySelector(&apos;select&apos;);</span><br><span class=\"line\">// 1.设置value的值等于option的value来选中option</span><br><span class=\"line\">selectNode.value = option2;</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.设置selectedIndex来选中option</span><br><span class=\"line\">selectNode.selectedIndex = 1;</span><br></pre></td></tr></table></figure>\n<p><strong>28、</strong> CSS实现超出部分内容显示<code>...</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  //需限制其宽度</span><br><span class=\"line\">  max-width: 100px;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  text-overflow: ellipsis;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>29、</strong> CSS postion定位有哪几种情况</p>\n<ul>\n<li><p>static<br>static定位是默认的定位方式，元素出现在正常的文档流中，会忽略left、top、right、bottom以及z-index。</p>\n</li>\n<li><p>absolute<br>absolute定位即绝对定位，相对于除static定位元素的第一个父类元素进行定位，元素的位置通过left、top、right以及bottom 属性进行设置。</p>\n</li>\n<li><p>fixed<br>fixed定位即固定定位，类似于绝对定位，但它是相对于浏览器窗口进行定位的，元素的位置通过left、top、right以及bottom 属性进行设置。</p>\n</li>\n<li><p>relative<br>relative定位即相对定位，相对的参考位置为元素自身所在文档流的位置(static定位时的位置)，通过left、top、right以及bottom属性进行设置。相对定位虽然脱离了文档流，但计算其他元素在文档流中的位置时仍会以该元素正常的文档流位置进行计算，就好像元素还在原来的位置。</p>\n</li>\n<li><p>inherit<br>继承父类的postion值，不会继承其left、top、right及bottom值</p>\n</li>\n</ul>\n<p><strong>30、</strong> 内联元素和块级元素的区别</p>\n<p><strong>内联元素</strong></p>\n<ul>\n<li>和相邻的内联元素在同一行</li>\n<li>设置width和height无效</li>\n<li>margin上下无效，padding上下虽然可以设置，但并不会挤压其他元素的空间，在其他元素看来好像没有设置一样</li>\n</ul>\n<p><strong>块级元素</strong></p>\n<ul>\n<li>块级元素总是各占一行，垂直排列</li>\n<li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可设置</li>\n</ul>\n<p>内联元素可以通过该变display属性进行转换，</p>\n<ul>\n<li><code>display:block</code>: 表现形式如块级元素</li>\n<li><code>display:inline</code>: 表现形式如内联元素</li>\n<li><code>display:inline-block</code>: 表现形式如内联元素和块级元素，具有block元素可以设置宽高的特性，同时又具有内联元素的不换行等特性</li>\n</ul>\n<p><strong>31、</strong> js判断一个变量是否是数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fuction isArray(obj) &#123;</span><br><span class=\"line\">  Object.prototype.toString().call(obj) === &quot;[object Array]&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">现代浏览器</span><br><span class=\"line\">Array.isArray(obj)</span><br></pre></td></tr></table></figure>\n<p><strong>32、</strong> JavaScript由哪三部分构成</p>\n<ul>\n<li>核心(ECMAScript)<br>ECMAScript仅仅是一个描述，定义了脚本语言所有的属性、方法和对象，其他语言可以实现 ECMAScript 来作为功能的基准</li>\n<li>文档对模型(DOM)<br>它是HTML和XML的应用程序接口，DOM将整个页面规划成由节点层级构成的文档，HTML或XML页面的每个部分都是一个节点的衍生物</li>\n<li>浏览器对象模型(BOM)<br>它提供了一种特性，可以对浏览器窗口进行访问和操作，使用BOM开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。</li>\n</ul>\n<p><strong>33、</strong> sql的注入原理及防范方法</p>\n<p>通常服务器端都会根据客户端的请求来动态构建sql执行语句，sql注入是通过将恶意的sql语句添加到应用的输入参数中，从而在sql服务器后台解析执行。<br>防范方法:</p>\n<ul>\n<li>sql语句预编译和绑定变量<br>sql执行命令必须先通过语法分析，生成执行计划，预编译后不管注入的参数是什么都不会再执行，而是当作字符串字面值进行处理。</li>\n<li>严格检查参数<br>只执行规定格式的参数可以避免部分的sql注入</li>\n<li>使用安全函数<br>安全函数将参数的特殊字符进行编码，这样sql引擎就不会将参数当成sql语句进行解析了。</li>\n</ul>\n<p><strong>34、</strong> JavaScript的垃圾回收机制</p>\n<p>JavaScript有自动垃圾回收机制，当然这并不意味着你不需要关心内存管理。<br>内存的生命周期大致分为内存的分配、内存的使用以及不需要时内存的释放。因此只要追踪内存的生命周期就能自动的对内存进行分配回收了，但是这并不容易，尤其要确定某块内存是否真的不需要了。因此，垃圾回收只能有限制的解决一般问题，主要有两种方法，引用计数和标记清除算法。</p>\n<ul>\n<li><p>引用计数法<br>在内存管理环境中，如果一个对象(包括函数作用域、全局词法作用域等)有访问另一个对象的权限，叫做一个对象访问另一个对象。当对象被引用的次数为0时就被回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123; v: 1 &#125;; // 对象&#123; v: 1 &#125;被变量a引用一次，引用计数为1</span><br><span class=\"line\">var b = a; // 同样，对象&#123; v: 1 &#125;被变量b引用一次，引用计数为2</span><br><span class=\"line\">a = null; // 对象引用次数减1</span><br><span class=\"line\">b = null;// 对象引用次数减1，此时引用计数为0，对象可以被释放</span><br></pre></td></tr></table></figure>\n<p>引用计数有一个潜在的问题，就是无法解决循环引用的问题。<br>如下，a、b互相引用，引用计数一直为1，导致不能自动回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  var a = &#123;&#125;;</span><br><span class=\"line\">  var b = &#123;&#125;;</span><br><span class=\"line\">  a.value = b;</span><br><span class=\"line\">  b.value = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>标记清除算法</p>\n<p>这个算法假定有一个叫跟(root)的对象(js中为window， node js为global)，垃圾回收器定期从根开始，找所有从根开始引用的对象，然后找这些引用对象引用的对象…将这些对象标记为active，其他的不能被根引用或间接引用的将被标记为garbage，最终将这些垃圾清除。<br>循环引用将不再是问题，上例中函数f执行完后，全局window就无法访问到对象a和b了，因此对象a、b将会被回收。<br><center><img src=\"/images/mark_sweep.gif\" alt=\"标记清除意图]\"><center><br><center>标记清除意图 <center></center></center></center></center></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>1、</strong> <code>&lt;img&gt;</code>的title和alt有什么区别</p>\n<ul>\n<li>title是鼠标移动到元素显示的值</li>\n<li>alt是<code>&lt;img&gt;</code>特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。</li>\n</ul>\n<p><strong>2、</strong> 从浏览器地址栏输入url到显示页面的步骤</p>\n<ul>\n<li>浏览器根据请求的url，交给DNS解析域名找到真实的Ip，向服务器请求数据。</li>\n<li>服务器处理完成返回数据，浏览器接收数据(Html、js、css、image等)</li>\n<li>浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom等)</li>\n<li>载入解析到的资源文件，渲染页面、完成。</li>\n</ul>\n<p><strong>3、</strong>js遍历li的内容<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ul&gt;</span><br><span class=\"line\">  &lt;li&gt;1&lt;/li&gt;</span><br><span class=\"line\">  &lt;li&gt;2&lt;/li&gt;</span><br><span class=\"line\">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p>\n<p>=&gt;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const u = document.querySelector(&apos;ul&apos;);</span><br><span class=\"line\">const lis = u.children;</span><br><span class=\"line\">for(let i = 0; i &lt; lis.length; i++) &#123;</span><br><span class=\"line\">  const li = lis[i];</span><br><span class=\"line\">  console.log(li.innerText);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或</span><br><span class=\"line\">const realArr = [].slice.call(lis);</span><br><span class=\"line\">realArr.forEach((li) =&gt; &#123;</span><br><span class=\"line\">  console.log(li.innerText)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><strong>4、</strong> JavaScript<code>===</code>和<code>==</code>的区别<br><code>===</code>即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换<br><code>==</code>即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如相等则相等。<br>需要指出的是NaN不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0等于(==或===)-0(对于0而言没有正负之分)。</p>\n<p><strong>5、</strong> JavaScript中null和undefined的区别<br>由于历史原因JavaScript中有null和undefined两个表示无的值，其区别很小，主要在于：</p>\n<ul>\n<li>null的类型为Object，undefined的类型为undefined</li>\n<li>Number(null)为0，Number(undefined)为NaN</li>\n<li>null表示没有对象，此处不该有值，undefined表示此处应该有值暂时缺少这个值</li>\n</ul>\n<p><strong>6、</strong> 常见http code及其含义</p>\n<ul>\n<li>信息响应(1xx)<br>表示服务器收到请求，需要请求者继续执行操作<ul>\n<li>100 Continue: 客户端应继续其请求。</li>\n</ul>\n</li>\n<li>成功(2xx)<br>表示服务器成功接收请求并处理返回<ul>\n<li>200 Ok: 请求正常处理完毕。一般用于GET与POST请求</li>\n<li>202 Accepted: 服务器已经接受到消息，当时尚未处理</li>\n<li>204 No Content: 服务器成功处理了请求但未返回任何内容</li>\n<li>206 Partial Content: 服务器成功处理了部分get请求</li>\n</ul>\n</li>\n<li>重定向(3xx)<br>表示需要客户端进一步操作才能完成请求<ul>\n<li>301 Moved Permanently: 永久重定向，请求的资源已永久移动到新URI</li>\n<li>302 Found: 临时重定向，资源临时移动到新的位置</li>\n<li>304 Not Modified: 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。</li>\n<li>307 Temporary Redirect: 临时重定向，不允许更改请求方法</li>\n</ul>\n</li>\n<li>客户端错误(4xx)<br>表示客户端可能发生了错误<ul>\n<li>400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解</li>\n<li>401 Unauthorized: 要求身份验证</li>\n<li>403 Forbidden: 服务器理解请求但拒绝执行</li>\n<li>404 Not Found: 服务器没有找到资源</li>\n</ul>\n</li>\n<li>服务器错误(5xx)<br>表示服务器无法完成请求<ul>\n<li>500 Internal Server Error: 服务器遇到未知问题，无法处理请求</li>\n<li>503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求</li>\n</ul>\n</li>\n</ul>\n<p><strong>7、</strong>  <strong>Coo</strong>kie, SessionStorage与LocalStorage区别</p>\n<p><a href=\"https://github.com/fengyueran/web-cache-demo.git\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<ul>\n<li>储存大小<ul>\n<li>Cookie: 4kb左右</li>\n<li>SessionStorage: 一般为5M</li>\n<li>LocalStorage: 一般为5M</li>\n</ul>\n</li>\n<li>生命周期<ul>\n<li>Cookie: 默认是关闭浏览器后失效，可以设置失效时间</li>\n<li>SessionStorage: 仅在当前会话有效，关闭tab页即失效</li>\n<li>LocalStorage: 持久缓存除非主动清除(通过浏览器或JS)</li>\n</ul>\n</li>\n<li>与服务器通信<ul>\n<li>每次请求都会携带在http请求头中，可能带来性能问题</li>\n<li>SessionStorage: 只在客户端起作用</li>\n<li>LocalStorage: 只在客户端起作用</li>\n</ul>\n</li>\n</ul>\n<p><strong>8、</strong>  html代码中让链接在新窗口中打开的写法</p>\n<p>通过设置a标签的target属性为_blank可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过window.openner访问原页面的窗口对象，并且可以通过window.opener.location = newURL将原页面导航至不同的网址。因此需要通过ref=”noopenner”来禁用window.opener。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;a href=&quot;http://www.xinghunm.com&quot;&gt;Welcome -  old window&lt;/a&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">      &lt;a href=&quot;http://www.xinghunm.com&quot; target=&quot;_blank&quot; ref=&quot;noopenner&quot;&gt;Welcome -  new window&lt;/a&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>\n<p><strong>9、</strong>  html5有哪些新特性，移除的元素有哪些<br>新增:</p>\n<ul>\n<li>WebSocket</li>\n<li>用于绘画的canvas元素</li>\n<li>用于媒介回放的vedio和audio元素</li>\n<li>新增sessionStorage和localStorage对离线缓存更好的支持</li>\n<li>新的特殊内容元素，如article、header、footer、nav、section</li>\n<li>新的表单控件，如calendar、date、time、email、url、search<br>移除:</li>\n<li>basefont</li>\n<li>big</li>\n<li>center</li>\n<li>dir</li>\n<li>font</li>\n<li>frame</li>\n<li>frameset</li>\n<li>noframes</li>\n<li>strike</li>\n<li>tt</li>\n</ul>\n<p><strong>10、</strong>  谈谈对盒模型的理解</p>\n<p>  浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为W3C标准盒模型和IE盒模型，W3C标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而IE盒模型的大小只由内容区域的大小(自定义的width和height)决定。css可以通过box-sizing来切换两种盒模型。</p>\n<ul>\n<li>矩形盒子<ul>\n<li>W3C标准盒模型(box-sizing: content-box)<br>size = content + border + padding</li>\n<li>IE盒模型(box-sizing: border-box)<br>size = content<br>我们在编写html时若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒模型，FireFox等会将其解释为W3C盒子模型，从而渲染出不同的结果。</li>\n</ul>\n</li>\n</ul>\n<p><strong>11、</strong>  主流的浏览器内核有哪些</p>\n<ul>\n<li>Trident<br>Trident为在早期的IE内核，没有使用W3C标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。</li>\n<li>Gecko<br>Gecko(火狐内核)，代码开源，也是一个跨平台内核。</li>\n<li>Presto<br>Presto(Opera前内核)，渲染速度快兼容性差，现已废弃而采用Google Chrome的Blink内核。</li>\n<li>Webkit<br>Webkit(Safari内核)，主要由渲染引擎WebCore和javascript解释引擎JSCore组成，代码开源。</li>\n<li>Chromium/Blink<br>2008年谷歌发布了chrome浏览器，其内核被命名为chromium，chromium代码fork自开源引擎webkit并对其进行重新梳理。<br>2013年谷歌决定从WebKit衍生出自己的Blink(WebKit的分支)引擎，后由Google和Opera Software共同研发。</li>\n</ul>\n<p><strong>12、</strong>  前端页面分层</p>\n<ul>\n<li>结构层<br>由HTML或XHTML创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。</li>\n<li>表示层<br>由CSS创建，CSS对如何显示这些标签内容进行了回答。</li>\n<li>行为层<br>行为层回答了内容应该如何对事件作出反应</li>\n</ul>\n<p><strong>13、</strong>  以下输出的内容</p>\n<p>函数作用域内var声明是局部变量<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 1;</span><br><span class=\"line\">function func()&#123;console.log(a);var a = &quot;in&quot;;&#125;</span><br><span class=\"line\">func();</span><br><span class=\"line\">=&gt; undefined</span><br></pre></td></tr></table></figure></p>\n<p><strong>14、</strong>  以下输出的内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(</span><br><span class=\"line\">  function func() &#123;</span><br><span class=\"line\">    var a = b =&apos;res&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)();</span><br><span class=\"line\"></span><br><span class=\"line\">//b前面没有跟着var相当于全局变量，所有输出res</span><br><span class=\"line\">console.log(b);//res</span><br><span class=\"line\">//a前面没有跟着var所以a是局部变量，所有输出undefined</span><br><span class=\"line\">console.log(a);</span><br></pre></td></tr></table></figure>\n<p><strong>15、</strong>  用js写一个继承实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent(name, age) &#123;</span><br><span class=\"line\">  this.name = name;</span><br><span class=\"line\">  this.age = age;</span><br><span class=\"line\">  function getName() &#123;</span><br><span class=\"line\">    console.log(this.name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child(name, age) &#123;</span><br><span class=\"line\">  Parent.call(this, name, age)</span><br><span class=\"line\">  this.weight = 120;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const snow = new Child(&apos;snow&apos;, &apos;20&apos;);</span><br><span class=\"line\">console.log(snow.name)</span><br></pre></td></tr></table></figure>\n<p><strong>16、</strong>  匹配文档中的关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const colorKeyWords = (node, targetValue) =&gt; &#123;</span><br><span class=\"line\">  const HIGHLIGHT_COLOR = &quot;orange&quot;;  </span><br><span class=\"line\">  const highlightTag = &quot;&lt;span style=&apos;background-color: &quot;+HIGHLIGHT_COLOR+&quot;;&apos;&gt;&quot; + targetValue + &quot;&lt;/span&gt;&quot;;</span><br><span class=\"line\">  let htmlStr = node.innerHTML;</span><br><span class=\"line\"></span><br><span class=\"line\">  const targetReg = new RegExp(targetValue, &quot;ig&quot;);</span><br><span class=\"line\">  htmlStr = htmlStr.replace(targetReg, highlightTag);</span><br><span class=\"line\">  node.innerHTML = htmlStr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>17、</strong>  单击以下node时获取node的属性title和内容<code>&lt;div id=&quot;xhm&quot; title=&quot;blog&quot;&gt;my blog&lt;/div&gt;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const node = document.getElementById(&quot;xhm&quot;);</span><br><span class=\"line\">node.addEventListener(&apos;click&apos;, ()=&gt; &#123;</span><br><span class=\"line\">  console.log(node.innerText); // my blog</span><br><span class=\"line\">  console.log(node.getAttribute(&apos;title&apos;)); // blog</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>18、</strong>  link和@import的区别</p>\n<ul>\n<li><p>从属关系不同<br>link属于XHTML提供的标签，除了加载CSS外还可以做其他事情，比如定义RSS、定义rel连接属性等，而@import只能用于加载CSS。</p>\n</li>\n<li><p>加载时机不同<br>link引用CSS时，在页面加载的同时加载，而@import引用的CSS要在页面加载完后再加载。</p>\n</li>\n<li><p>兼容性不同<br>link属于XHTML标签，无兼容性问题。而@import是在CSS2.1提出的，低版本浏览器不支持。</p>\n</li>\n<li><p>DOM可控性的不同<br>link支持使用JavaScript控制DOM去改变样式，而@import不支持。</p>\n</li>\n</ul>\n<p><strong>19、</strong> 修改chrome浏览器表单自动填充后的黄色背景</p>\n<ul>\n<li>取消chrome的自动填充</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input autoComplete=&quot;new-password&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置内阴影来覆盖黄色背景</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;: -webkit-autofill &#123;</span><br><span class=\"line\">  -webkit-box-shadow: 0 0 0 1000px white inset;</span><br><span class=\"line\">  -webkit-text-fill-color: black;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>设置动画</li>\n</ul>\n<p>通过动画设置其背景永远为透明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;:-webkit-autofill &#123;</span><br><span class=\"line\">   animation: autofill-fix 1s infinite;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">@keyframes autofill-fix &#123;</span><br><span class=\"line\">  from &#123;</span><br><span class=\"line\">    background-color: transparent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  to &#123;</span><br><span class=\"line\">     background-color: transparent;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>20、</strong> JavaScript数据类型</p>\n<ul>\n<li>基本数据类型<ul>\n<li>undefined</li>\n<li>Null</li>\n<li>Boolean</li>\n<li>String</li>\n<li>Number</li>\n<li>Symbol(new in ES6)</li>\n</ul>\n</li>\n<li>引用数据类型(Object类型)<ul>\n<li>Object</li>\n<li>Array</li>\n<li>Date</li>\n<li>RegRxp</li>\n<li>Function</li>\n</ul>\n</li>\n</ul>\n<p><strong>21、</strong> js将一浮点数小数点左边的数字每三位加一个逗号</p>\n<ul>\n<li><p>利用parseInt的toLocaleString方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const formatNum = (num) =&gt; num.toString().replace(/(\\d+)(.*)/g, (match, s1, s2) =&gt; `$&#123;parseInt(s1).toLocaleString()&#125;$&#123;s2&#125;`)</span><br><span class=\"line\"></span><br><span class=\"line\">formatNum(15234555.55)</span><br><span class=\"line\">=&gt; &quot;15,234,555.55&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>完全用正则替换</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//当一个字符串中某个数字后跟着n对三个数字(\\d&#123;3&#125;)就匹配这个数字</span><br><span class=\"line\">const formateNum = (num) =&gt; &#123;</span><br><span class=\"line\">  const numStr = num.toString();</span><br><span class=\"line\">  //替换小数点左边的数字</span><br><span class=\"line\">  return numStr.replace(/\\d+/, (match) =&gt; &#123;</span><br><span class=\"line\">    //替换目标数字为`$&#123;matchNum&#125;,`</span><br><span class=\"line\">    return match.replace(/(\\d)(?=(\\d&#123;3&#125;+$))/, (s1) =&gt; `$&#123;s1&#125;,`);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">formateNum(435345.656)</span><br><span class=\"line\">=&gt; &quot;435,345.656&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>22、</strong> HTML常见的内联元素和块级元素</p>\n<ul>\n<li><p>内联元素</p>\n<ul>\n<li>a</li>\n<li>img</li>\n<li>input</li>\n<li>label</li>\n<li>span</li>\n<li>br</li>\n<li>select</li>\n<li>strong</li>\n<li>textarea</li>\n</ul>\n</li>\n<li><p>块级元素</p>\n<ul>\n<li>div</li>\n<li>h1-h6</li>\n<li>form</li>\n<li>hr</li>\n<li>p</li>\n<li>ul</li>\n<li>table</li>\n<li>option</li>\n<li>li</li>\n</ul>\n</li>\n</ul>\n<p><strong>23、</strong> 移动开发中使用rem的优点</p>\n<p>rem是CSS3新增的一个单位即root em，它与em的区别在于em是相对父元素的font-size，而rem相对的是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。因此对于移动开发而言，只要通过媒体查询来根据不同的屏幕宽度设置<code>&lt;html&gt;</code>元素的字体大小，就可以适配不同的屏幕。</p>\n<p><strong>24、</strong> js模块化分哪些阶段</p>\n<ul>\n<li><p>无模块化</p>\n<p>js最初的作用只是进行表单验证或添加一些简单的动画，js文件通过<code>script</code>标签进行引用，没有模块化一说，随着前端复杂度提高想要引入更多的js文件就把多个<code>script</code>标签放在一起。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  　&lt;script src=&quot;script1.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">　　&lt;script src=&quot;script2.js&quot;&gt;&lt;/script&gt;</span><br><span class=\"line\">　　&lt;script src=&quot;script3.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>优点<br>相对于把所有逻辑放入一个文件，这种引入多个js文件实现简单模块化的思想是进步的。</li>\n<li>缺点<br>污染全局作用域，文件间依赖关系不明显。</li>\n</ul>\n</li>\n<li><p>CommonJS规范<br>CommonJS是一个JavaScript模块化规范，最初用于服务端的node。根据这个规范一个文件就是一个模块，其内部定义的变量函数只属于这个模块而不对外暴露。CommonJS通过export或module.exports来导出需要对外提供的接口，通过require方法来同步加载所要依赖的模块。</p>\n<ul>\n<li><p>模块定义</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// util.js</span><br><span class=\"line\">var x = 0;</span><br><span class=\"line\">var add = function (value) &#123;</span><br><span class=\"line\">  return value + x;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">module.exports.x = x;</span><br><span class=\"line\">module.exports.add = add;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>模块使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var util = require(./util.js); </span><br><span class=\"line\">console.log(util.x); // 0</span><br><span class=\"line\">console.log(util.add(1)); // 1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>优点<br>解决了全局污染及模块间依赖的问题</p>\n</li>\n<li>缺点<br>CommonJS为同步加载，在服务端因其文件都在本地，同步加载没有问题，但在浏览器端文件需要异步加载 CommonJS就不再适用了。</li>\n</ul>\n</li>\n<li><p>AMD规范<br>AMD(Asynchronous Module Definition)规范为异步加载模块，并允许指定回调函数，实现AMD规范的加载器JS主要有两个require.js 和 curl.js。<br>AMD标准中定义了两个API，define和require: </p>\n<ul>\n<li>模块定义: define(id, [depends], callback)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//math.js，定义了一个math模块</span><br><span class=\"line\">define(function () &#123;</span><br><span class=\"line\">  var add = function (x, y) &#123;</span><br><span class=\"line\">    return x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    add: add,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>模块使用: require([module], callback)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require([&apos;math&apos;], function (math)&#123;</span><br><span class=\"line\">  console.log(math.add(1,1));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>优点<br>适合在浏览器环境中异步加载模块，并可以并行加载多个模块。</p>\n</li>\n<li>缺点<br>提高了开发成本，且不能按需加载，而是必须提前加载所有的依赖。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>CMD规范<br>CMD(Common Module Definition)规范是seajs推崇的规范，与requirejs类似，其不同点在于其加载模式为按需加载。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">  var a = require(&apos;pdf.js&apos;);</span><br><span class=\"line\">  a.doSomething();</span><br><span class=\"line\">  // 依赖就近书写，什么时候用到什么时候引入</span><br><span class=\"line\">  var b = require(&apos;./b&apos;);</span><br><span class=\"line\">  b.doSomething();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>优点<br>实现了异步加载模块，并可以按需加载。</li>\n<li>缺点<br>依赖SPM打包，模块的加载逻辑偏重。</li>\n</ul>\n</li>\n<li><p>ES6模块化<br>前面的模块化方法都是社区自己实现的，而ES6的模块化方案是真正的规范。在ES6中通过import关键字引入模块，export关键字导出模块，目前浏览器尚不支持es6因此需要用babel将代码转换为广泛支持的require。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">import Counter from &apos;../counter&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">class Home extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;Counter /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Home;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><strong>25、</strong> 不用第三个变量，直接交换两个变量的值</p>\n<ul>\n<li>方法1: 利用技巧</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 5;</span><br><span class=\"line\">var b = 6;</span><br><span class=\"line\">a = a + b;</span><br><span class=\"line\">b = a - b;</span><br><span class=\"line\">a = a - b;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(a); // 6</span><br><span class=\"line\">console.log(b); // 5</span><br></pre></td></tr></table></figure>\n<ul>\n<li>方法2: 利用位运算<br>位运算当且仅当只有一个表达式的某位上为1时，结果的该位才为1。否则结果的该位为0。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  var a = 5; // 二进制101</span><br><span class=\"line\">  var b = 6; // 二进制110</span><br><span class=\"line\">  a = a^b;</span><br><span class=\"line\">=&gt; </span><br><span class=\"line\">  a = 101</span><br><span class=\"line\">      110</span><br><span class=\"line\">      ---</span><br><span class=\"line\">      011</span><br><span class=\"line\"></span><br><span class=\"line\">  b = a^b;</span><br><span class=\"line\"></span><br><span class=\"line\">=&gt;</span><br><span class=\"line\">  b = 011</span><br><span class=\"line\">      110</span><br><span class=\"line\">      ---</span><br><span class=\"line\">      101</span><br><span class=\"line\">  </span><br><span class=\"line\">  a = a^b;</span><br><span class=\"line\">=&gt;</span><br><span class=\"line\">  a = 011</span><br><span class=\"line\">      101</span><br><span class=\"line\">      ---</span><br><span class=\"line\">      110</span><br><span class=\"line\"></span><br><span class=\"line\">  console.log(a); // 6</span><br><span class=\"line\">  console.log(b); // 5</span><br></pre></td></tr></table></figure>\n<p><strong>26、</strong> CSS创建平移动画</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">width: 100px;</span><br><span class=\"line\">  height: 30px;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  background: blue;</span><br><span class=\"line\">  left: 0;</span><br><span class=\"line\">  top: 0;</span><br><span class=\"line\">  animation: move 3s ease infinite; </span><br><span class=\"line\"></span><br><span class=\"line\">  @keyframes move &#123;</span><br><span class=\"line\">    50% &#123;</span><br><span class=\"line\">      left: 100px;</span><br><span class=\"line\">      top: 100px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  或</span><br><span class=\"line\">  @keyframes move &#123;</span><br><span class=\"line\">    50% &#123;</span><br><span class=\"line\">      transform: translate(100px, 100px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><strong>27、</strong> js选择select下的option</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;select&gt;</span><br><span class=\"line\">  &lt;option value=&quot;option1&quot;&gt;1&lt;/option&gt;</span><br><span class=\"line\">  &lt;option value=&quot;option2&quot;&gt;2&lt;/option&gt;</span><br><span class=\"line\">&lt;/select&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">const selectNode = document.querySelector(&apos;select&apos;);</span><br><span class=\"line\">// 1.设置value的值等于option的value来选中option</span><br><span class=\"line\">selectNode.value = option2;</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.设置selectedIndex来选中option</span><br><span class=\"line\">selectNode.selectedIndex = 1;</span><br></pre></td></tr></table></figure>\n<p><strong>28、</strong> CSS实现超出部分内容显示<code>...</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  //需限制其宽度</span><br><span class=\"line\">  max-width: 100px;</span><br><span class=\"line\">  overflow: hidden;</span><br><span class=\"line\">  text-overflow: ellipsis;</span><br><span class=\"line\">  white-space: nowrap;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>29、</strong> CSS postion定位有哪几种情况</p>\n<ul>\n<li><p>static<br>static定位是默认的定位方式，元素出现在正常的文档流中，会忽略left、top、right、bottom以及z-index。</p>\n</li>\n<li><p>absolute<br>absolute定位即绝对定位，相对于除static定位元素的第一个父类元素进行定位，元素的位置通过left、top、right以及bottom 属性进行设置。</p>\n</li>\n<li><p>fixed<br>fixed定位即固定定位，类似于绝对定位，但它是相对于浏览器窗口进行定位的，元素的位置通过left、top、right以及bottom 属性进行设置。</p>\n</li>\n<li><p>relative<br>relative定位即相对定位，相对的参考位置为元素自身所在文档流的位置(static定位时的位置)，通过left、top、right以及bottom属性进行设置。相对定位虽然脱离了文档流，但计算其他元素在文档流中的位置时仍会以该元素正常的文档流位置进行计算，就好像元素还在原来的位置。</p>\n</li>\n<li><p>inherit<br>继承父类的postion值，不会继承其left、top、right及bottom值</p>\n</li>\n</ul>\n<p><strong>30、</strong> 内联元素和块级元素的区别</p>\n<p><strong>内联元素</strong></p>\n<ul>\n<li>和相邻的内联元素在同一行</li>\n<li>设置width和height无效</li>\n<li>margin上下无效，padding上下虽然可以设置，但并不会挤压其他元素的空间，在其他元素看来好像没有设置一样</li>\n</ul>\n<p><strong>块级元素</strong></p>\n<ul>\n<li>块级元素总是各占一行，垂直排列</li>\n<li>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可设置</li>\n</ul>\n<p>内联元素可以通过该变display属性进行转换，</p>\n<ul>\n<li><code>display:block</code>: 表现形式如块级元素</li>\n<li><code>display:inline</code>: 表现形式如内联元素</li>\n<li><code>display:inline-block</code>: 表现形式如内联元素和块级元素，具有block元素可以设置宽高的特性，同时又具有内联元素的不换行等特性</li>\n</ul>\n<p><strong>31、</strong> js判断一个变量是否是数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fuction isArray(obj) &#123;</span><br><span class=\"line\">  Object.prototype.toString().call(obj) === &quot;[object Array]&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">现代浏览器</span><br><span class=\"line\">Array.isArray(obj)</span><br></pre></td></tr></table></figure>\n<p><strong>32、</strong> JavaScript由哪三部分构成</p>\n<ul>\n<li>核心(ECMAScript)<br>ECMAScript仅仅是一个描述，定义了脚本语言所有的属性、方法和对象，其他语言可以实现 ECMAScript 来作为功能的基准</li>\n<li>文档对模型(DOM)<br>它是HTML和XML的应用程序接口，DOM将整个页面规划成由节点层级构成的文档，HTML或XML页面的每个部分都是一个节点的衍生物</li>\n<li>浏览器对象模型(BOM)<br>它提供了一种特性，可以对浏览器窗口进行访问和操作，使用BOM开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。</li>\n</ul>\n<p><strong>33、</strong> sql的注入原理及防范方法</p>\n<p>通常服务器端都会根据客户端的请求来动态构建sql执行语句，sql注入是通过将恶意的sql语句添加到应用的输入参数中，从而在sql服务器后台解析执行。<br>防范方法:</p>\n<ul>\n<li>sql语句预编译和绑定变量<br>sql执行命令必须先通过语法分析，生成执行计划，预编译后不管注入的参数是什么都不会再执行，而是当作字符串字面值进行处理。</li>\n<li>严格检查参数<br>只执行规定格式的参数可以避免部分的sql注入</li>\n<li>使用安全函数<br>安全函数将参数的特殊字符进行编码，这样sql引擎就不会将参数当成sql语句进行解析了。</li>\n</ul>\n<p><strong>34、</strong> JavaScript的垃圾回收机制</p>\n<p>JavaScript有自动垃圾回收机制，当然这并不意味着你不需要关心内存管理。<br>内存的生命周期大致分为内存的分配、内存的使用以及不需要时内存的释放。因此只要追踪内存的生命周期就能自动的对内存进行分配回收了，但是这并不容易，尤其要确定某块内存是否真的不需要了。因此，垃圾回收只能有限制的解决一般问题，主要有两种方法，引用计数和标记清除算法。</p>\n<ul>\n<li><p>引用计数法<br>在内存管理环境中，如果一个对象(包括函数作用域、全局词法作用域等)有访问另一个对象的权限，叫做一个对象访问另一个对象。当对象被引用的次数为0时就被回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &#123; v: 1 &#125;; // 对象&#123; v: 1 &#125;被变量a引用一次，引用计数为1</span><br><span class=\"line\">var b = a; // 同样，对象&#123; v: 1 &#125;被变量b引用一次，引用计数为2</span><br><span class=\"line\">a = null; // 对象引用次数减1</span><br><span class=\"line\">b = null;// 对象引用次数减1，此时引用计数为0，对象可以被释放</span><br></pre></td></tr></table></figure>\n<p>引用计数有一个潜在的问题，就是无法解决循环引用的问题。<br>如下，a、b互相引用，引用计数一直为1，导致不能自动回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f() &#123;</span><br><span class=\"line\">  var a = &#123;&#125;;</span><br><span class=\"line\">  var b = &#123;&#125;;</span><br><span class=\"line\">  a.value = b;</span><br><span class=\"line\">  b.value = a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>标记清除算法</p>\n<p>这个算法假定有一个叫跟(root)的对象(js中为window， node js为global)，垃圾回收器定期从根开始，找所有从根开始引用的对象，然后找这些引用对象引用的对象…将这些对象标记为active，其他的不能被根引用或间接引用的将被标记为garbage，最终将这些垃圾清除。<br>循环引用将不再是问题，上例中函数f执行完后，全局window就无法访问到对象a和b了，因此对象a、b将会被回收。<br><center><img src=\"/images/mark_sweep.gif\" alt=\"标记清除意图]\"><center><br><center>标记清除意图 <center></center></center></center></center></p>\n</li>\n</ul>\n"},{"layout":"post","title":"伪类与伪元素的区别","tagline":"Supporting tagline","description":"在React应用的开发中遵循一定的基本准则，能使代码更加友好，提高代码质量。","date":"2017-06-20T12:10:07.000Z","_content":"\n### **伪类(pseudo-classes)**\n\n官方定义:\n> The pseudo-class concept is introduced to <font color=#0099ff>permit selection</font> based on information that lies <font color=#0099ff>outside of the document</font> tree or that cannot be expressed using the other <font color=#0099ff>simple selectors</font>.\n\n其核心就是用来选择那些<font color=#0099ff>不能够被普通选择器选择</font>的文档之外的元素，比如:hover。\n\n\n### **伪元素(Pseudo-elements)**\n\n官方定义:\n> Pseudo-elements <font color=#0099ff>create abstractions</font> about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document.\n\n其核心就是需要<font color=#0099ff>创建</font>通常不存在于文档中的元素，比如::before。\n\n\n### **伪类与伪元素的区别**\n\n- 表示方法\n  CSS2中伪类、伪元素都是以单冒号`:`表示，CSS2.1后规定伪类用单冒号表示，伪元素用双冒号`::`表示，浏览器同样接受CSS2时代已经存在的伪元素(:before, :after, :first-line, :first-letter等)的单冒号写法。对于CSS2之后所有新增的伪元素(如::selection)，须采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。\n\n- 定义不同\n  \n  伪类即假的类，可以通过添加类来达到效果，伪元素即假元素可以通过添加元素来达到效果。\n  来看下面的例子\n  **例1:将一行字符串的首字母变成红色**\n\n  现在不用伪元素应该如何实现？用CSS slector选择？想了一晚上也没想出来，既然没法选择也就没法添加一个类来改变首字母的颜色。\n  ```\n  <p>I am snow</p>\n  ```\n  添加元素试试，如下创建一个元素span将首字母包裹起来，进而改变其颜色，成功了。这里，关键点在于我们创建了新的元素达到了`::first-letter`的作用，且不能通过类来实现这一效果，因此将`::first-letter`叫做伪元素而不是伪类。\n  ```\n    <p><span style={{ color: red }}>I<span/> am snow</p>\n  ```\n\n  **例2: 如下要将I am snow这句话变为红色**\n  \n  很简单用`:first-child`，同样添加一个类试试，显然很容易达到同样效果，我们并没有创建新的元素只是添加了一个类，因此将`:first-child`叫做伪类而不是伪元素，尽管它和`::first-letter`在语义上十分相似。\n   ```\n   div:first-child {\n    color: red;\n   }\n   或\n   .red-line {\n      color: red;\n   }\n\n   <div class='red-line'>\n    <p>I am snow</p>\n   <div>\n\n\n  ```\n\n  ","source":"_posts/伪类与伪元素的区别.md","raw":"---\nlayout: post\ntitle: 伪类与伪元素的区别\ncategory : react\ntagline: \"Supporting tagline\"\ntags : [react]\ndescription: 在React应用的开发中遵循一定的基本准则，能使代码更加友好，提高代码质量。\ndate: 2017-6-20 20:10:07\n---\n\n### **伪类(pseudo-classes)**\n\n官方定义:\n> The pseudo-class concept is introduced to <font color=#0099ff>permit selection</font> based on information that lies <font color=#0099ff>outside of the document</font> tree or that cannot be expressed using the other <font color=#0099ff>simple selectors</font>.\n\n其核心就是用来选择那些<font color=#0099ff>不能够被普通选择器选择</font>的文档之外的元素，比如:hover。\n\n\n### **伪元素(Pseudo-elements)**\n\n官方定义:\n> Pseudo-elements <font color=#0099ff>create abstractions</font> about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document.\n\n其核心就是需要<font color=#0099ff>创建</font>通常不存在于文档中的元素，比如::before。\n\n\n### **伪类与伪元素的区别**\n\n- 表示方法\n  CSS2中伪类、伪元素都是以单冒号`:`表示，CSS2.1后规定伪类用单冒号表示，伪元素用双冒号`::`表示，浏览器同样接受CSS2时代已经存在的伪元素(:before, :after, :first-line, :first-letter等)的单冒号写法。对于CSS2之后所有新增的伪元素(如::selection)，须采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。\n\n- 定义不同\n  \n  伪类即假的类，可以通过添加类来达到效果，伪元素即假元素可以通过添加元素来达到效果。\n  来看下面的例子\n  **例1:将一行字符串的首字母变成红色**\n\n  现在不用伪元素应该如何实现？用CSS slector选择？想了一晚上也没想出来，既然没法选择也就没法添加一个类来改变首字母的颜色。\n  ```\n  <p>I am snow</p>\n  ```\n  添加元素试试，如下创建一个元素span将首字母包裹起来，进而改变其颜色，成功了。这里，关键点在于我们创建了新的元素达到了`::first-letter`的作用，且不能通过类来实现这一效果，因此将`::first-letter`叫做伪元素而不是伪类。\n  ```\n    <p><span style={{ color: red }}>I<span/> am snow</p>\n  ```\n\n  **例2: 如下要将I am snow这句话变为红色**\n  \n  很简单用`:first-child`，同样添加一个类试试，显然很容易达到同样效果，我们并没有创建新的元素只是添加了一个类，因此将`:first-child`叫做伪类而不是伪元素，尽管它和`::first-letter`在语义上十分相似。\n   ```\n   div:first-child {\n    color: red;\n   }\n   或\n   .red-line {\n      color: red;\n   }\n\n   <div class='red-line'>\n    <p>I am snow</p>\n   <div>\n\n\n  ```\n\n  ","slug":"伪类与伪元素的区别","published":1,"updated":"2019-01-04T06:59:22.371Z","comments":1,"photos":[],"link":"","_id":"cjqlyakk700013w0rg3cyqipb","content":"<h3 id=\"伪类-pseudo-classes\"><a href=\"#伪类-pseudo-classes\" class=\"headerlink\" title=\"伪类(pseudo-classes)\"></a><strong>伪类(pseudo-classes)</strong></h3><p>官方定义:</p>\n<blockquote>\n<p>The pseudo-class concept is introduced to <font color=\"#0099ff\">permit selection</font> based on information that lies <font color=\"#0099ff\">outside of the document</font> tree or that cannot be expressed using the other <font color=\"#0099ff\">simple selectors</font>.</p>\n</blockquote>\n<p>其核心就是用来选择那些<font color=\"#0099ff\">不能够被普通选择器选择</font>的文档之外的元素，比如:hover。</p>\n<h3 id=\"伪元素-Pseudo-elements\"><a href=\"#伪元素-Pseudo-elements\" class=\"headerlink\" title=\"伪元素(Pseudo-elements)\"></a><strong>伪元素(Pseudo-elements)</strong></h3><p>官方定义:</p>\n<blockquote>\n<p>Pseudo-elements <font color=\"#0099ff\">create abstractions</font> about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document.</p>\n</blockquote>\n<p>其核心就是需要<font color=\"#0099ff\">创建</font>通常不存在于文档中的元素，比如::before。</p>\n<h3 id=\"伪类与伪元素的区别\"><a href=\"#伪类与伪元素的区别\" class=\"headerlink\" title=\"伪类与伪元素的区别\"></a><strong>伪类与伪元素的区别</strong></h3><ul>\n<li><p>表示方法<br>CSS2中伪类、伪元素都是以单冒号<code>:</code>表示，CSS2.1后规定伪类用单冒号表示，伪元素用双冒号<code>::</code>表示，浏览器同样接受CSS2时代已经存在的伪元素(:before, :after, :first-line, :first-letter等)的单冒号写法。对于CSS2之后所有新增的伪元素(如::selection)，须采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。</p>\n</li>\n<li><p>定义不同</p>\n<p>伪类即假的类，可以通过添加类来达到效果，伪元素即假元素可以通过添加元素来达到效果。<br>来看下面的例子<br><strong>例1:将一行字符串的首字母变成红色</strong></p>\n<p>现在不用伪元素应该如何实现？用CSS slector选择？想了一晚上也没想出来，既然没法选择也就没法添加一个类来改变首字母的颜色。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I am snow&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>添加元素试试，如下创建一个元素span将首字母包裹起来，进而改变其颜色，成功了。这里，关键点在于我们创建了新的元素达到了<code>::first-letter</code>的作用，且不能通过类来实现这一效果，因此将<code>::first-letter</code>叫做伪元素而不是伪类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&lt;span style=&#123;&#123; color: red &#125;&#125;&gt;I&lt;span/&gt; am snow&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>例2: 如下要将I am snow这句话变为红色</strong></p>\n<p>很简单用<code>:first-child</code>，同样添加一个类试试，显然很容易达到同样效果，我们并没有创建新的元素只是添加了一个类，因此将<code>:first-child</code>叫做伪类而不是伪元素，尽管它和<code>::first-letter</code>在语义上十分相似。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div:first-child &#123;</span><br><span class=\"line\"> color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或</span><br><span class=\"line\">.red-line &#123;</span><br><span class=\"line\">   color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&apos;red-line&apos;&gt;</span><br><span class=\"line\"> &lt;p&gt;I am snow&lt;/p&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"伪类-pseudo-classes\"><a href=\"#伪类-pseudo-classes\" class=\"headerlink\" title=\"伪类(pseudo-classes)\"></a><strong>伪类(pseudo-classes)</strong></h3><p>官方定义:</p>\n<blockquote>\n<p>The pseudo-class concept is introduced to <font color=\"#0099ff\">permit selection</font> based on information that lies <font color=\"#0099ff\">outside of the document</font> tree or that cannot be expressed using the other <font color=\"#0099ff\">simple selectors</font>.</p>\n</blockquote>\n<p>其核心就是用来选择那些<font color=\"#0099ff\">不能够被普通选择器选择</font>的文档之外的元素，比如:hover。</p>\n<h3 id=\"伪元素-Pseudo-elements\"><a href=\"#伪元素-Pseudo-elements\" class=\"headerlink\" title=\"伪元素(Pseudo-elements)\"></a><strong>伪元素(Pseudo-elements)</strong></h3><p>官方定义:</p>\n<blockquote>\n<p>Pseudo-elements <font color=\"#0099ff\">create abstractions</font> about the document tree beyond those specified by the document language. For instance, document languages do not offer mechanisms to access the first letter or first line of an element’s content. Pseudo-elements allow authors to refer to this otherwise inaccessible information. Pseudo-elements may also provide authors a way to refer to content that does not exist in the source document.</p>\n</blockquote>\n<p>其核心就是需要<font color=\"#0099ff\">创建</font>通常不存在于文档中的元素，比如::before。</p>\n<h3 id=\"伪类与伪元素的区别\"><a href=\"#伪类与伪元素的区别\" class=\"headerlink\" title=\"伪类与伪元素的区别\"></a><strong>伪类与伪元素的区别</strong></h3><ul>\n<li><p>表示方法<br>CSS2中伪类、伪元素都是以单冒号<code>:</code>表示，CSS2.1后规定伪类用单冒号表示，伪元素用双冒号<code>::</code>表示，浏览器同样接受CSS2时代已经存在的伪元素(:before, :after, :first-line, :first-letter等)的单冒号写法。对于CSS2之后所有新增的伪元素(如::selection)，须采用双冒号的写法。但是因为兼容性问题，大部分还是用的单冒号。</p>\n</li>\n<li><p>定义不同</p>\n<p>伪类即假的类，可以通过添加类来达到效果，伪元素即假元素可以通过添加元素来达到效果。<br>来看下面的例子<br><strong>例1:将一行字符串的首字母变成红色</strong></p>\n<p>现在不用伪元素应该如何实现？用CSS slector选择？想了一晚上也没想出来，既然没法选择也就没法添加一个类来改变首字母的颜色。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;I am snow&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p>添加元素试试，如下创建一个元素span将首字母包裹起来，进而改变其颜色，成功了。这里，关键点在于我们创建了新的元素达到了<code>::first-letter</code>的作用，且不能通过类来实现这一效果，因此将<code>::first-letter</code>叫做伪元素而不是伪类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;p&gt;&lt;span style=&#123;&#123; color: red &#125;&#125;&gt;I&lt;span/&gt; am snow&lt;/p&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>例2: 如下要将I am snow这句话变为红色</strong></p>\n<p>很简单用<code>:first-child</code>，同样添加一个类试试，显然很容易达到同样效果，我们并没有创建新的元素只是添加了一个类，因此将<code>:first-child</code>叫做伪类而不是伪元素，尽管它和<code>::first-letter</code>在语义上十分相似。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">div:first-child &#123;</span><br><span class=\"line\"> color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">或</span><br><span class=\"line\">.red-line &#123;</span><br><span class=\"line\">   color: red;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;div class=&apos;red-line&apos;&gt;</span><br><span class=\"line\"> &lt;p&gt;I am snow&lt;/p&gt;</span><br><span class=\"line\">&lt;div&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"layout":"post","title":"nginx基本配置及常用命令","tagline":"Supporting tagline","description":"最近自己搭建了一个网站，并准备用nginx作为服务器，于是搜索了nginx的配置。nginx可配置项很多，由于该网站只是个人使用，只是简单进行了配置，在这里作一个记录。","date":"2017-10-11T10:10:20.000Z","_content":"\n\n### **基本配置** \n\n```\n### nginx.conf\n########### 每个指令必须有分号结束。#################\n\n #配置运行nginx用户或用户组\nuser root;   \n#允许生成的进程数，默认为1\nworker_processes 2; \n#制定错误日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emerg\nerror_log log/error.log debug; \n\nevents {\n#设置网路连接序列化，防止惊群现象发生，默认为on\n   accept_mutex on; \n#设置一个进程是否同时接受多个网络连接，默认为off\n   multi_accept on; \n#事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport\n#use epoll; \n#单个work进程允许的最大连接数，默认为512\n   worker_connections 1024; \n}\n\n#http服务器\nhttp {\n#文件扩展名与文件类型映射表。设定mime类型(邮件支持类型),类型由mime.types文件定义\n#include /usr/local/etc/nginx/conf/mime.types;\n   include mime.types; \n#默认文件类型，默认为text/plain\n   default_type application/octet-stream; \n\n#自定义日志格式\n   log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; \n#设置访问日志路径和格式。\"log/\"该路径为nginx日志的相对路径，mac下是/usr/local/var/log/。combined为日志格式的默认值\n   access_log log/access.log myFormat; \n   rewrite_log on;\n\n#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。（sendfile系统调用不需要将数据拷贝或者映射到应用程序地址空间中去）\n   sendfile on; \n#将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞\n   tcp_nopush on;\n   tcp_nodelay on;\n#连接超时时间，默认为75s，可以在http，server，location块。\n   keepalive_timeout 65; \n\n#gzip压缩开关\n   gzip on;\n\n#error_page 404 https://www.baidu.com; #错误页\n\n#HTTP服务器\n\n# 静态资源一般放在nginx所在主机\n   server {\n       listen 8080; #监听HTTP端口\n       server_name localhost 149.28.211.15; #监听地址  \n       keepalive_requests 120; #单连接请求上限次数\n       root /root/www;\n       index index.html;  #定义首页索引文件的名称\n       location / { \n          root /root/www; #静态资源根目录\n          index index.html;\n       } \n       location /fancybook {\n          alias /root/www/fancybook;\n          index index.html;\n       }\n   }\n} \n```\n\n### **常用命令** \n\n```\n1）启动nginx\n$ service nginx start\n\n2）停止nginx\n$ nginx -s stop\n\n3）不停止nginx重启\n$ nginx -s reload\n\n4）测试nginx.conf文件配置是否正确\n$ nginx -t\n\n5）查看nginx版本\n$ nginx -v\n\n6）查看nginx进程\n$ ps -ef | grep nginx\n\n```","source":"_posts/10.nginx基本配置及常用命令.md","raw":"---\nlayout: post\ntitle: nginx基本配置及常用命令\ncategory : server\ntagline: \"Supporting tagline\"\ntags : [server]\ndescription: 最近自己搭建了一个网站，并准备用nginx作为服务器，于是搜索了nginx的配置。nginx可配置项很多，由于该网站只是个人使用，只是简单进行了配置，在这里作一个记录。\ndate: 2017-10-11 18:10:20\n---\n\n\n### **基本配置** \n\n```\n### nginx.conf\n########### 每个指令必须有分号结束。#################\n\n #配置运行nginx用户或用户组\nuser root;   \n#允许生成的进程数，默认为1\nworker_processes 2; \n#制定错误日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emerg\nerror_log log/error.log debug; \n\nevents {\n#设置网路连接序列化，防止惊群现象发生，默认为on\n   accept_mutex on; \n#设置一个进程是否同时接受多个网络连接，默认为off\n   multi_accept on; \n#事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport\n#use epoll; \n#单个work进程允许的最大连接数，默认为512\n   worker_connections 1024; \n}\n\n#http服务器\nhttp {\n#文件扩展名与文件类型映射表。设定mime类型(邮件支持类型),类型由mime.types文件定义\n#include /usr/local/etc/nginx/conf/mime.types;\n   include mime.types; \n#默认文件类型，默认为text/plain\n   default_type application/octet-stream; \n\n#自定义日志格式\n   log_format myFormat '$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for'; \n#设置访问日志路径和格式。\"log/\"该路径为nginx日志的相对路径，mac下是/usr/local/var/log/。combined为日志格式的默认值\n   access_log log/access.log myFormat; \n   rewrite_log on;\n\n#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。（sendfile系统调用不需要将数据拷贝或者映射到应用程序地址空间中去）\n   sendfile on; \n#将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞\n   tcp_nopush on;\n   tcp_nodelay on;\n#连接超时时间，默认为75s，可以在http，server，location块。\n   keepalive_timeout 65; \n\n#gzip压缩开关\n   gzip on;\n\n#error_page 404 https://www.baidu.com; #错误页\n\n#HTTP服务器\n\n# 静态资源一般放在nginx所在主机\n   server {\n       listen 8080; #监听HTTP端口\n       server_name localhost 149.28.211.15; #监听地址  \n       keepalive_requests 120; #单连接请求上限次数\n       root /root/www;\n       index index.html;  #定义首页索引文件的名称\n       location / { \n          root /root/www; #静态资源根目录\n          index index.html;\n       } \n       location /fancybook {\n          alias /root/www/fancybook;\n          index index.html;\n       }\n   }\n} \n```\n\n### **常用命令** \n\n```\n1）启动nginx\n$ service nginx start\n\n2）停止nginx\n$ nginx -s stop\n\n3）不停止nginx重启\n$ nginx -s reload\n\n4）测试nginx.conf文件配置是否正确\n$ nginx -t\n\n5）查看nginx版本\n$ nginx -v\n\n6）查看nginx进程\n$ ps -ef | grep nginx\n\n```","slug":"10.nginx基本配置及常用命令","published":1,"updated":"2019-01-07T06:52:28.300Z","_id":"cjqlyr9wx00094a0r5mj8j4v2","comments":1,"photos":[],"link":"","content":"<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a><strong>基本配置</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### nginx.conf</span><br><span class=\"line\">########### 每个指令必须有分号结束。#################</span><br><span class=\"line\"></span><br><span class=\"line\"> #配置运行nginx用户或用户组</span><br><span class=\"line\">user root;   </span><br><span class=\"line\">#允许生成的进程数，默认为1</span><br><span class=\"line\">worker_processes 2; </span><br><span class=\"line\">#制定错误日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class=\"line\">error_log log/error.log debug; </span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">#设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class=\"line\">   accept_mutex on; </span><br><span class=\"line\">#设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class=\"line\">   multi_accept on; </span><br><span class=\"line\">#事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class=\"line\">#use epoll; </span><br><span class=\"line\">#单个work进程允许的最大连接数，默认为512</span><br><span class=\"line\">   worker_connections 1024; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#http服务器</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">#文件扩展名与文件类型映射表。设定mime类型(邮件支持类型),类型由mime.types文件定义</span><br><span class=\"line\">#include /usr/local/etc/nginx/conf/mime.types;</span><br><span class=\"line\">   include mime.types; </span><br><span class=\"line\">#默认文件类型，默认为text/plain</span><br><span class=\"line\">   default_type application/octet-stream; </span><br><span class=\"line\"></span><br><span class=\"line\">#自定义日志格式</span><br><span class=\"line\">   log_format myFormat &apos;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&apos;; </span><br><span class=\"line\">#设置访问日志路径和格式。&quot;log/&quot;该路径为nginx日志的相对路径，mac下是/usr/local/var/log/。combined为日志格式的默认值</span><br><span class=\"line\">   access_log log/access.log myFormat; </span><br><span class=\"line\">   rewrite_log on;</span><br><span class=\"line\"></span><br><span class=\"line\">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。（sendfile系统调用不需要将数据拷贝或者映射到应用程序地址空间中去）</span><br><span class=\"line\">   sendfile on; </span><br><span class=\"line\">#将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞</span><br><span class=\"line\">   tcp_nopush on;</span><br><span class=\"line\">   tcp_nodelay on;</span><br><span class=\"line\">#连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class=\"line\">   keepalive_timeout 65; </span><br><span class=\"line\"></span><br><span class=\"line\">#gzip压缩开关</span><br><span class=\"line\">   gzip on;</span><br><span class=\"line\"></span><br><span class=\"line\">#error_page 404 https://www.baidu.com; #错误页</span><br><span class=\"line\"></span><br><span class=\"line\">#HTTP服务器</span><br><span class=\"line\"></span><br><span class=\"line\"># 静态资源一般放在nginx所在主机</span><br><span class=\"line\">   server &#123;</span><br><span class=\"line\">       listen 8080; #监听HTTP端口</span><br><span class=\"line\">       server_name localhost 149.28.211.15; #监听地址  </span><br><span class=\"line\">       keepalive_requests 120; #单连接请求上限次数</span><br><span class=\"line\">       root /root/www;</span><br><span class=\"line\">       index index.html;  #定义首页索引文件的名称</span><br><span class=\"line\">       location / &#123; </span><br><span class=\"line\">          root /root/www; #静态资源根目录</span><br><span class=\"line\">          index index.html;</span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">       location /fancybook &#123;</span><br><span class=\"line\">          alias /root/www/fancybook;</span><br><span class=\"line\">          index index.html;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a><strong>常用命令</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）启动nginx</span><br><span class=\"line\">$ service nginx start</span><br><span class=\"line\"></span><br><span class=\"line\">2）停止nginx</span><br><span class=\"line\">$ nginx -s stop</span><br><span class=\"line\"></span><br><span class=\"line\">3）不停止nginx重启</span><br><span class=\"line\">$ nginx -s reload</span><br><span class=\"line\"></span><br><span class=\"line\">4）测试nginx.conf文件配置是否正确</span><br><span class=\"line\">$ nginx -t</span><br><span class=\"line\"></span><br><span class=\"line\">5）查看nginx版本</span><br><span class=\"line\">$ nginx -v</span><br><span class=\"line\"></span><br><span class=\"line\">6）查看nginx进程</span><br><span class=\"line\">$ ps -ef | grep nginx</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a><strong>基本配置</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### nginx.conf</span><br><span class=\"line\">########### 每个指令必须有分号结束。#################</span><br><span class=\"line\"></span><br><span class=\"line\"> #配置运行nginx用户或用户组</span><br><span class=\"line\">user root;   </span><br><span class=\"line\">#允许生成的进程数，默认为1</span><br><span class=\"line\">worker_processes 2; </span><br><span class=\"line\">#制定错误日志路径，级别。这个设置可以放入全局块，http块，server块，级别依次为：debug|info|notice|warn|error|crit|alert|emerg</span><br><span class=\"line\">error_log log/error.log debug; </span><br><span class=\"line\"></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">#设置网路连接序列化，防止惊群现象发生，默认为on</span><br><span class=\"line\">   accept_mutex on; </span><br><span class=\"line\">#设置一个进程是否同时接受多个网络连接，默认为off</span><br><span class=\"line\">   multi_accept on; </span><br><span class=\"line\">#事件驱动模型，select|poll|kqueue|epoll|resig|/dev/poll|eventport</span><br><span class=\"line\">#use epoll; </span><br><span class=\"line\">#单个work进程允许的最大连接数，默认为512</span><br><span class=\"line\">   worker_connections 1024; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">#http服务器</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">#文件扩展名与文件类型映射表。设定mime类型(邮件支持类型),类型由mime.types文件定义</span><br><span class=\"line\">#include /usr/local/etc/nginx/conf/mime.types;</span><br><span class=\"line\">   include mime.types; </span><br><span class=\"line\">#默认文件类型，默认为text/plain</span><br><span class=\"line\">   default_type application/octet-stream; </span><br><span class=\"line\"></span><br><span class=\"line\">#自定义日志格式</span><br><span class=\"line\">   log_format myFormat &apos;$remote_addr–$remote_user [$time_local] $request $status $body_bytes_sent $http_referer $http_user_agent $http_x_forwarded_for&apos;; </span><br><span class=\"line\">#设置访问日志路径和格式。&quot;log/&quot;该路径为nginx日志的相对路径，mac下是/usr/local/var/log/。combined为日志格式的默认值</span><br><span class=\"line\">   access_log log/access.log myFormat; </span><br><span class=\"line\">   rewrite_log on;</span><br><span class=\"line\"></span><br><span class=\"line\">#允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。（sendfile系统调用不需要将数据拷贝或者映射到应用程序地址空间中去）</span><br><span class=\"line\">   sendfile on; </span><br><span class=\"line\">#将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞</span><br><span class=\"line\">   tcp_nopush on;</span><br><span class=\"line\">   tcp_nodelay on;</span><br><span class=\"line\">#连接超时时间，默认为75s，可以在http，server，location块。</span><br><span class=\"line\">   keepalive_timeout 65; </span><br><span class=\"line\"></span><br><span class=\"line\">#gzip压缩开关</span><br><span class=\"line\">   gzip on;</span><br><span class=\"line\"></span><br><span class=\"line\">#error_page 404 https://www.baidu.com; #错误页</span><br><span class=\"line\"></span><br><span class=\"line\">#HTTP服务器</span><br><span class=\"line\"></span><br><span class=\"line\"># 静态资源一般放在nginx所在主机</span><br><span class=\"line\">   server &#123;</span><br><span class=\"line\">       listen 8080; #监听HTTP端口</span><br><span class=\"line\">       server_name localhost 149.28.211.15; #监听地址  </span><br><span class=\"line\">       keepalive_requests 120; #单连接请求上限次数</span><br><span class=\"line\">       root /root/www;</span><br><span class=\"line\">       index index.html;  #定义首页索引文件的名称</span><br><span class=\"line\">       location / &#123; </span><br><span class=\"line\">          root /root/www; #静态资源根目录</span><br><span class=\"line\">          index index.html;</span><br><span class=\"line\">       &#125; </span><br><span class=\"line\">       location /fancybook &#123;</span><br><span class=\"line\">          alias /root/www/fancybook;</span><br><span class=\"line\">          index index.html;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a><strong>常用命令</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1）启动nginx</span><br><span class=\"line\">$ service nginx start</span><br><span class=\"line\"></span><br><span class=\"line\">2）停止nginx</span><br><span class=\"line\">$ nginx -s stop</span><br><span class=\"line\"></span><br><span class=\"line\">3）不停止nginx重启</span><br><span class=\"line\">$ nginx -s reload</span><br><span class=\"line\"></span><br><span class=\"line\">4）测试nginx.conf文件配置是否正确</span><br><span class=\"line\">$ nginx -t</span><br><span class=\"line\"></span><br><span class=\"line\">5）查看nginx版本</span><br><span class=\"line\">$ nginx -v</span><br><span class=\"line\"></span><br><span class=\"line\">6）查看nginx进程</span><br><span class=\"line\">$ ps -ef | grep nginx</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"JS常用方法","tagline":"Supporting tagline","description":null,"date":"2016-06-05T10:10:20.000Z","_content":"\n\n### **取整函数**\n\n- 向上取整: Math.ceil():\n- 向下取整: Math.floor():\n- 四舍五入: Math.round():\n\n### **生成随机数**\n\n- 产生[m, n]的随机整数\n  ```\n  // Math.random产生[0, 1)的随机数\n  const random = (m, n) => Math.ceil(Math.random() * (n - m)) + m;\n  ```\n\n- 产生(m, n]的随机整数\n  \n  ```\n  const random = (m, n) => {\n    const value = Math.random();\n    return value === 0 ? m + 1 : Math.ceil(value * (n - m)) + m;\n  }\n  ```\n\n- 产生[m, n)的随机整数\n  \n  ```\n  const random = (m, n) => Math.floor(Math.random() * (n - m)) + m;\n  ```\n\n- 产生(m, n)的随机整数\n  \n  ```\n    const random = (m, n) => {\n      const value = Math.floor(Math.random() * (n - m));\n      return value === 0 ? m + 1 : value + m;\n    }\n  ```\n\n### **快速排序法**\n\n```\nconst quickSort = (arr) => {\n  if (arr.length <= 1) return arr;\n  const pivotIndex = Math.floor(arr.length / 2);\n  const pivot = arr.splice(pivotIndex, 1);\n  const left = [];\n  const right = [];\n\n  for(let i = 0; i< arr.length; i++) {\n    const value = arr[i];\n    if (value < pivot) {\n      left.push(value);\n    } else {\n      right.push(value);\n    }\n  }\n\n  return quickSort(left).concat(pivot, quickSort(right));\n}\n```","source":"_posts/JS常用方法.md","raw":"\n---\nlayout: post\ntitle: JS常用方法\ncategory : js\ntagline: \"Supporting tagline\"\ntags : [js]\ndescription: \ndate: 2016-6-05 18:10:20\n---\n\n\n### **取整函数**\n\n- 向上取整: Math.ceil():\n- 向下取整: Math.floor():\n- 四舍五入: Math.round():\n\n### **生成随机数**\n\n- 产生[m, n]的随机整数\n  ```\n  // Math.random产生[0, 1)的随机数\n  const random = (m, n) => Math.ceil(Math.random() * (n - m)) + m;\n  ```\n\n- 产生(m, n]的随机整数\n  \n  ```\n  const random = (m, n) => {\n    const value = Math.random();\n    return value === 0 ? m + 1 : Math.ceil(value * (n - m)) + m;\n  }\n  ```\n\n- 产生[m, n)的随机整数\n  \n  ```\n  const random = (m, n) => Math.floor(Math.random() * (n - m)) + m;\n  ```\n\n- 产生(m, n)的随机整数\n  \n  ```\n    const random = (m, n) => {\n      const value = Math.floor(Math.random() * (n - m));\n      return value === 0 ? m + 1 : value + m;\n    }\n  ```\n\n### **快速排序法**\n\n```\nconst quickSort = (arr) => {\n  if (arr.length <= 1) return arr;\n  const pivotIndex = Math.floor(arr.length / 2);\n  const pivot = arr.splice(pivotIndex, 1);\n  const left = [];\n  const right = [];\n\n  for(let i = 0; i< arr.length; i++) {\n    const value = arr[i];\n    if (value < pivot) {\n      left.push(value);\n    } else {\n      right.push(value);\n    }\n  }\n\n  return quickSort(left).concat(pivot, quickSort(right));\n}\n```","slug":"JS常用方法","published":1,"updated":"2019-01-07T06:55:44.953Z","comments":1,"photos":[],"link":"","_id":"cjqlz47jc0000d10ru25q7p8g","content":"<h3 id=\"取整函数\"><a href=\"#取整函数\" class=\"headerlink\" title=\"取整函数\"></a><strong>取整函数</strong></h3><ul>\n<li>向上取整: Math.ceil():</li>\n<li>向下取整: Math.floor():</li>\n<li>四舍五入: Math.round():</li>\n</ul>\n<h3 id=\"生成随机数\"><a href=\"#生成随机数\" class=\"headerlink\" title=\"生成随机数\"></a><strong>生成随机数</strong></h3><ul>\n<li><p>产生[m, n]的随机整数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Math.random产生[0, 1)的随机数</span><br><span class=\"line\">const random = (m, n) =&gt; Math.ceil(Math.random() * (n - m)) + m;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生(m, n]的随机整数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const random = (m, n) =&gt; &#123;</span><br><span class=\"line\">  const value = Math.random();</span><br><span class=\"line\">  return value === 0 ? m + 1 : Math.ceil(value * (n - m)) + m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生[m, n)的随机整数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const random = (m, n) =&gt; Math.floor(Math.random() * (n - m)) + m;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生(m, n)的随机整数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const random = (m, n) =&gt; &#123;</span><br><span class=\"line\">  const value = Math.floor(Math.random() * (n - m));</span><br><span class=\"line\">  return value === 0 ? m + 1 : value + m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"快速排序法\"><a href=\"#快速排序法\" class=\"headerlink\" title=\"快速排序法\"></a><strong>快速排序法</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const quickSort = (arr) =&gt; &#123;</span><br><span class=\"line\">  if (arr.length &lt;= 1) return arr;</span><br><span class=\"line\">  const pivotIndex = Math.floor(arr.length / 2);</span><br><span class=\"line\">  const pivot = arr.splice(pivotIndex, 1);</span><br><span class=\"line\">  const left = [];</span><br><span class=\"line\">  const right = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  for(let i = 0; i&lt; arr.length; i++) &#123;</span><br><span class=\"line\">    const value = arr[i];</span><br><span class=\"line\">    if (value &lt; pivot) &#123;</span><br><span class=\"line\">      left.push(value);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      right.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return quickSort(left).concat(pivot, quickSort(right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"取整函数\"><a href=\"#取整函数\" class=\"headerlink\" title=\"取整函数\"></a><strong>取整函数</strong></h3><ul>\n<li>向上取整: Math.ceil():</li>\n<li>向下取整: Math.floor():</li>\n<li>四舍五入: Math.round():</li>\n</ul>\n<h3 id=\"生成随机数\"><a href=\"#生成随机数\" class=\"headerlink\" title=\"生成随机数\"></a><strong>生成随机数</strong></h3><ul>\n<li><p>产生[m, n]的随机整数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Math.random产生[0, 1)的随机数</span><br><span class=\"line\">const random = (m, n) =&gt; Math.ceil(Math.random() * (n - m)) + m;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生(m, n]的随机整数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const random = (m, n) =&gt; &#123;</span><br><span class=\"line\">  const value = Math.random();</span><br><span class=\"line\">  return value === 0 ? m + 1 : Math.ceil(value * (n - m)) + m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生[m, n)的随机整数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const random = (m, n) =&gt; Math.floor(Math.random() * (n - m)) + m;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>产生(m, n)的随机整数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const random = (m, n) =&gt; &#123;</span><br><span class=\"line\">  const value = Math.floor(Math.random() * (n - m));</span><br><span class=\"line\">  return value === 0 ? m + 1 : value + m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"快速排序法\"><a href=\"#快速排序法\" class=\"headerlink\" title=\"快速排序法\"></a><strong>快速排序法</strong></h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const quickSort = (arr) =&gt; &#123;</span><br><span class=\"line\">  if (arr.length &lt;= 1) return arr;</span><br><span class=\"line\">  const pivotIndex = Math.floor(arr.length / 2);</span><br><span class=\"line\">  const pivot = arr.splice(pivotIndex, 1);</span><br><span class=\"line\">  const left = [];</span><br><span class=\"line\">  const right = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  for(let i = 0; i&lt; arr.length; i++) &#123;</span><br><span class=\"line\">    const value = arr[i];</span><br><span class=\"line\">    if (value &lt; pivot) &#123;</span><br><span class=\"line\">      left.push(value);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      right.push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return quickSort(left).concat(pivot, quickSort(right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjq5aqcs60002dsztxw50b0y2","category_id":"cjq5aqcse0008dsztab1j56j7","_id":"cjq5aqcsq000kdsztxdj0bvbi"},{"post_id":"cjq5aqcsb0005dsztgpkjt5tn","category_id":"cjq5aqcs80003dsztuwimd86j","_id":"cjq5aqcss000ndszt4hbjz44e"},{"post_id":"cjq5aqcsc0006dszttzcmofjo","category_id":"cjq5aqcsq000jdsztj6v2m01x","_id":"cjq5aqcsu000sdsztrsxlzcop"},{"post_id":"cjq5aqcsd0007dszt6dv75i40","category_id":"cjq5aqcse0008dsztab1j56j7","_id":"cjq5aqcsv000vdsztxyf3yi1w"},{"post_id":"cjq5aqcsg000bdsztk60hxxll","category_id":"cjq5aqcsu000rdsztep33l3qa","_id":"cjq5aqcsx0010dsztaz3e41gc"},{"post_id":"cjq5aqcsi000cdsztpaia87p1","category_id":"cjq5aqcsq000jdsztj6v2m01x","_id":"cjq5aqcsy0013dsztzie7xatb"},{"post_id":"cjq5aqcsl000gdsztcchpk0dp","category_id":"cjq5aqcsx000zdszt74bake0p","_id":"cjq5aqcsy0017dsztefuegx56"},{"post_id":"cjq5aqcso000idszt8swv9flx","category_id":"cjq5aqcsy0014dsztbgosh6ap","_id":"cjq5aqcsz0019dszth96prdaf"},{"post_id":"cjqlyakk700013w0rg3cyqipb","category_id":"cjq5aqcsu000rdsztep33l3qa","_id":"cjqlyakkb00043w0rvr0zwn7g"},{"post_id":"cjqlyr9wx00094a0r5mj8j4v2","category_id":"cjqlycze000024a0ryilafhin","_id":"cjqlyr9wy000b4a0rvtzehyvf"},{"post_id":"cjqlz47jc0000d10ru25q7p8g","category_id":"cjq5aqcsq000jdsztj6v2m01x","_id":"cjqlz47jk0002d10rfcpeeood"},{"post_id":"cjq5aqcs00000dsztlxq3nxiu","category_id":"cjqlz47k10003d10rn6jw6u55","_id":"cjqlz47k90006d10rhs9s2vqc"}],"PostTag":[{"post_id":"cjq5aqcs60002dsztxw50b0y2","tag_id":"cjq5aqcse0009dsztrfylxsz5","_id":"cjq5aqcsn000hdsztlcnteg5h"},{"post_id":"cjq5aqcsb0005dsztgpkjt5tn","tag_id":"cjq5aqcsa0004dsztb8u0tcdn","_id":"cjq5aqcsr000mdsztslnsvfxu"},{"post_id":"cjq5aqcsc0006dszttzcmofjo","tag_id":"cjq5aqcsq000ldszt9ay237xn","_id":"cjq5aqcst000qdszty3j4k585"},{"post_id":"cjq5aqcsd0007dszt6dv75i40","tag_id":"cjq5aqcse0009dsztrfylxsz5","_id":"cjq5aqcsv000udsztt4vrac5f"},{"post_id":"cjq5aqcsg000bdsztk60hxxll","tag_id":"cjq5aqcsu000tdsztg7eazksy","_id":"cjq5aqcsw000ydsztsn4jpf9j"},{"post_id":"cjq5aqcsi000cdsztpaia87p1","tag_id":"cjq5aqcsq000ldszt9ay237xn","_id":"cjq5aqcsx0012dsztx92vuqv1"},{"post_id":"cjq5aqcsl000gdsztcchpk0dp","tag_id":"cjq5aqcsx0011dsztisic14yu","_id":"cjq5aqcsy0016dsztg8gfuzpj"},{"post_id":"cjq5aqcso000idszt8swv9flx","tag_id":"cjq5aqcsy0015dsztslksrrg2","_id":"cjq5aqcsz0018dsztalvomuod"},{"post_id":"cjqlyakk700013w0rg3cyqipb","tag_id":"cjq5aqcsu000tdsztg7eazksy","_id":"cjqlyakkb00033w0rdoqc7un9"},{"post_id":"cjqlyr9wx00094a0r5mj8j4v2","tag_id":"cjqlycze100034a0ru6sw2nyo","_id":"cjqlyr9wy000a4a0rmxansyux"},{"post_id":"cjqlz47jc0000d10ru25q7p8g","tag_id":"cjq5aqcsq000ldszt9ay237xn","_id":"cjqlz47jj0001d10ra3d76bhd"},{"post_id":"cjq5aqcs00000dsztlxq3nxiu","tag_id":"cjqlz47k70004d10rbin2fh9w","_id":"cjqlz47k80005d10r328wejbl"}],"Tag":[{"name":"network","_id":"cjq5aqcsa0004dsztb8u0tcdn"},{"name":"Git","_id":"cjq5aqcse0009dsztrfylxsz5"},{"name":"js","_id":"cjq5aqcsq000ldszt9ay237xn"},{"name":"react","_id":"cjq5aqcsu000tdsztg7eazksy"},{"name":"JS","_id":"cjq5aqcsx0011dsztisic14yu"},{"name":"subject","_id":"cjq5aqcsy0015dsztslksrrg2"},{"name":"server","_id":"cjqlycze100034a0ru6sw2nyo"},{"name":"css","_id":"cjqlz47k70004d10rbin2fh9w"}]}}