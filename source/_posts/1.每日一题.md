---
layout: post
title: 每日一题
category : subject
tagline: "Supporting tagline"
tags : [subject]
description: 前端题集
date: 2017-1-04 21:36:05
---

**1、** `<img>`的title和alt有什么区别

- title是鼠标移动到元素显示的值
- alt是`<img>`特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。

**2、** 从浏览器地址栏输入url到显示页面的步骤

- 浏览器根据请求的url，交给DNS解析域名找到真实的Ip，向服务器请求数据。
- 服务器处理完成返回数据，浏览器接收数据(Html、js、css、image等)
- 浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom等)
- 载入解析到的资源文件，渲染页面、完成。


**3、**js遍历li的内容
```
<ul>
  <li>1</li>
  <li>2</li>
</ul>
```
=>
```
  const u = document.querySelector('ul');
  const lis = u.children;
  for(let i = 0; i < lis.length; i++) {
    const li = lis[i];
    console.log(li.innerText);
  }
  或
  const realArr = [].slice.call(lis);
  realArr.forEach((li) => {
    console.log(li.innerText)
  })

```
**4、** JavaScript`===`和`==`的区别
`===`即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换
`==`即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如相等则相等。
需要指出的是NaN不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0等于(==或===)-0(对于0而言没有正负之分)。
对于引用类型的变量，==和===都只会判断引用地址是否相等，而不会判断对象具体里的属性以及值是否相等。判断两个对象是否相等，一个简单的方法就是将他们转换为字符串再进行比较。
```
var obj1Str = Json.stringify(obj1);
var obj2Str = Json.stringify(obj2);
console.log(obj1Str === obj2Str);
```


**5、** JavaScript中null和undefined的区别
由于历史原因JavaScript中有null和undefined两个表示无的值，其区别很小，主要在于：
- null的类型为Object，undefined的类型为undefined
- Number(null)为0，Number(undefined)为NaN
- null表示没有对象，此处不该有值，undefined表示此处应该有值暂时缺少这个值

**6、** 常见http code及其含义
- 信息响应(1xx)
  表示服务器收到请求，需要请求者继续执行操作
  - 100 Continue: 客户端应继续其请求。
- 成功(2xx)
  表示服务器成功接收请求并处理返回
  - 200 Ok: 请求正常处理完毕。一般用于GET与POST请求
  - 202 Accepted: 服务器已经接受到消息，但尚未处理
  - 204 No Content: 服务器成功处理了请求但未返回任何内容
  - 206 Partial Content: 服务器成功处理了部分get请求
- 重定向(3xx)
  表示需要客户端进一步操作才能完成请求
  - 301 Moved Permanently: 永久重定向，请求的资源已永久移动到新URI
  - 302 Found: 临时重定向，资源临时移动到新的位置
  - 304 Not Modified: 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。
  - 307 Temporary Redirect: 临时重定向，不允许更改请求方法
- 客户端错误(4xx)
  表示客户端可能发生了错误
  - 400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解
  - 401 Unauthorized: 要求身份验证
  - 403 Forbidden: 服务器理解请求但拒绝执行
  - 404 Not Found: 服务器没有找到资源
- 服务器错误(5xx)
  表示服务器无法完成请求
  - 500 Internal Server Error: 服务器遇到未知问题，无法处理请求
  - 503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求


**7、**  **Coo**kie, SessionStorage与LocalStorage区别

[demo](https://github.com/fengyueran/web-cache-demo.git)
- 储存大小
  - Cookie: 4kb左右
  - SessionStorage: 一般为5M
  - LocalStorage: 一般为5M
- 生命周期
  - Cookie: 默认是关闭浏览器后失效，可以设置失效时间
  - SessionStorage: 仅在当前会话有效，关闭tab页即失效
  - LocalStorage: 持久缓存除非主动清除(通过浏览器或JS)
- 与服务器通信
  - 每次请求都会携带在http请求头中，可能带来性能问题
  - SessionStorage: 只在客户端起作用
  - LocalStorage: 只在客户端起作用

**8、**  html代码中让链接在新窗口中打开的写法

通过设置a标签的target属性为_blank可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过window.openner访问原页面的窗口对象，并且可以通过window.opener.location = newURL将原页面导航至不同的网址。因此需要通过ref="noopenner"来禁用window.opener。
```
  <div>
    <div>
      <a href="http://www.xinghunm.com">Welcome -  old window</a>
    </div>
    <div>
        <a href="http://www.xinghunm.com" target="_blank" ref="noopenner">Welcome -  new window</a>
    </div>
  </div>
```

**9、**  html5有哪些新特性，移除的元素有哪些？

html5现在已经不是标准通用标记语言SGML的子集了，主要是关于图像、位置、存储、多任务功能的增加。
新增:
  - WebSocket
  - Webworker
  - SharedWorker
  - 用于绘画的canvas元素
  - 用于媒介回放的vedio和audio元素
  - 新增sessionStorage和localStorage对离线缓存更好的支持
  - 新的特殊内容元素，如article、header、footer、nav、section
  - 新的表单控件，如calendar、date、time、email、url、search
移除:
  - basefont
  - big
  - center
  - dir
  - font
  - frame
  - frameset
  - noframes
  - strike
  - tt

**10、**  谈谈对盒模型的理解

浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为W3C标准盒模型和IE盒模型，W3C标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而IE盒模型的大小只由内容区域的大小(自定义的width和height)决定。css可以通过box-sizing来切换两种盒模型。
矩形盒子
- W3C标准盒模型(box-sizing: content-box)
  size = content + border + padding
- IE盒模型(box-sizing: border-box)
  size = content

我们在编写html时若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒模型，FireFox等会将其解释为W3C盒子模型，从而渲染出不同的结果。

**11、**  主流的浏览器内核有哪些

- Trident
  Trident为在早期的IE内核，没有使用W3C标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。
- Gecko
  Gecko(火狐内核)，代码开源，也是一个跨平台内核。
- Presto
  Presto(Opera前内核)，渲染速度快兼容性差，现已废弃而采用Google Chrome的Blink内核。
- Webkit
  Webkit(Safari内核)，主要由渲染引擎WebCore和javascript解释引擎JSCore组成，代码开源。
- Chromium/Blink
  2008年谷歌发布了chrome浏览器，其内核被命名为chromium，chromium代码fork自开源引擎webkit并对其进行重新梳理。
  2013年谷歌决定从WebKit衍生出自己的Blink(WebKit的分支)引擎，后由Google和Opera Software共同研发。
  
**12、**  前端页面分层

- 结构层
  由HTML或XHTML创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。
- 表示层
  由CSS创建，CSS对如何显示这些标签内容进行了回答。
- 行为层
  行为层回答了内容应该如何对事件作出反应

**13、**  以下输出的内容

函数作用域内var声明是局部变量
```
var a = 1;
function func(){console.log(a);var a = "in";}
func();
=> undefined
```

**14、**  以下输出的内容

```
(
  function func() {
    var a = b ='res';
  }
)();

//b前面没有跟着var相当于全局变量，所有输出res
console.log(b);//res
//a前面没有跟着var所以a是局部变量，所有输出undefined
console.log(a);
```

**15、**  用js写一个继承实例

```
function Parent(name, age) {
  this.name = name;
  this.age = age;
  function getName() {
    console.log(this.name);
  }
}

function Child(name, age) {
  Parent.call(this, name, age)
  this.weight = 120;
}

const snow = new Child('snow', '20');
console.log(snow.name)
```

**16、**  匹配文档中的关键字

```
  const colorKeyWords = (node, targetValue) => {
    const HIGHLIGHT_COLOR = "orange";  
    const highlightTag = "<span style='background-color: "+HIGHLIGHT_COLOR+";'>" + targetValue + "</span>";
    let htmlStr = node.innerHTML;

    const targetReg = new RegExp(targetValue, "ig");
    htmlStr = htmlStr.replace(targetReg, highlightTag);
    node.innerHTML = htmlStr;
  }
```

**17、**  单击以下node时获取node的属性title和内容`<div id="xhm" title="blog">my blog</div>`

```
const node = document.getElementById("xhm");
node.addEventListener('click', ()=> {
  console.log(node.innerText); // my blog
  console.log(node.getAttribute('title')); // blog
})
```

**18、**  link和@import的区别

- 从属关系不同
  link属于XHTML提供的标签，除了加载CSS外还可以做其他事情，比如定义RSS、定义rel连接属性等，而@import只能用于加载CSS。

- 加载时机不同
  link引用CSS时，在页面加载的同时加载，而@import引用的CSS要在页面加载完后再加载。

- 兼容性不同
  link属于XHTML标签，无兼容性问题。而@import是在CSS2.1提出的，低版本浏览器不支持。

- DOM可控性的不同
  link支持使用JavaScript控制DOM去改变样式，而@import不支持。


**19、** 修改chrome浏览器表单自动填充后的黄色背景

- 取消chrome的自动填充

```
 <input autoComplete="new-password" />
```

- 设置内阴影来覆盖黄色背景
  
```
&: -webkit-autofill {
  -webkit-box-shadow: 0 0 0 1000px white inset;
  -webkit-text-fill-color: black;
}
```

- 设置动画
  
通过动画设置其背景永远为透明。
  
```
 &:-webkit-autofill {
    animation: autofill-fix 1s infinite;
  }
 
 @keyframes autofill-fix {
   from {
     background-color: transparent;
   }
   to {
      background-color: transparent;
   }
 }
```

**20、** JavaScript数据类型

- 基本数据类型
  - undefined
  - Null
  - Boolean
  - String
  - Number
  - Symbol(new in ES6)
- 引用数据类型(Object类型)
  - Object
  - Array
  - Date
  - RegRxp
  - Function
  

**21、** js将一浮点数小数点左边的数字每三位加一个逗号

- 利用parseInt的toLocaleString方法
```
const formatNum = (num) => num.toString().replace(/(\d+)(.*)/g, (match, s1, s2) => `${parseInt(s1).toLocaleString()}${s2}`)

formatNum(15234555.55)
=> "15,234,555.55"
```

- 完全用正则替换
  
```
//当一个字符串中某个数字后跟着n对三个数字(\d{3})就匹配这个数字
const formateNum = (num) => {
  const numStr = num.toString();
  //替换小数点左边的数字
  return numStr.replace(/\d+/, (match) => {
    //替换目标数字为`${matchNum},`
    return match.replace(/(\d)(?=(\d{3}+$))/, (s1) => `${s1},`);
  })
}

formateNum(435345.656)
=> "435,345.656"
```

**22、** HTML常见的内联元素、块级元素以及空元素有哪些？
- 内联元素
  - a
  - img
  - input
  - label
  - span
  - br
  - select
  - strong
  - textarea

- 块级元素
  - div
  - h1-h6
  - form
  - hr
  - p
  - ul
  - table
  - option
  - li

- 空元素
  - `<br>`
  - `<hr>`
  - `<img>`
  - `<input>`
  - `<link>`
  - `<meta>`

**23、** 移动开发中使用rem的优缺点

rem是CSS3新增的一个单位即root em，它与em的区别在于em是相对父元素的font-size，而rem相对的是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。因此对于移动开发而言，只要通过媒体查询来根据不同的屏幕宽度设置`<html>`元素的字体大小，就可以适配不同的屏幕。rem布局需要计算大小，相对麻烦，此外在引用第三方库时也适配也比较麻烦。


**24、** js模块化分哪些阶段

- 无模块化
  
  js最初的作用只是进行表单验证或添加一些简单的动画，js文件通过`script`标签进行引用，没有模块化一说，随着前端复杂度提高想要引入更多的js文件就把多个`script`标签放在一起。
  ```
  　<script src="script1.js"></script>
　　<script src="script2.js"></script>
　　<script src="script3.js"></script>
  ```
  - 优点
    相对于把所有逻辑放入一个文件，这种引入多个js文件实现简单模块化的思想是进步的。
  - 缺点
    污染全局作用域，文件间依赖关系不明显。

- CommonJS规范
  CommonJS是一个JavaScript模块化规范，最初用于服务端的node。根据这个规范一个文件就是一个模块，其内部定义的变量函数只属于这个模块而不对外暴露。CommonJS通过exports或module.exports来导出需要对外提供的接口，通过require方法来同步加载所要依赖的模块。

  - 模块定义
  ```
  // util.js
  var x = 0;
  var add = function (value) {
    return value + x;
  };
  exports.x = x;
  module.exports.add = add;

  ```
  - 模块使用
  ```
   var util = require(./util.js); 
   console.log(util.x); // 0
   console.log(util.add(1)); // 1
  ```

  - 优点
    解决了全局污染及模块间依赖的问题
  - 缺点
    CommonJS为同步加载，在服务端因其文件都在本地，同步加载没有问题，但在浏览器端文件需要异步加载 CommonJS就不再适用了。

- AMD规范
  AMD(Asynchronous Module Definition)规范为异步加载模块，并允许指定回调函数，实现AMD规范的加载器JS主要有两个require.js 和 curl.js。
  AMD标准中定义了两个API，define和require: 
  - 模块定义: define(id, [depends], callback)

  ```
  //math.js，定义了一个math模块
  define(function () {
    var add = function (x, y) {
      return x + y;
    }
    return {
      add: add,
    };
  });

  ```
  - 模块使用: require([module], callback)
  ```
    require(['math'], function (math){
      console.log(math.add(1,1));
    });
        
  ```

  - 优点
    适合在浏览器环境中异步加载模块，并可以并行加载多个模块。
  - 缺点
    提高了开发成本，且不能按需加载，而是必须提前加载所有的依赖。



- CMD规范
  CMD(Common Module Definition)规范是seajs推崇的规范，与requirejs类似，其不同点在于其加载模式为按需加载。

  ```
  define(function(require, exports, module) {
    var a = require('pdf.js');
    a.doSomething();
    // 依赖就近书写，什么时候用到什么时候引入
    var b = require('./b');
    b.doSomething();
  });
  ```

  - 优点
    实现了异步加载模块，并可以按需加载。
  - 缺点
    依赖SPM打包，模块的加载逻辑偏重。

- ES6模块化
  前面的模块化方法都是社区自己实现的，而ES6的模块化方案是真正的规范。在ES6中通过import关键字引入模块，export关键字导出模块，目前浏览器尚不支持ES6因此需要用babel将代码转换为广泛支持的require。
  ```
    import React, { Component } from 'react';
    import Counter from '../counter';

    class Home extends Component {
      render() {
        return (
          <div>
            <Counter />
          </div>
        );
      }
    }

    export default Home;
  ```


**25、** 不用第三个变量，直接交换两个变量的值

- 方法1: 利用技巧
  
```
  var a = 5;
  var b = 6;
  a = a + b;
  b = a - b;
  a = a - b;

  console.log(a); // 6
  console.log(b); // 5
```

- 方法2: 利用位运算
  位运算当且仅当只有一个表达式的某位上为1时，结果的该位才为1。否则结果的该位为0。

```
  var a = 5; // 二进制101
  var b = 6; // 二进制110
  a = a^b;
=> 
  a = 101
      110
      ---
      011

  b = a^b;

=>
  b = 011
      110
      ---
      101
  
  a = a^b;
=>
  a = 011
      101
      ---
      110

  console.log(a); // 6
  console.log(b); // 5
```
  
**26、** CSS创建平移动画

  
```
  {
    width: 100px;
    height: 30px;
    position: absolute;
    background: blue;
    left: 0;
    top: 0;
    animation: move 3s ease infinite; 
  
    @keyframes move {
      50% {
        left: 100px;
        top: 100px;
      }
    }
    // 或
    @keyframes move {
      50% {
        transform: translate(100px, 100px);
      }
    }
  }
```

**27、** js选择select下的option

```
<select>
  <option value="option1">1</option>
  <option value="option2">2</option>
</select>

const selectNode = document.querySelector('select');
// 1.设置value的值等于option的value来选中option
selectNode.value = option2;

// 2.设置selectedIndex来选中option
selectNode.selectedIndex = 1;

```

**28、** CSS实现超出部分内容显示`...`

```
{
  //需限制其宽度
  max-width: 100px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

**29、** CSS postion定位有哪几种情况

- static
  static定位是默认的定位方式，元素出现在正常的文档流中，会忽略left、top、right、bottom以及z-index。

- absolute
  absolute定位即绝对定位，相对于除static定位元素的第一个父类元素进行定位，元素的位置通过left、top、right以及bottom 属性进行设置。

- fixed
  fixed定位即固定定位，类似于绝对定位，但它是相对于浏览器窗口进行定位的，元素的位置通过left、top、right以及bottom属性进行设置。

- relative
  relative定位即相对定位，相对的参考位置为元素自身所在文档流的位置(不管这个元素是否脱离正常文档流)，通过left、top、right以及bottom属性进行设置。相对定位虽然脱离了文档流，但计算其他元素在文档流中的位置时仍会以该元素正常的文档流位置进行计算，就好像元素还在原来的位置。

- sticky
  sticky定位即粘性定位，可以简单地认为是相对定位和固定定位的混合，元素在跨越特定阈值(top、left、right、bottom所确定的值)前为相对定位，之后为固定定位。
  粘性定位的效果如下:
  <center><img src="/images/1-29-1-sticky.gif" width="500" /><center>
  上图中，导航栏设置为粘性定位:
  ```
    height: 50px;
    background: deepskyblue;
    position: sticky;
    top: 0;
  ```
  可以看到导航栏距离距离上边框为0(阈值)时就不再继续向上滚动，即导航栏在距上边框的距离大于0时可以认为此时的position为relative且top的最小值为0，当导航栏距上边框的达到0时，可以认为position的值为fixed且此时相对于父级元素的top为0。
  利用sticky还能实现层次滚动:
  ```
  <style>
    #root {
      overflow: auto;
      max-height: 200px;
      border: 1px solid;
    }
    dt {
      position: sticky;
      top: -1px;
      padding: 2px 0 0 12px;
      background: deepskyblue;
    }

    dd {
      margin: 0;
      padding: 0 0 0 12px;
    }

  </style>
  <body>
    <div id="root">
      <dl>
        <dt>A</dt>
        <dd>A1</dd>
        <dd>A2</dd>
        <dd>A3</dd>
        <dd>A4</dd>
        <dd>A5</dd>
        <dd>A6</dd>
      </dl>
      <dl>
        <dt>B</dt>
        <dd>B1</dd>
        <dd>B2</dd>
        <dd>B3</dd>
        <dd>B4</dd>
        <dd>B5</dd>
        <dd>B6</dd>
      </dl>
      <dl>
        <dt>C</dt>
        <dd>C1</dd>
        <dd>C2</dd>
        <dd>C3</dd>
        <dd>C4</dd>
        <dd>C5</dd>
        <dd>C6</dd>
      </dl>
    </div>
  ```
  效果如下:
  <center><img src="/images/1-29-2-sticky.gif" width="500" /><center>
  
- initial
  设置默认值，可作用于任何CSS样式(IE不支持该关键字)。
- inherit
  继承父类的postion值，不会继承其left、top、right及bottom值。
- unset
  initial和inherit的结合，当该属性是默认继承属性时等同于inherit；当该属性是非继承属性时等同于initial。
   

**30、** 内联元素和块级元素的区别

**内联元素**
 - 和相邻的内联元素在同一行
 - 设置width和height无效
 - margin上下无效，padding上下虽然可以设置，但并不会挤压其他元素的空间，在其他元素看来好像没有设置一样

**块级元素**

 - 块级元素总是各占一行，垂直排列
 - 宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可设置

内联元素可以通过该变display属性进行转换，
- `display:block`: 表现形式如块级元素
- `display:inline`: 表现形式如内联元素
- `display:inline-block`: 表现形式如内联元素和块级元素，具有block元素可以设置宽高的特性，同时又具有内联元素的不换行等特性


**31、** js判断一个变量是否是数组

```
fuction isArray(obj) {
  Object.prototype.toString().call(obj) === "[object Array]";
}
现代浏览器
Array.isArray(obj)
```

**32、** JavaScript由哪三部分构成

- 核心(ECMAScript)
  ECMAScript仅仅是一个描述，定义了脚本语言所有的属性、方法和对象，其他语言可以实现 ECMAScript 来作为功能的基准
- 文档对模型(DOM)
  它是HTML和XML的应用程序接口，DOM将整个页面规划成由节点层级构成的文档，HTML或XML页面的每个部分都是一个节点的衍生物
- 浏览器对象模型(BOM)
  它提供了一种特性，可以对浏览器窗口进行访问和操作，使用BOM开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。


**33、** sql的注入原理及防范方法

通常服务器端都会根据客户端的请求来动态构建sql执行语句，sql注入是通过将恶意的sql语句添加到应用的输入参数中，从而在sql服务器后台解析执行。
防范方法:
- sql语句预编译和绑定变量
  sql执行命令必须先通过语法分析，生成执行计划，预编译后不管注入的参数是什么都不会再执行，而是当作字符串字面值进行处理。
- 严格检查参数
  只执行规定格式的参数可以避免部分的sql注入
- 使用安全函数
  安全函数将参数的特殊字符进行编码，这样sql引擎就不会将参数当成sql语句进行解析了。

**34、** JavaScript的垃圾回收机制

JavaScript有自动垃圾回收机制，当然这并不意味着你不需要关心内存管理。
内存的生命周期大致分为内存的分配、内存的使用以及不需要时内存的释放。因此只要追踪内存的生命周期就能自动的对内存进行分配回收了，但是这并不容易，尤其要确定某块内存是否真的不需要了。因此，垃圾回收只能有限制的解决一般问题，主要有两种方法，引用计数和标记清除算法。

- 引用计数法
  在内存管理环境中，如果一个对象(包括函数作用域、全局词法作用域等)有访问另一个对象的权限，叫做一个对象引用另一个对象。当对象被引用的次数为0时就被回收。
  ```
  var a = { v: 1 }; // 对象{ v: 1 }被变量a引用一次，引用计数为1
  var b = a; // 同样，对象{ v: 1 }被变量b引用一次，引用计数为2
  a = null; // 对象引用次数减1
  b = null;// 对象引用次数减1，此时引用计数为0，对象可以被释放
  ```
  引用计数有一个潜在的问题，就是无法解决循环引用的问题。
  如下，a、b互相引用，引用计数一直为1，导致不能自动回收。
  ```
    function f() {
      var a = {};
      var b = {};
      a.value = b;
      b.value = a;
    }
    f();
  ```
- 标记清除算法

 这个算法假定有一个叫跟(root)的对象(js中为window， node js为global)，垃圾回收器定期从根开始，找所有从根开始引用的对象，然后找这些引用对象引用的对象...将这些对象标记为active，其他的不能被根引用或间接引用的将被标记为garbage，最终将这些垃圾清除。
 循环引用将不再是问题，上例中函数f执行完后，全局window就无法访问到对象a和b了，因此对象a、b将会被回收。
 <center>![标记清除意图]](/images/mark_sweep.gif)<center>
 <center>标记清除意图 <center>

**35、** JavaScript中var和let去区别

let为ES6新增的命令，用来声明变量，用法与var类似，其区别如下:
- 有效范围
  在ES6之前，JS函数只有函数作用域和全局作用域，没有块级作用域，所以`{}`不能限制var所声明的变量的访问范围，而let声明的变量只在let声明时的代码块内有效。
  ```
  {
    let a = 1;
    var b = 2;
  }

  a // ReferenceError: a is not defined.
  b // 2
  ```
- 变量提升
  let不存在变量提升，var存在变量提升
  ```
    console.log(a); // undefined
    var a = 1;

    console.log(b); // Uncaught ReferenceError
    let b = 2;
  ```
- 重复声明
  let不能重复声明，var可以重复声明
  ```
    var a = 1;
    var a = 2;

    let b = 1;
    let b = 2; //Identifier 'b' has already been declared
  ```
- 暂时性死区
  let有暂时性死区约束，如下在全局声明了变量a，又在块级作用域用let声明了a，ES6明确规定，如果块级作用域内存在let或const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭区域。凡是在声明之前使用这些变量，就会报错，这在语法上称为暂时性死区。
  ```
  var a = 1;
  if (true) {
    a = 2;// ReferenceError
    let a;
  }
  ```

**36、** Doctype作用？标准模式与兼容模式各有什么区别?

- 作用
  `<!DOCTYPE>`声明位于HTML文档的第一行，处于`<html>`标签之前。用于告诉浏览器以什么文档标准来解析这个文档，DOCTYPE不存在或格式错误会导致浏览器用兼容模式来解析文档。
- 区别
  标准模式是以浏览器支持的最高标准来运行，兼容模式中页面以宽松的向后兼容的模式进行显示，以防止老式浏览器无法正常工作。
  
**37、**  HTML5为什么只需要写`<!DOCTYPE HTML>`？

HTML5不是基于标准通用标记语言SGML(Standard Generalized Markup Language)的，因此不需要对文档类型定义DTD(Document Type Definition)进行引用，但是需要Doctype来规范浏览器的行为(让浏览器按照他们应该的方式来运行)。HTML4.01是基于SGML的，因此需要对DTD进行引用，才能告知浏览器所使用的文档类型。

**38、**  介绍一下你对浏览器内核的理解。

主要分为两部分，渲染引擎和JS引擎。
- 渲染引擎
  主要负责获取网页内容(HTML、XML、图像等)、整理信息(CSS等)以及计算网页的显示方式，然后输出至显示器或打印机。不同的浏览器内核对网页的解释不同，所渲染出的网页效果也就不一样。
- JS引擎
  解析和执行javascript来实现网页的动态效果。
最初渲染引擎和JS引擎并没有区分地很明确，后来JS引擎越来越独立，内核就倾向于指渲染引擎。


**39、**  简述一下你对HTML语义化的理解。

用正确的标签做正确的事情。
- html语义化使页面结构更加清晰，便于对浏览器搜索引擎解析。
- 在没有CSS的情况下也以一种文档格式显示。
- 搜索引擎的爬虫也依赖于HTML的标签来确定上下文和各个关键字的权重，利于SEO。
- 有利于阅读代码的人理解网站的分块。

**40、** iframe有哪些优缺点？
优点:
- 用来实现长连接，在websocket不可用的时候作为一种替代。
- 跨域通信。
- 无刷新上传文件，在FormData不可用时作为替代方案。
- 创建一个全新的独立的宿主环境。
  
缺点:
- 搜索引擎的爬虫还不能很好的处理iframe的内容，不利于SEO。
- iframe会阻塞页面的加载，onload事件不能及时触发(动态的给iframe添加src值可
  解决) 。
- iframe和主页面共享连接池，而浏览器对同域的连接有限制，所以会影响页面的并行
  加载(动态的给iframe添加src值可解决)。
- 样式和脚本需要额外链入，增加服务器的http请求。
- 多数小型的移动设备无法完全显示框架。
- 浏览器的后退按钮无效。

**41、** label的作用是什么？是怎么用的？
label标签用来定义表单控制间的关系，当用户选择该标签时，浏览器会自动将焦点转移到和改标签相关联的表单控件上。
如下: 通过将label标签的属性for的值设置为input的id就可以将label和input关联起来，点击label时就可以选中radio类型的表单了。
```
  <div>
    <label for="Name">Number:</label>  
    <input type="radio" id="Name"/>  
  </div>
```

**42、** 如何实现浏览器内多个标签页之间的通信? (阿里)

- WebSocket
- SharedWorker
- localstorage、cookies等本地存储方式

**43、** webSocket如何兼容低浏览器？(阿里)

- Adobe Flash Socket
- ActiveX HTMLFile(IE)
- 基于mutipart编码发送XHR
- 基于长轮询的XHR

**44、** 页面可见性Page Visibility API 可以有哪些用途？

在web页面的开发中，如何判断用户是不是还在与页面交互是一个重要的问题，比如页面最小化了或隐藏在其他标签页后面，这时我们就可以做关闭页面正在播放的音乐或其他什么事情。
Page Visibility API由三部分构造:
- document.hidden: 表示页面是否隐藏的布尔值
- document.visibilityState: 有4个可能的状态值
  - hidden: 页面在后台标签页或浏览器最小化，此时页面对用户不可见
  - visible: 页面在前台标签页，此时页面至少有部分是可见的
  - prerender: 页面正在进行预渲染处理，文档只能从这个状态开始，不可能由其它状态变为这个状态，此时
    document.hidden为true，
  - unloaded: 页面从内存中卸载清除
- visibilitychange事件: document.visibilityState状态发生变化时触发
  
```
  document.addEventListener('visibilitychange', () => {
    console.log(document.visibilityState);
  })
```

**45、** 网页验证码是干嘛的，是为了解决什么安全问题。

为了区分用户是机器还是人，验证码对于人而言很容易识别，对于计算机则难以识别，这可以防止恶意的破解密码、刷票、论坛灌水或者利用特定的程序暴力破解方式进行不断的登录尝试。

**46、** title与h1的区别、b与strong的区别、i与em的区别？
- title vs h1
  title是关于元素的额外信息，当鼠标移动元素上时显示一段提示文本，而h1表示层次明确的标题，对页面信息的抓取也有很大影响。

- b vs strong
  b表示粗体文本，并没有明确的语义，而strong表示强调，有语气加强的含义，使用阅读设备阅读时`<strong>`会重读。

- i vs em
  i表示斜体，em表示强调的内容。

以上主要是自然样式标签和语义样式标签的差别，应该多用语义样式标签，但不能滥用。
- 自然样式标签
  ```
  b, i, u, s, pre
  ```
- 语义样式标签
  ```
  strong, em, ins, del, code
  ```

**47、** CSS选择符有哪些？哪些属性可以继承？哪些属性不可以继承？CSS3新增伪类有哪些？

**CSS选择符**
- id选中器(# id)
- 类选择器(. class)
- 标签选择器(div、p)
- 相邻元素选择器(E + F)
- 子元素选择器(E > F)
- 后代元素选择器(E F)
- 属性选择器([attribute])
- 伪类选择器(E:)
- 通配符选择器(*)

**可继承属性**
- color
- text-align、text-indent、text-transform
- font、font-family、font-size、font-style、font-weight
- line-height
- cursor
- visibility
- word-spacing
...

**不可继承属性**
- display
- margin
- padding
- border
- position
- z-index
- height、min-height、max-height
- width、min-width、max-width
- left、top、right、bottom
...

**新增伪类**
- :enabled
- :disabled
- :checked
- :only-child
- :nth-child(n)
- :first-of-type
- :last-of-type
...

**48、** display有哪些值？说明他们的作用。

- none: 元素不显示，并从文档流中移除
- inline: 显示为行内元素类型，同行显示，宽高不能设置
- block: 显示为块级元素类型，换行显示，可设置宽高，默认宽度为父元素宽度
- inline-block: 显示为行内块级元素类型，同行显示，可以设置宽高
- list-item: 像块级元素一样显示并添加列表标记
- table: 像table一样显示
- inherit: 从父元素继承display属性值

**49、** css多列等高(高度不固定)如何实现？
**padding补偿法**
如下: 父容器(container)的高度是由子元素div中高的那一列(叫做higher)决定的，而子元素的高度有内容、边框、内边距、外边距的高度共同决定的，当设置子元素的底内边距padding-bottom和底外边距为相等的正负值后，高度相抵为0，此时父容器的高度由higher的内容和边框决定，当higher的高度增加时父容器的高度也跟着增加，子元素中较矮的那列则会用padding-bottom来补偿这部分高度差(因为padding足够大)，再设置父容器overflow: hidden则可以正好截取higher的高度进行显示，表面看上去就是两列等高。
```
  <style>
    .container {
      overflow: hidden;
    }
    .div1 {
      float: left;
      width: 200px;
      background: blue;
      padding-bottom: 2000px;
      margin-bottom: -2000px;
    }
    .div2 {
      float: left;
      width: 200px;
      background: red;
      padding-bottom: 2000px;
      margin-bottom: -2000px;
    }
  </style>
  <div class="container">
    <div1 class="div1">
    Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues.
    </div1>
    <div2 class="div2">
    Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues. Most of the discussion was on what needed to be done now as we transitioned from the security issues to the challenging economic issues.
    </div2>
  </Box>
```

**50、** li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？

由于浏览器默认会把行内元素间的空白字符(空格、换行、tab)渲染为一个空格，因此li之间就产生了空白间隔。
解决方法是书写li时写为一行或设置font-size为0。

**51、** 为什么要初始化CSS样式。

因为浏览器兼容问题，不同的浏览器对有些标签的默认值是不一致的，如果没有初始化可能导致浏览器渲染的结果差异，但是初始化样式对SEO有一定影响，力求影响最小的情况下初始化。

**52、** CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？

对普通元素设置visibility: collapse后这个元素会完全隐藏，但会占据局部空间，与visibility: hidden的效果一样，相当于此元素透明，如果元素为table，collapse会让table会隐藏但不会占据局部空间。
不同浏览器不同版本的表现并不一致，不建议使用。

**53、** 请解释一下为什么需要清除浮动？清除浮动的方式

清除浮动是为了清除使用浮动元素带来的影响，浮动的元素高度会塌陷，而高度的塌陷是我们后面的布局不能正常显示。
清除浮动的方式:
- 利用clear属性

  如下，设置box的clear的属性为left或both即可消除兄弟元素浮动的影响，因为clear的本质是添加外边距，所有该方法不能解决父元素高度塌陷的问题。
  ```
    <style>
      .float-left {
        float: left;
        width: 200px;
        height: 100px;
        background: blue;
      }
      .box {
        width: 200px;
        height: 100px;
        background: gray;
        clear: both;
      }
    </style>

    <div>
      <div class="float-left" />
      <div class="box" />
    </div>
  ```
- 添加空块级元素
  如下在浮动元素后添加空块级元素div，并设置其clear属性为both或left即可以清除浮动，父元素高度塌陷的问题也得到了解决。
  ```
    <style>
      .clear {
        clear: both;
      }
    </style>
    <div>
      <div class="float-left" />
      <div class="clear"/>
      <div class="box" />
    </div>
  ```

- 伪元素::after和::before(作用于浮动元素的父类)
  ```
    <style>
      .float-father {
        &::after {
          content: "";
          display: block;
          clear: both;
        }
      }
    </style>
    <div>
      <div class="float-father">
        <div class="float-left" />
      </div>
      <div class="box" />
    </div>
  ```

- overflow的方法(作用于浮动元素的父类)
  设置浮动元素父类的overflow为auto或hidden即可清除浮动，该方法是利用BFC的特性达到的效果，这与前述几种方法通过设置clear属性的本质是不一样的。
  ```
    <style>
      .float-father {
        overflow: auto;
      }
    </style>
    <div>
      <div class="float-father">
        <div class="float-left" />
      </div>
      <div class="box" />
    </div>
  ```

**53、** 浏览器是怎样解析CSS选择器的？

样式系统从关键选择器开始匹配，然后从右向左查找选择器的的祖先祖先元素，如果匹配，则继续左移查询父元素，不匹配则放弃查找，相比从左到右的正向查找效率大大提高。


**54、** 在网页中的应该使用奇数还是偶数的字体？为什么呢？
使用偶数字体更好，主要原因如下:
- 比例关系
  相对来说偶数字号容易和web页面的其他部分构成比例关系，如使用14号为正文字号，使用14 * 0.5 = 7px作为margin，14 * 1.5 = 21px作为标题。
- ie6中会把13px的字号渲染为14px
- 汉字更均衡
  比如14号的汉字，会去掉1px的间距，字体的实际宽度就是13px，这样汉字的中竖线正好平分汉字，使汉字显得更加均衡。

**55、** 元素竖向的百分比设定是相对于容器的高度吗？

高度是相对于父容器高度，padding-top,padding-bottom,margin-top,margin-bottom是相对于父容器宽度。

**56、** 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？

响应式设计就是根据设备环境(系统平台、屏幕尺寸)来进行相应的响应和调整。其主要原理就是通过媒体查询来适配不同环境下的UI，对于低版本IE来说不能使用媒体查询，则可以通过监听window resize事件添加新的类来实现PC端的响应式布局，此外还可以通过Respond.js来实现媒体查询。

**57、** 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）

多数显示器的默认频率是60Hz，即一秒钟刷新60次，因此理论上动画最小时间间隔是1 / 60 * 1000ms = 16.7ms。

**58、** overflow: scroll时不能平滑滚动的问题怎么处理

开启硬件加速，-webkit-overflow-scrolling: touch  

**59、** png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？

- png(Portable Network Graphics)
  直译就是便携式网络图片，简称PNG，是一种无损压缩的位图图形格式式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性。PNG的开发目标是改善并取代GIF作为适合网络传输的格式而不需要专利许可。
  特性
  - 支持256色调色板技术以产生小体积文件
  - 支持最高24位真彩色图像以及8位灰度图像
  - 支持Alpha通道的透明/与半透明特性
  - 支持无损压缩
  - 支持存储附加信息，以保留图像名称、作者等信息
  - 支持图像亮度的Gamma校准信息
  - 渐进显示和流式读写，适合在网络传输中快速显示预览效果后再展示全貌
  ...

- jpg(Joint Photographic Experts Group)
  jpg即jpeg，由于早期的DOS、Windows95只支持最长3字符的扩展名，为了兼容采用了.jpg，一直沿用到今天，JPEG是一种针对照片视频而广泛使用的有损压缩标准方法。支持24位真彩色，颜色丰富并且适合那些允许轻微失真的像素色彩丰富的图片(相片)不支持动画，不支持透明色，不适合logo和线条。
  
- gif(Graphics Interchange Format)
  是一种位图图形文件格式，它采用无损压缩技术，以8位色(即2556种颜色)重现真彩色的图像，它既可以减少文件的大小，又保持成像质量。GIF图片可以动并且拥有透明度(透明或不透明，并没有alpha通道)。适合logo、线条图。

- webp
  是一种同时提供了有损压缩和无损压缩(可逆压缩)的图片文件格式。它的优势在于拥有更优的图像数据压缩算法，能带来更新的图片提交，而且拥有肉眼识别无差异的图像质量，此外它还具备Alpha透明以及动画特性。


**60、** style标签写在body后与body前有什么区别

写在body前有利于浏览器逐步渲染(resources download=>CSSOM+DOM=>RenderTree=>Layout=>Paint)，写在body标签后由于浏览器逐行方式对html文档进行解析，当解析到写在尾部的样式表时会导致浏览器停止之前的渲染，等待加载且解析样式表完成后重新渲染，在windows的IE下可能会出现FOUC现象(即样式失效导致的页面闪烁问题)。

**61、** 什么是CSS 预处理器 / 后处理器？

- 预处理器
  CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加一些编程的特性，并将CSS作为目标生成文件。比如LESS、Sass、Stylus等用来预编译CSS，他们具有层级、mixin、变量、循环、函数等特性，极大的提高了UI开发效率。

- 后处理器
  对CSS进行处理，属于广义上的CSS预处理器，我们很久以前就在用预处理器了，最典型的例子就是CSS压缩工具clean-css，目前最常用的后处理器就是PostCSS，用来在完成的样式表中根据CSS规范处理CSS，如给CSS属性添加浏览器私有前缀，实现各个浏览器的兼容。


**62、** 什么是Cookie隔离？

cookie隔离就是在http请求的时候不带cookie，如果静态文件都放在主域名下，那么在静态文件请求时都会把带有cookie的请求提交给server，非常浪费资源，所以不如隔离开。
因为cookie有域的限制，因此不能跨域请求，因此使用非主域名的时候，请求头中就不会带有cookie，这样就可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。


