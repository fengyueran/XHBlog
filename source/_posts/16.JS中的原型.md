---
layout: post
title: JS中的原型
category : JS
tagline: "Supporting tagline"
tags : [JS]
description: 在面向对象编程中，类之间共享是通过继承实现的，而在JavaScript中万物皆对象，并没有类的概念(ES6中类仅仅是一个语法糖)，对象之间的共享是通过一个叫做原型的东西实现的。
date: 2017-2-01 18:10:20
---

对于原型我们通过[[prototype]]、__proto__以及prototype这三个概念理解其实现继承的思路。

### **[[prototype]]** 

在ECMAScript标准中规定每个对象都有一个内置的属性[[prototype]]，它指向一个对象的原型(也是一个对象即原型对象)，而这个对象会继承它的原型对象的所有属性。当查找一个对象的属性或方法时，如果在当前对象找不到，则在其原型对象上寻找，如果原型对象上也没有，则在原型对象的原型对象上寻找，如此继续直到一个对象的原型对象为null(null没有原型)。可以看到，这样一种层层向上的查找是一种链式查找，在每一层上的对象都有一个指向其原型对象的链接，由这些链接组成的整个链条就叫做原型链。

基于原型的继承思路大致如下: obj拥有属性[[Prototype]]，它指向原型对象proto，从而对象obj通过原型链可以使用原型对象的方法getName。
```
var proto = {
    getName: function () {
        return 'name: '+this.name;
    }
};
var obj = {
    [[Prototype]]: proto,
    name: 'obj'
};
> obj.getName
[Function]
> obj.getName()
'name: obj'
```
<center>![链式查找示意图]](/images/16-1-chain.png)<center>
<center>图1.链式查找示意图 <center>

### **__proto__** 
前述中的[[Prototype]]是一个内置属性，由于我们并不能直接获取，为了操作属性的便利性很多浏览器都实现了Object.prototype.__proto__，因此可以通过obj.__proto__来访问对象的原型对象。
另一方面，设置[[Prototype]]是一个缓慢的操作，影响性能，因此使用__proto__是有争议的，更推荐使用Object.getPrototypeOf和Object.setPrototypeOf来访问原型对象。但为了保持浏览器的兼容性，在ES6中支持了这一规范。
```
let Animal = function () {};
let dog = {};
let animal = new Animal();
 
dog.__proto__ = animal;
console.log(dog.__proto__);
```

### **prototype** 
prototype是一个拥有constructor内部方法的对象才有的属性，比如函数(非箭头函数)，ES6中的类。这个所谓的prototype，其实可以认为是构造函数内部一个普通的对象(或者说指向这个普通对象)，只是很不幸的是叫做prototype(原型)而已，我们可以叫他baseObj，当调用构造函数时，会自动将baseObj赋值给__proto__，这样在新的实例上通过原型链就可以共享构造函数baseObj及其原型链上的属性了。

来看下面的例子:
函数Animal通过new实例化的对象能够访问到函数prototype属性的food和eat，这是如何做到的呢？
```
var Animal = function(name) {
  this.name = name;
};
Animal.prototype.food = 'meat';
Animal.prototype.eat = function() {
  console.log(this.name + ' eat ' + this.food);
};
var panda = new Animal('panda');
var dog = new Animal('dog');
console.log(panda.eat()); // panda eat meat
console.log(dog.eat()); // dog eat meat
console.log(panda.__proto__=== Animal.prototype); // true
```
如下图所示，实例对象panda和dog之所以能够访问Animal原型上的food和eat属性是因为在调用构造函数时Animal的prototype对象赋值给了实例对象的__proto__属性，实例对象在访问自己的方法(panda.eat)时首先在其原型对象上寻找，即在__proto__指向的对象上寻找，而这个对象正好是Animal的原型prototype对象，它拥有eat方法，所以可以成功访问eat方法。
说明: 图中builts-in为构建内置函数比如toString()、valueOf等。
<center>![prototype继承示意图]](/images/16-2-prototype.png)<center>
<center>图2.prototype继承示意图 <center>

来看另一个例子:
如下将函数Fish的prototype赋值为Animal，以此，通过fish的实例来访问Animal原型prototype上的方法，可结果是Uncaught TypeError: nimo.eat is not a function，为什么会这样呢？前述我们已经知道继承是通过原型链来实现的，而原型链又是通过__proto__(指向内置对象[[prototype]]])来串联的。当函数Fish的prototype赋值为Animal后，生成的实例对象nimo的__proto__为Animal，所以访问nimo.eat会现在Animal上寻找eat方法，如图2，Animal函数并没有eat方法，从而继续向上寻找，直到顶层对象Object，结果还是没有，因此报错。
```
var Animal = function(name) {
  this.name = name;
};
Animal.prototype.food = 'meat';
Animal.prototype.eat = function() {
  console.log('I can eat' + this.food);
};

var Fish = function(name) {
  this.name = name;
};
Fish.prototype = Animal;

var nimo = new Fish('nimo');
console.log(nimo.eat()); // Uncaught TypeError: nimo.eat is not a function
```

### **通过不同的方法来创建对象和生成原型链** 

- 语法结构创建对象
  - 对象字面量
    通过对象字面量创建的对象其原型链为obj --> Object.prototype --> null
    ```
    var obj = { a: 1 };
    ```
  - 数组字面量
    通过数组字面量创建的对象其原型链为arr --> Array.prototype --> Object.prototype --> null
    ```
    var arr = [1, 2];
    ```
   - 函数字面量
    通过函数字面量创建的对象其原型链为f --> Function.prototype --> Object.prototype --> null
    ```
    function f(){ console.log('func');}
    ```
- 构造器创建对象
  通过构造函数创建的对象其原型链为instance --> func.prototype --> Function.prototype --> Object.prototype --> null
  ```
    var Animal = function(name) {
      this.name = name;
    };
    Animal.prototype.food = 'meat';
    Animal.prototype.eat = function() {
      console.log('I can eat' + this.food);
    };
    //实例对象panda的__proto__指向Animal.prototype
    var panda = new Animal('panda');
  ```

- Object.create创建对象
  在ES5中引入了一个新的方法来创建对象，就是Object.create，新对象的原型就是该方法传入的第一个参数。
  ```
    var a = { x: 1 }; 
    // a --> Object.prototype --> null

    var b = Object.create(a);
    // b --> a --> Object.prototype --> null
    console.log(b.__proto__ === a); // true
    console.log(b.x); // 1 

    var c = Object.create(b);
    // c --> b --> a --> Object.prototype --> null
    console.log(c.__proto__ === b); // true
  ```

### **总结** 

- 任何对象都可以成为其他对象的原型(原型对象)。
- [[Prototype]]为一个对象的指向原型对象的内置属性，不能直接访问。
- __proto__为一个非标准的，只是为了方便访问原型对象而实现的一个属性，它和[[Prototype]]本质上一样都
  是指向原型对象，是所有对象都有的属性。
- prototype为拥有constructor内部方法的对象才有的属性，它本身只是一个普通对象，只是正好叫做原型      (prototype)，它的作用是在构造函数生成新的实例时将这个所谓的原型赋值给实例的__proto__属性，这样新
  的实例就可以通过__proto__来继承构造函数原型里的方法。可以看到，这和__proto__所指的原型对象是完全不同的概念。
- 实例对象没有prototype属性，

  