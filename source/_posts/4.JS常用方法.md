---
layout: post
title: JS常用方法
category: js
tagline: "Supporting tagline"
tags: [js]
description: js中方法很多，在这里记录下自己容易忘记的一些较为重要的方法和技巧
date: 2016-6-05 18:10:20
---

### **10 进制转 x 进制**

```
var convert10ToXBinary = (num, x) => {
  let xBinaryStr = "";
  while (num !== 0) {
    const res = num % x;
    xBinaryStr = res + xBinaryStr;
    num = Math.floor(num / x);
    console.log(num)
  }
  const xBinaryNum = Number(xBinaryStr);
  return xBinaryStr;
};

```

### **解析对象**

请实现方法 parse ，作用如下：

```
var object = {
 b: { c: 4 }, d: [{ e: 5 }, { e: 6 }]
};
console.log( parse(object, ‘b.c’) == 4 ) //true
console.log( parse(object, ‘d[0].e’) == 5 ) //true
console.log( parse(object, ‘d.0.e’) == 5 ) //true
console.log( parse(object, ‘d[1].e’) == 6 ) //true
console.log( parse(object, ‘d.1.e’) == 6 ) //true
console.log( parse(object, ‘f’) == ‘undefined’ ) //true
```

```
var parse = (object, key) => {
  const els = key.split(".");
  let target = object;
  let i = 0;
  while (target && i < els.length) {
    const el = els[i];
    const index = el.indexOf("[");

    if (index >= 0) {
      const objKey = el.slice(0, index);
      target = target[objKey];
      if (target) {
        const arrIndex = el.slice(index + 1, index + 2);
        target = target[arrIndex];
      }
    } else {
      target = target[el];
    }
    i++;
  }
  return target;
};

```

### **取整函数**

- 向上取整: Math.ceil():
- 向下取整: Math.floor():
- 四舍五入: Math.round():

### **生成随机数**

- 产生[m, n]的随机整数

  ```
  // Math.random产生[0, 1)的随机数
  const random = (m, n) => Math.ceil(Math.random() * (n - m)) + m;
  ```

- 产生(m, n]的随机整数

  ```
  const random = (m, n) => {
    const value = Math.random();
    return value === 0 ? m + 1 : Math.ceil(value * (n - m)) + m;
  }
  ```

- 产生[m, n)的随机整数

  ```
  const random = (m, n) => Math.floor(Math.random() * (n - m)) + m;
  ```

- 产生(m, n)的随机整数

  ```
    const random = (m, n) => {
      const value = Math.floor(Math.random() * (n - m));
      return value === 0 ? m + 1 : value + m;
    }
  ```

### 常用排序算法

- 冒泡排序法

  基本思想: 两个数比较，较小的数冒泡起来，较大的数下沉

  过程:

  - 比较相邻的两个数，如果第二个数小，就交换位置
  - 从后往前两两比较，直到最前面两个数，此时最小的数被排到了前面
  - 重复上述过程，依次将第 2，3...n 个最小的数排好位置

  ```
  var bubbleSort = arr => {
    let tmp;
    let flag = false;
    for (let i = 0; i < arr.length - 1; i++) { //表示排序次数
      for (let j = arr.length - 1; j > i; j--) {
        if (a[j] < a[j - 1]) {
          tmp = a[j];
          a[j] = a[j - 1];
          a[j - 1] = tmp;
          flag = true;
        }
      }
      if (!flag) break; //flag为false表明没有位置交换，也就是说数组已经是有序的了
    }
  };
  ```

  **时间复杂度计算:**

  如下: 冒泡排序的时间复杂度为 O(n^2)

  ```
  假设数组长度为n，算法执行次数为T(n)，时间复杂度为O(T(n))
  T(n) = (n - 1) + (n - 2) + (n - 3) + ... + n - (n - 1)
       = ((n - 1) + 1) * (n - 2) / 2
       = 0.5 * n^2 - n
  O(T(n)) = O(n^2)
  ```

  **空间复杂度计算:**

  可以看到，冒泡排序并没有循环分配空间，只有变量 tmp、flag、i、j 分配了空间且与数组长度无关，因此冒泡排序的空间复杂度为 O(1)。

- 快速排序法

  基本思想:

  - 先从数列中选出一个数作为参照值
  - 将比这个参照值小的放到左边，大于或等于这个值的放到右边
  - 对左右两列数重复上一步，直至各个区间只有一个数

  ```
  var quickSort = arr => {
    if (arr.length <= 1) return arr;
    const pivotIndex = Math.floor(arr.length / 2);
    const pivot = arr.splice(pivotIndex, 1)[0];
    const left = [];
    const right = [];
    for (let i = 0; i < arr.length; i++) {
      const v = arr[i];
      if (v < pivot) {
        left.push(v);
      } else {
        right.push(v);
      }
    }
    return quickSort(left).concat(pivot, quickSort(right));
  };
  ```

  **时间复杂度计算:**

  如下: 快速排序的时间复杂度为 O(nlogn)

  ```
  假设数组长度为n，算法执行次数为T(n), 每进行一次快速排序的时间为一个单独快速排序O(n)的工作和两个n/2大小数列的递归调用T(n/2)，时间复杂度为O(T(n))
  T(1) = 1;
  T(n) = O(n) + 2T(n/2);
       = O(n) + 2(O(n/2) + 2T(n/4));
       = O(n) + 2O(n/2) + 4T(n/4);
       = 2O(n) + 4T(n/4);
       = 2O(n) + 4(O(n/4) + 2T(n/8));
       = 3O(n) + 8T(n/8)
       = ...
       = kO(n) + 2^kT(n/2^k);
       = kO(n) + nT(1);//n==2^k => k = log2n，2为底数
       = log2n * n + n;

  O(T(n)) = O(nlogn)
  ```

- 归并排序法
  归并排序是建立在归并操作上的一种有效的排序方法，该算法是采用分治法的一个非常典型的应用。
  基本思想:

  - 将长度为 n 的数列分为两个长度为 n/2 的子列表
  - 将子列表继续分为长度为 n/4 的子列表，如此继续，直到列表长度为 1 为止
  - 对子列表进行两两比较，只比较它们的第一个数，哪个列表的数小就取出这个数，并从原数组中删除，如果一个数列为空，则依次取出另一个数组中的元素，这样得到的是有序数列。
  - 将这些有序数列进行合并

  ```
  var merge = (left, right) => {
    console.log("left", left);
    console.log("right", right);
    const result = [];
    while (left.length > 0 && right.length > 0) {
      if (left[0] < right[0]) {
        result.push(left.shift());
      } else {
        result.push(right.shift());
      }
    }
    return result.concat(left, right);
  };

  var mergeSort = arr => {
    if (arr.length <= 1) return arr;
    const pivotIndex = Math.floor(arr.length / 2);

    const left = arr.slice(0, pivotIndex);
    const right = arr.slice(pivotIndex);
    return merge(mergeSort(left), mergeSort(right));
  };
  ```

  **时间复杂度计算:**

  可以看到归并排序把一个规模为 n 的问题分解成了一个 merge 操作和两个规模为 n/2 的问题，merge 耗时为 O(n)，则

  ```
  T(n) = O(n) + 2T(n/2);
  ```

  因此，同快速排序一样归并排序的时间复杂度为 O(nlogn)。

### **操作数组**

- shift

  该方法用于将数组的第一个元素从其中删除，并返回第一个元素的值。如果数组为空，则不进行任何操作，返回 undefined 值，该方法不会创建新数组而是从原数组直接进行修改。

  ```
  const arr = [1, 2];
  const v = arr.shift();
  console.log(v); // 1
  console.log(arr); // [2]

  ```

- pop

  该方法用于删除并返回数组的最后一个元素，如果数组为空，则 pop 不改变数组，并返回 undefined 值，该方法不会创建新数组而是从原数组直接进行修改。

  ```
  const arr = [1, 2];
  const v = arr.pop();
  console.log(v); // 2
  console.log(arr); // [1]
  ```

- slice

  该方法返回一个新的数组对象，这个对象由一个 begin 和 end(不包括 end)决定的原数组的浅拷贝，原数组不会被改变。

  **语法:**

  ```
  arr.slice(begin, end);
  ```

  **参数:**

  ```
  begin(可选): 拷贝元素的开始位置(包含开始位置)，默认为0，如果为负数，则表示从原数组的倒数第几个元素开始拷贝。
  end(可选): 拷贝元素的结束位置(不包括结束位置)，如果省略或大于数组长度，则拷贝到最后一个元素(包含最后一个元素)。如果为负数，则表示从拷贝到原数组的倒数第几个元素。
  ```

  **实例:**

  ```
  var a = [1, 2, 3, 4];
  var b = a.slice(1, 3);// [2, 3]
  var c = a.slice(1);// [2, 3, 4]
  var d = a.slice();// [1, 2, 3, 4]
  ```

- splice

  该方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组的形式返回被修改的内容，此方法会改变原数组。

  **语法:**

  ```
  array.splice(start, deleteCount, item1, item2, ...)
  ```

  **参数:**

  ```
  start:

  指定修改的开始位置，从 0 开始，如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表
  示从数组末位开始的第几位(从-1 计数，-n 表示倒数第 n 个元素);如果负数的绝对值大于数组长度，则表示开始位置为第 0 位。

  deleteCount(可选):

  表示要删除的元素个数，如果省略 deleteCount 或 deleteCount 的值大于 start 之后的元素的总数，则 start 后的元素都将被删除(含第 start 位);deleteCount 是 0 或负数，则不删除元素。

  item1, item2,...(可选):

  要添加进数组的元素，从 start 位置开始，如果不指定，则 splice()删除元素。

  ```

  **实例:**

  ```
  var a=[1,2,3,4,5];
  //1. a.splice(1, 3)从第二个元素开始删除三个元素 a 变为[1,5]
  //2. 元素 5、2、1 添加到数组删除的位置，则 a 变为[1, 5, 2, 1, 5]
  var b = a.splice(1,3,5,2,1); // b: [2, 3, 4]，为被删除的元素
  console.log(a);[1, 5, 2, 1, 5]

  ```

  - cancat

  该方法用于合并多个数组，此方法不会改变原数组，而是返回一个新数组。

  **语法:**

  ```
  var newArray = arr1.cancat(arr2, arr3, ..., arrN)
  ```

  **参数:**

  ```
  arrN: 要合并的数组
  ```

  **实例:**

  ```
  var arr1 = [1];
  var arr2 = [2];
  var arr3 = [3, 4];
  var newArr = arr1.concat(arr2, arr3);
  console.log(newArr);//[1, 2, 3, 4]
  ```

- sort
  该方法用于对数组的元素进行排序，并返回数组，此方法会改变原数组。

  ```
    /*
    compareFunction: 用于指定按照某种顺序进行排序的函数，如果省略，元
                      素按照转换为字符串的各个字符的Unicode编码顺序进行升序排序。
    compareFunction(a, b): a和b分别表示第一个比较的元素和第二个比较的元素，函数返回值决定了如何排序
                          1. 小于0则a排在b前面
                          2. 等于0，可能保持相对位置不变(并不是所有浏览器都遵守)
                          3. 大于0，则a排在b后面
    */
    array.sort(compareFunction)

    var a=['b','a'];
    //a的ASCII码比b的ASCII码小，所以a排在前面
    var b = a.sort(); //['a', 'b']
    console.log(a); // ['a', 'b']

    var c =[10, 2];
    //10，2转换为字符串'10', '2'进行比较，因为'1'比'2'的的ASCII码小，所以10排前面
    var d = c.sort(); //[10, 2]

    var e = c.sort((a, b) => a - b); //[10, 2]
  ```

- reverse
  该方法将数组中的元素位置颠倒，并返回颠倒后的数组，该方法会改变原数组。
  ```
  var a = [1, 2, 3];
  var b = a.reverse(); //[3, 2, 1];
  console.log(a); //[3, 2, 1];
  ```
