---
layout: post
title: 作用域链
category : js
tagline: "Supporting tagline"
tags : [js]
description: 通常，我们在函数内部使用函数外部的变量时会很自然，并没有想过为什么能够直接使用函数外部的变量而在函数外部却不能直接使用函数内部的变量，一切都显得理所当然。佛曰，凡事必有因，这个因就是作用域链。
date: 2017-4-05 18:10:20
---


### 执行上下文的生命周期

执行上下文的生命周期大概分为两个阶段，即创建阶段和执行阶段:

**1. 创建阶段**
- 创建作用域链(变量对象+父级执行上下文的变量对象)
- 创建变量对象(包括局部变量、函数以及函数参数)
- 确定this的指向

由此，一个执行上下文可以由包含作用域链、变量对象和this指针的对象组成:
```
executionContextObj = {
  scopeChain: {},
  variableObject: {},
  this: {}
}
```
**2. 代码执行阶段**
- 指定变量的值和函数的引用
- 解释并执行代码
  
### 变量对象(Variable Object, VO)

由前述，我们知道作用域链是由变量对象组成的，因此要理解作用域链就需要知道变量对象是如何创建的。其过程大致如下:

- 创建arguments对象，检查当前上下文的参数，初始化属性和属性值。
- 检查函数声明，当前上下文中每发现一个函数就在VO中用函数名创建一个属性，以此来引用函数。如果函数名存在，就覆盖这
  个属性。
- 检查变量，当前上下文中每发现一个变量就在VO中用变量名创建一个属性，并初始化其值为undefined。如果变量名存在，
  则不进行任何处理(注意这是在创建阶段，执行阶段会被赋值)，继续检查。

来看下面的例子:
```
function calcArea(r) {
  var width = 20;
  var squareArea = function squareArea() {
    return width * width;
  };

  function circleArea() {
    return 3.14 * r * r;
  };

  return circleArea() + squareArea();
}

calcArea(10);
```
当调用sum(10)时创建阶段的快照如下:
```
sumExecutionContext = {
  scopeChain: { ... },
  variableObject: {
    arguments: {
      0: 10,
      length: 1
    },
    r: 10,
    width: undefined,
    squareArea: undefined,
    circleArea: pointer to function circleArea()
  },
  this: { ... }
}
```
可以看到在创建阶段，只处理定义变量的名字，不为变量赋值，一旦创建完成进入执行阶段就会为变量赋值，其快照如下:
```
sumExecutionContext = {
  scopeChain: { ... },
  variableObject: {
    arguments: {
      0: 10,
      length: 1
    },
    r: 10,
    width: 20,
    squareArea: pointer to function squareArea(),
    circleArea: pointer to function circleArea()
  },
  this: { ... }
}
```
由此变量提升就比较容易理解了，来看如下例子
```
console.log(hello); // [Function: hello]
function hello() { console.log('how are u') }
var hello = 10;
```
可以看到打印输出的值为`[Function: hello]`，为什么能在变量声明前使用呢？我们来看上述代码的执行流程
- 首先进入全局上下文创建阶段，检查函数声明，将函数hello放入变量对象。
- 检查变量声明，发现变量hello已经存在，则跳过。
- 进入执行阶段，变量对象就变成了活动对象AO(Active Object，变成活动对象前，其内部属性不能被访问)，执行代码
  `console.log(hello)`时会先到当前上下文活动对象中寻找hello，找到了函数hello。

执行阶段执行上下文快照如下:
```
globalExecutionContext = {
  scopeChain: { ... },
  AO: {
    hello: pointer to function hello(),
  },
  this: window
}
```

### 作用域链

创建执行上下文时会生成对应的变量对象。
> 作用域链，是由当前环境与上层环境的一系列变量对象组成的，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。

来看下面的例子:
```
var firstName = 'Michael';
function getName() {
  var middleName = 'Jeffrey';
  function fullName() {
    var lastName = 'Jordan';
    return firstName + middleName + lastName;
  }
  return fullName();
}

getName();
```
上面的代码会创建三个执行上下文，全局上下文、函数getName上下文以及函数fullName上下文，它们的变量对象分别为VO(global)、VO(getName)以及VO(fullName)。
最里层的函数fullName的执行上下文如下:
```
fullNameEC = {
  VO: {...}, 
  scopeChain: [VO(fullName), VO(getName), VO(global)], // 作用域链
}
```
可以看到作用域链由一个数组构成，数组的第一个元素即链条的最前端为当前执行上下文的变量对象，数组的最后一个元素即链条的最末端为全局执行上下文的变量对象。当前执行上下文在执行阶段访问变量会先从作用域链的最前端开始查找变量，如果没有则向上查找，如此，直到全局上下文中的活动对象，返过来并不成立，也就是说在全局作用域并不能访问函数内部的变量。

<img style="display:block; margin: auto;" alt="执行栈示意图" src="https://i.imgur.com/BtAsvW7.png" />

