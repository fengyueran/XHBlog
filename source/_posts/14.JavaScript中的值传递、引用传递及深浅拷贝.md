---
layout: post
title: JavaScript中的值传递、引用传递及深浅拷贝
category : JS
tagline: "Supporting tagline"
tags : [JS]
description: 在JavaScript编程中经常会遇到改变了一个变量另一个变量情况，即使传给函数的参数的改变都可能导致原值被改变，这和其他某些语言并不太一样，值得去探究一下。
date: 2017-5-01 18:10:20
---

### **值传递** 
JS中值传递是对于基本数据而言的，包括boolean、null、undefined、String以及Number类型。在某些经典的系统语言(C等)中基本数据都是在栈空间分配，而JS这种动态语言不同，它没有明确的堆栈概念，变量如何分配内存依赖于具体的解释器。
如果将一个基本类型的数据绑定到一个变量，则该认为变量包含这个基本数据类型的值。如果我们将一个变量赋值给另一个变量，实际是将对应的值拷贝了一份给另一个变量。他们在内存中存在于不同的区域，一个变量的改变不会影响另一个变量。
如下，a赋值给b后，a值的改变并不会影响b值。
```
var a = 1;
var b = a;
a = 2;
console.log(a); // 2
console.log(b); // 1 
```
<center><img src="/images/14-1-value.png" width="500" /><center>

### **引用传递** 
引用传递是对于非基本类型而言的，包括Array, Function以及Object。
如果将一个非基本类型的数据绑定到一个变量，实际上是将非基本类型的数据地址赋值给了该变量，这个变量只包含了一个地址并没有包含实际的数据，这与值传递时拥有数据本身不同，这种赋值方式叫做引用传递。
如下，将变量m赋值给变量n后，m和n的值都为指向对象{ a:1, b: 2 }的地址，修改n，则m也会改变。

```
var m = { a:1, b: 2 };
var n = m;
n.a = 3;
console.log(m.a); // 3
console.log(n.a); // 3
```
<center><img src="/images/14-2-reference.png" width="500" /><center>

如果将一个已经赋值的变量重新赋值，那么它将包含新的数据或地址。
如下，在函数updateAgeAndRef内部，参数girl的age被修改为18，因为对象为引用传递，所以参数girl1的age也变成了18，接着又将新的对象赋值给了参数girl，因此girl指向了新的对象{ name: 'lucy', age: 20 }，所以girl2的age为20。
```
function updateAgeAndRef(girl) {
    girl.age = 18;
    girl = {
        name: 'lucy',
        age: 20
    };
    return girl;
}
var girl1 = {
    name: 'lily',
    age: 17
};
var girl2 = updateAgeAndRef(girl1);
console.log(girl1.age); // -> 18
console.log(girl2.age); // -> 20
```

### **深拷贝** 
深拷贝，其关键字就是深，原有对象在进行深拷贝时会将各层属性拷贝到新的内存，新实例的每一层属性都都不和原对象属性共享内存，也就是说新的实例和旧的实例是互不影响的。
深拷贝简单实现:
```
function deepCopy(target){
  if (typeof target === 'object') {
    var copyTarget = target.constructor === 'Array' ? [] : {};
    for (key in target) {
      copyTarget[key] = target[key];
      if (typeof target[key] === 'object') {
         copyTarget[key] = deepCopy(target[key]);
      } else {
        copyTarget[key] = target[key];
      }
    }
    return copyTarget;
  } 
}

var obj = { a: 1, b: { c: 2, d: 3 }};
var copyObj = deepCopy(obj);
obj.b.c = 6;
console.log(obj.b.c); // 6
console.log(copyObj.b.c); // 2
console.log(obj === copyObj); // false
console.log(obj.b === copyObj.b); // false
```

### **浅拷贝** 

浅拷贝只拷贝对象的地址，通过地址来指向原对象。前述的引用传递就是一种浅拷贝，此外在对对象进行拷贝时只对第一层进行深拷贝，其他层级对对象仍然采用拷贝地址的方式进行复制，这也称为浅拷贝。

浅拷贝简单实现:
```
function shallowCopy(target){
  if (typeof target === 'object') {
    var copyTarget = target.constructor === 'Array' ? [] : {};
    for (key in target) {
      copyTarget[key] = target[key];
    }
    return copyTarget;
  } 
}

var obj = { a: 1, b: { c: 2, d: 3 }};
var copyObj = shallowCopy(obj);
obj.a = 5;
obj.b.c = 6;
console.log(obj.a); // 5
console.log(copyObj.a); // 1
console.log(obj.b.c); // 6
//只对第一层进行了独立的复制，因此obj的b.c改变会造成copyObj的b.c改变
console.log(copyObj.b.c); // 6
//第一层深拷贝
console.log(obj === copyObj); // false
//第二层浅拷贝
console.log(obj.b === copyObj.b); // true
```