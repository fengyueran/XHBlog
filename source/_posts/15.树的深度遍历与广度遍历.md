---
layout: post
title: 树的深度遍历与广度遍历
category : js
tagline: "Supporting tagline"
tags : [js]
description: 作为一个非科班出生的前端开发人员，平时对数据结构与算法了解得相对较少，当谈到深度遍历与广度遍历时就一脸懵逼，于是查阅相关资料对其有一个基本认识并能够实现深度、广度遍历的方法。
date: 2017-6-26 26:11:08
---
### **基本概念**

树是一种数据结构，之所以称之为树是因为其结构类似于🌲，它的根在上，枝叶在下。
树中一个最基本的数据称为节点(Node)，对应于🌲中的每一个分叉。树具有一个根节点(root)，根节点之下可能具有多个节点，节点间通过边(edge)相连，表示它们之间的关系。这种结构类似于Html文档，公司的组织结构...

<center>![结构树示意图]](/images/tree.png)<center>
<center>图1.结构树示意图 <center>


### **树相关的术语**
- 根结点: 树最顶层结点，也是树中唯一一个没有父节点的节点，如图1中的0节点
- 边: 两个结点之间的连接
- 父结点: 一个节点有子节点则称这个节点是其子结点的父节点
- 兄弟结点: 具有相同父节点的节点互为兄弟节点，如图中的6、7、8
- 叶子结点: 树中没有子结点的结点(树得末端)，如图1中的6、7、8、9、5
- 层次: 节点的层次从根开始定义，根为第一层，根的子节点为第二层，依次类推
- 深度: 树中结点的最大层次称为树的深度

### **操作树**
在计算机科学中树是一种用来模拟分层数据的数据结构，树由多个节点构成，而每个节点都有自身的数据(data)及指向其他节点(parent、children)的指针，如下定义了节点和树。

#### 节点
- data: 节点的数据
- parent: 节点的父亲
- children: 节点的子节点

```
class Node {
  constructor(data) {
    this.data = data;
    this.parent = null;
    this.children = [];
  }
}
```

#### 树

树有一个根节点root
```
class Tree {
  constructor(data) {
    this._root = new Node(data);
  }
}
```

#### Tree的方法
接下来我们将要创建以下五种方法。

- traverseDF(callback)

- traverseBF(callback)

- contains(callback, traversalType)

- add(data, toId, traversalType)

- remove(node, parent)

**方法1/5: traverseDF(callback)**
这种方法以深度优先遍历树：从根节点出发，沿着左子树方向进行遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树的遍历，直到遍历完所有可到达的节点为止。对于图1来说深度优先遍历的结果是:
```
  traverseDF(callback) {
    const recuseNode = (node) => {
      for (let i = 0; i < node.children.length; i++) {
        recuseNode(node.children[i]);
      }
      callback(node);
    };
    recuseNode(this._root);
  }
```

**方法2/5: traverseBF(callback)**

这种方法以广度优先遍历树：从根节点出发，对每一层节点依次访问，访问一层进入下一层，而且每个节点只能访问一次。对于图1来说广度优先遍历的结果是:

```
  class Queue {
    constructor() {
        this.dataStore = [];
    }

    add(element) {
        this.dataStore.push(element);
    }

    pop() {
        return this.dataStore.shift();
    }
  }

  traverseBF(callback) {
    let currentTree = this._root;
    const queue = new Queue();
    while (currentTree) {
      for (let i = 0; i < currentTree.children.length; i++) {
        queue.add(currentTree.children[i]);
      }
      callback(currentTree);
      currentTree = queue.pop();
    }
  }
```

**方法3/5: contains(callback, traversalType)**
contains方法用于在树中搜索特定的值，它有两个参数，第一个为回调函数，每遍历到一个节点就会以该节点为回调参数回调，第二个为遍历的类型(深度遍历或广度遍历)
```
 contains(callback, traversalType) {
    const traverse = this[traversalType];
    traverse.call(this, callback);
  }

```

搜索特定id的节点就可以这样写：
```
tree.contains((node) => {
  if (node.id === '12345') {
    console.log(node);
  }
}, 'traverseDF');
```

**方法4/5: add(data, toId, traversalType)**

该方法用于在指定节点添加节点。
```
  add(data, toId, traversalType) {
    let parent = null;
    //遍历是否有目标节点
    this.contains((node) => {
      if (node.data === toId) {
        parent = node.parent;
      }
    }, traversalType);
    //有目标节点则添加节点
    if (parent) {
      const newNode = new Node(data);
      newNode.parent = parent;
      parent.children.push(newNode);
    } else {
      throw new Error(`can't find the target node`);
    }
  }
```

**方法5/5: remove(fromId, traversalType)**

该方法用于在指定节点下的节点。
```
  remove(fromId, traversalType) {
    let parent = null;
    let deleteNode = null;
    //遍历是否有目标节点
    this.contains((node) => {
      if (node.id === fromId) {
        parent = node.parent;
        deleteNode = node;
      }
    }, traversalType);

    //有目标节点则遍历目标节点的子节点是否有要删除的节点，有则删除
    if (parent) {
      const findIndex = parent.children.findIndex(node => deleteNode.id === node.id);
      if (findIndex >= 0) {
        parent.children.splice(findIndex, 1);
      }
    } else {
      throw new Error(`can't find the target node`);
    }
  }
```

#### 树的完整实现

```
class Queue {
  constructor() {
    this.dataStore = [];
  }
  
  add(element) {
    this.dataStore.push(element);
  }

  pop() {
    return this.dataStore.shift();
  }
}


class Node {
  constructor(data) {
    this.data = data;
    this.parent = null;
    this.children = [];
  }
}

class Tree {
  constructor(data) {
    this._root = new Node(data);
  }

  traverseDF(callback) {
    const recuseNode = (node) => {
      for (let i = 0; i < node.children.length; i++) {
        recuseNode(node.children[i]);
      }
      callback(node);
    };
    recuseNode(this._root);
  }

  traverseBF(callback) {
    let currentTree = this._root;
    const queue = new Queue();
    while (currentTree) {
      for (let i = 0; i < currentTree.children.length; i++) {
        queue.add(currentTree.children[i]);
      }
      callback(currentTree);
      currentTree = queue.pop();
    }
  }

  contains(callback, traversalType) {
    const traverse = this[traversalType];
    traverse.call(this, callback);
  }

  add(data, toId, traversalType) {
    let parent = null;
    this.contains((node) => {
      if (node.data === toId) {
        parent = node.parent;
      }
    }, traversalType);
    if (parent) {
      const newNode = new Node(data);
      newNode.parent = parent;
      parent.children.push(newNode);
    } else {
      throw new Error(`can't find the target node`);
    }
  }

  remove(fromId, traversalType) {
    let parent = null;
    let deleteNode = null;
    this.contains((node) => {
      if (node.id === fromId) {
        parent = node.parent;
        deleteNode = node;
      }
    }, traversalType);

    if (parent) {
      const findIndex = parent.children.findIndex(node => deleteNode.data === node.data);
      if (findIndex >= 0) {
        parent.children.splice(findIndex, 1);
      }
    } else {
      throw new Error(`can't find the target node`);
    }
  }
}


/*
遍历文件夹
RootDir
   ┆------DirA
   ┆       ┆──DirA1
   ┆       └──DirA2 
   ┆            └──DirA21            
   ┆------DirB
   ┆        └──DirB1
   └──------DirC
    
*/

const tree = new Tree('RootDir');

const nodeDirA = new Node('DirA');
const nodeDirA1 = new Node('DirA1');
const nodeDirA2 = new Node('DirA2');
const nodeDirA21 = new Node('DirA21');
nodeDirA.children.push(nodeDirA1);
nodeDirA1.parent = nodeDirA;
nodeDirA.children.push(nodeDirA2);
nodeDirA2.parent = nodeDirA;
nodeDirA2.children.push(nodeDirA21);
nodeDirA21.parent = nodeDirA2;
nodeDirA.parent = tree._root;
tree._root.children.push(nodeDirA);

const nodeDirB = new Node('DirB');
const nodeDirB1 = new Node('DirB1');
nodeDirB.children.push(nodeDirB1);
nodeDirB1.parent = nodeDirB;
nodeDirB.parent = tree._root;
tree._root.children.push(nodeDirB);

const nodeDirC = new Node('DirC');
nodeDirC.parent = tree._root;
tree._root.children.push(nodeDirC);

tree.traverseDF((node) => {
  console.log(node.data);
  /*
  => 
      DirA1
        DirA21
      DirA2
    DirA
      DirB1
    DirB
    DirC
  RootDir
  */
});

tree.traverseBF((node) => {
  console.log(node.data);
  /*
  => 
  RootDir
    DirA
    DirB
    DirC
      DirA1
      DirA2
      DirB1
        DirA21
  */
});

tree.contains((node) => {
  if (node.data === 'DirA1') {
    console.log(node);
  }
}, 'traverseDF');

tree.add('DirC1', 'DirC', 'traverseBF');
tree.traverseDF((node) => {
  console.log(node.data);
});
tree.remove('DirC1', 'traverseBF');
tree.traverseDF((node) => {
  console.log(node.data);
});