
---
layout: post
title: 函数的防抖与节流
category : js
tagline: "Supporting tagline"
tags : [js]
description: 最初接触到函数的防抖与节流是在lodash库中看到了这样一个函数throttle，当时的心理感受是mmp，这是啥，一查翻译，哦...原来，还是不懂。防抖与节流看着很高级，其实在日常的编程中也是经常遇到，值得我们拥有。
date: 2016-3-01 15:10:20
---

### **函数防抖(debounce)** 
当事件持续被触发时，并不立即执行事件处理函数，而是等到约定的时间后再执行，当约定的时间到来之前，又一次触发了事件则重新进行计时。
- 函数防抖的简单实现
处理函数通过fn.apply调用是为了能够保持debounce函数的this上下文且能够保留事件调用时的参数(e等)arguments为非箭头函数中可用的局部变量，为传递给函数的参数的伪数组。
```
const debounce = function(fn, wait) {
  let timer = null;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function() {
      fn.apply(context, args);
    }, wait)
  }
}
```
- 防抖函数应用场景
  比如在注册用户的时候，验证密码是否符合规范，我们并不需要在用户输入时频繁去验证，而是等到用户最后一次触发输入后，等待一定时间没有再输入，此时认为输入已经结束，可以进行验证了，这是符合逻辑的，也提升了性能。
  **无防抖效果:**
    <center><img src="/images/12-1-no-debounce.gif" width="500" /><center>

  **防抖效果:**
    <center><img src="/images/12-2-debounce.gif" width="500" /><center>


### **函数节流(throttle)** 
当事件持续被触发时，保证函数在一定时间内只执行一次事件处理函数。
- 函数节流的简单实现
  函数节流的实现主要有时间轴的方法和计时器的方法。时间轴的方法是通过比较事件触发时间与上一次函数执行时间(第一次为0，保证第一次一定执行)的差dt来判断是否执行事件处理函数，如果dt大于约定的时间则执行，反之则不执行；计时器的方法是在事件触发时，如果当前没有计时器则设置计时器来触发事件处理函数的执行。这两种方法对于最后一次触发事件，都有可能不会执行。
```
// 1.时间轴
const throttle = function(fn, wait) {
  //pre设置为0使得第一次一定执行
  let pre = 0;
  return function() {
    const now = Date.now();
    const context = this;
    const args = arguments;
    if (now - pre > wait) {
      fn.apply(context, args);
      pre = now;
    }
  }
}
// 2.计时器
const throttle = function(fn, wait) {
  let timer = null;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timer);
    if (!timer) {
      timer = setTimeout(function() {
        fn.apply(context, args);
        timer = null;
      }, wait)
    }
  }
}
```
  有些时候我们希望至少第一次和最后一次触发事件得到响应，这就可以结合时间轴和计时器的方法。
  如下，当事件最后一次触发时要么达到了约定的时间可以立即执行事件处理函数，要么设置一个timer等待约定的时间后执行。
```
const throttle = function(fn, wait) {
  let pre = 0;
  let timer = null;
  return function() {
    const context = this;
    const args = arguments;
    const now = Date.now();
    clearTimeout(timer);
    const dt = now - pre;
    if (dt > wait) {
      fn.apply(context, args);
      pre = now;
    } else {
      timer = setTimeout(function() {
        fn.apply(context, args);
      }, wait)
    }
  }
}
```

- 节流函数应用场景
  比如在客户端搜索，服务器返回搜索结果时我们希望尽快刷新搜索结果，但又不希望频繁的向服务器请求结果导致性能下降，节流就是一个很好的选择。
  **无节流效果:**
    <center><img src="/images/12-3-no-throttle.gif" width="500" /><center>

  **节流效果:**
    <center><img src="/images/12-4-throttle.gif" width="500" /><center>

