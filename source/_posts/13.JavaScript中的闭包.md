---
layout: post
title: JavaScript中的闭包
category: js
tagline: "Supporting tagline"
tags: [js]
description: 闭包，相信第一次接触到这个词的同学，都会觉得一脸懵逼，这是啥玩意儿，好高端的样子。看看书看看报，闭包似乎没有那么难。
date: 2016-3-02 15:15:21
---

### **闭包的概念**

闭包简单的说就是能够访问其他函数内部变量的函数，更确切的说，闭包不是指某一个具体的东西，而是指由这个函数以及创建创该函数的词法环境(包含了创建时所能访问到的所有局部变量)共同组成的一个抽象的概念。
来看下面的例子:
显然，函数 log 可以访问函数外的全局变量 name，但是直接在函数外访问函数内部的局部变量 age 则不行

```
var name = 'xhm';
function log {
  var age = 18;
  console.log(name)
}
log();
```

实在想访问函数中的局部变量怎么办呢？既然直接在函数外边不行那我们就在函数内部访问。
如下，函数 getAge 放到了 log 函数的内部，由于 JS 的作用域链，getAge 函数在寻找 age 时会先在自己的作用域下寻找，如果没有则一级一级往上寻找，直到找完所有父对象的变量，因此 getAge 可以访问到父对象 log 函数的局部变量，根据前述闭包的概念，getAge 函数就是一个闭包。

```
function log {
  var age = 18;
  function getAge() {// 闭包
    console.log(age) // 能够读取函数log的局部变量age
  }
  getAge();
}
log();
```

### **闭包的应用**

根据闭包的特性，我们可以利用闭包将函数和操作环境联系起来，类似于 OOP 编程的效果。
来看下面的例子:
本钱有 1800，earnMoney()、earnMoney()每天都能赚一块钱，苦逼 😫，我想静静。
可以看到局部变量 money 一直都在，并没有在函数 makeMoney 执行完后清空，为什么呢？因为 saveMoney 函数的作用域链仍然引用着这个变量，直到 saveMoney 函数被销毁后，闭包作用域链上的变量才会被销毁。

```
function makeMoney() {
  var money = 1800;
  return function saveMoney() {
    return ++money;
  }
}
// 通过闭包，使在函数外部能够访问函数内部的变量
const earnMoney = makeMoney();
console.log(earnMoney());// 1801
console.log(earnMoney());// 1802
```

### **闭包使用的注意事项**

- 性能考量
  闭包在处理速度和内存消耗方面都对脚本性能有负面影响。
- 循环中创建闭包
  下列中因为 i 是五次循环共享的，循环五次后 i 已经变成 5 了，所以会输出 5 个 5。
  ```
    for(var i=0;i<5;i++){
      setTimeout(function(){
          console.log(i); // 5个5
      },1000)
    }
    等同于
    var i = 0;
    for(;i<5;i++){
      setTimeout(function(){
          console.log(i); // 5个5
      },1000)
    }
  ```
  避免方法
  - 用 let 声明变量
    es6 中的 let 使得声明的变量具有块级作用域，i 并不共享，因此循环后可以得到正确的值。
    ```
    for(let i=0;i<5;i++){
      setTimeout(function(){
          console.log(i); // 0 1 2 3 4
      },1000)
    }
    ```
  - 添加闭包
    通过创建匿名闭包将事件回调同循环时的 i 值关联起来。
  ```
  for(var i=0;i<5;i++){
    ((j) => {
      setTimeout(function(){
        console.log(j); // 0 1 2 3 4
    },1000)})(i)
  }
  ```
  等同于
  ```
    var callback = function (num) {
    setTimeout(function() {
          console.log(num); // 0 1 2 3 4
      },1000)
  }
  for(var i=0;i<5;i++){
    callback(i)
  }
  ```
