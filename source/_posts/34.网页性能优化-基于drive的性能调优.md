---
layout: post
title: 网页性能优化
category: js
tagline: "Supporting tagline"
tags: [js]
description:
date: 2019-1-05 18:10:20
---

### 研究概况

- 研究内容

  本次研究的主要内容为基于 drive 这个项目的性能优化，这里的性能优化主要是指减少首页的加载时间，具体点说就是减少 drive 首页的加载时间。加载时间主要由浏览器发起请求获得资源的时间和资源获取后解析渲染的时间，我的主要研究内容为前半部分，即资源获取时间。以下的工作基本上都是围绕如何降低资源获取时间来展开，包括减少资源大小，减少网络请求等等。对于影响解析渲染速度的因素暂不做研究。

- 评估方法

  通过 chrome 自有工具 audit 进行跑分评测，以下为 drive 在没有优化前的初始测评(以 commit 189440 作为起始):
  以本地搭建的 drive 环境为基础，没有安装其他 app，也没有用户上传的文件。通过 chrome Audits 测评，其初始性能表现评分为：Performance: 35

  <img style="display:block; margin: auto;border: 1px solid" alt="drive初始评分" src="https://i.imgur.com/HWUqiB7.png" />
  <center>图1. drive初始评分</center>

- 研究目的

  1）drive 性能评分提高到 85 分
  2）给出性能优化的指导性建议

- 研究周期

  3 个月。

### 测量工具

- chrome 自带的 audits

  Chrome DevTools 自带的测试工具，早期版本叫做 lighthouse，可以测量性能、最佳实践、SEO 等，本地调试比较方便。

- [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)

  谷歌的一个性能测试平台，它可以通过谷歌收集的用户数据进行测试，可以模拟更为真实的用户环境，有详细的测试报告。

- [WebPageTest](https://www.webpagetest.org/)

  性能测试平台，能提供各种环境测试，非常适合移动的设备，此外对比测试也比较方便。

- [pingdom](https://tools.pingdom.com/)

  性能测试平台，提供非常详细的性能测试结果。

### drive 初始测评

- 测试环境

  ```
  测试工具：chrome audits模块
  Device: Desktop
  Throttling: Simulated Slow 3G，4x CPU Slowdown
  ```

- 测试结果

  <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/R23SwLg.png" />
     <center>图2. drive初始测试结果</center>
  从图中可以看到，测试结果给出了优化的方向：
  - 消除阻塞的资源
  - 减小JavaScript
  - 删除无用的css
  - 添加缓存策略
  - 减少JS执行时间
  - 减少关键路径
  有了优化的建议，就可以根据这些优化方向进行一些测试及优化。

### 研究内容

- audits 在 simulated fast 3g 条件的准确性测试

  在测试的过程中发现 audits 在 simulated fast 3g 条件测得的 FCP、Load 时间与实际并不相符，于是进行了如下测试。
  一个简单的 html，html 加载一个 css，server 延迟 5s 返回这个 css。由于 CSS 会阻塞渲染，因此 FCP 应该 大于 5 秒。

  <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/HC863nR.png" />
     <center>图2. 基础html</center>

  fast 3g 下的加载时间为 5.02s，如下
  <img style="display:block; margin: auto;border: 1px solid"  src="https://i.imgur.com/jP3kXjc.png" />

  <center>图2. html加载时间</center>

  通过 audits simutalated 3g 测试结果如下：
  <img style="display:block; margin: auto;border: 1px solid"  src="https://i.imgur.com/pbQkojY.png" />

  <center>图2. audits测试结果</center>

  可以看到 audits 测试得到的 FCP 为 0.8s，与实际不符，此外，通过 chrome dvtool 的 Performance 模块测试， FCP 为 5056ms。说明 audits simutalated 3g 的模拟算法并不会采用实际的延迟，因此在后续的测试都采用 chrome 的 performance 工具进行测试。

- 浏览器请求资源个数与 Load(资源下载完成时间，包括 css)、FCP(首次内容绘制)时间的关系测试

  1）测试环境

  ```
  测试工具：chrome dvtool Performance模块
  测试方法：测试3次的平均值
  Network: Fast 3G
  CPU: 4 x slowdown
  ```

  2）测试方法

  一个 简单的 html，大小为 1b 的 css(下载 css 本身消耗的时间可以忽略)，通过 link 属性逐步增加测试的 css 个数，从 1 个增加到 6 个，因为 chrome 最大并发数为 6，再增加到 7 个(需要排队请求)，再增加到 12 个，再增加到 13 个，测试随着 css 请求个数的增加 FCP 等指标的变化。

    <img style="display:block; margin: auto;border: 1px solid" alt="简单的html" src="https://i.imgur.com/HC863nR.png" />
     <center>图2. 基础html</center>

  因为 css 会阻塞渲染，因此需要下载完成后才能绘制出 body 的内容 123(FCP 绘制的内容)，也就能通过改变 css 的个数来影响 Load 和 FCP 时间。

  3）测试结果

  从图 2 中可以看到，增加 css 的个数并不会对 FCP 有明显影响，直到 css 增加到 7 个，因为 chrome 最大并行请求数为 6，前 6 个资源为并行请求(如图 3)，可以认为前六个请求为一个请求。当增加到 7 个 css 时曲线斜率有明显提升，FCP 增加了 400 多毫秒，增加 http 请求数的影响就显现出来了，同样当有 13 个 css 时，第 13 个 css 需要添加到新的一轮队列(如图 4)，此时，FCP 增加了近 500ms，即使请求的资源大小近乎为 0 也是如此。所以当请求的资源较多时减少 http 请求数是很有必要的。
  <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/HiqBK8X.png" />

     <center>图 2. 请求数量与 FCP 时间的关系图</center>

    <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/wSkvtVp.png" />
      <center>图2. 7个css请求示意图</center>

    <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/AaR5gfw.png" />
      <center>图2. 13个css请求示意图</center>

- 验证首页资源应小于 14kb

  前面的测试表明减少 http 请求数的必要性，而通过内联资源到首页的 html 则可以减少请求数，那么内联多大的资源比较合适呢？

  为了防止网络拥堵和丢包 [[ https://hpbn.co/building-blocks-of-tcp/#slow-start | TCP ]] 会采取慢启动、拥塞避免等策略，使得任何一次往返可传输的最大数据量是 14kb，无论 HTML、CSS 和脚本都是如此。

  因此如果一次请求中，HTML 或者任何累积的资源超过了 14kb(1453b 左右)，那么就需要多做一次往返来获取它们。

  当然，这是理论，秉着实践出真知的理念，现对 14kb 这个限制进行测试。

  1）测试环境
  同上， 在[fast 3g](https://github.com/WPO-Foundation/webpagetest/blob/master/www/settings/connectivity.ini.sample)条件下进行测试，下行速度大概 204kb/s。

  ```
  [3GFast]
   label="3G Fast (1.6 Mbps/768 Kbps 150ms RTT)"
   bwIn=1600000(下行bps)
   bwOut=768000(上行bps)
   latency=150(延迟)
   plr=0(丢包率)
   timeout=120
  ```

  2）测试的方法
  通过内联 css 对 html 大小进行动态调整，对比不同资源大小下的加载时间(load 时间)和首次内容绘制时间(First Contentful Paint，FCP)，着重观察跨越 14kb 前后的时间差。


    <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/xYznLy0.png" />
     <center>图2. 基础html</center>

3）测试结果

   <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/UktpBBq.png" />
     <center>图2. 基础html</center>

     可以看到在14kb前后FCP并无明显变化，在html为14574b时，通过wireshark抓包结果如下：

   <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/cFHK0iA.png" />
     <center>图2. 基础html</center>

    可以看到一次传输最大最大的数据量 MSS 为 16344，html 大小为 14574b 时实际并没有拆包，在 92 帧服务器向客户端发送确认信息后，在 93 帧直接将 html 完成。

    由此在 html 大小超过 16344 时会拆包并会对一个 RTT(往返延时)，此时请求时间应明显增大，html 大小为 16423b 时的抓包信息如下：

  <img style="display:block; margin: auto;border: 1px solid" src="https://i.imgur.com/y6GLOpG.png" />
     <center>图2. 基础html</center>

可以看到 html 的发送分为了 211 和 212 帧，分成了两次，但 FCP 和 Load 时间并没有大的变化。

### 结论

- 减少 HTTP 请求数量

### 成果
