---
layout: post
title: 每日一题
category : subject
tagline: "Supporting tagline"
tags : [subject]
description: 前端题集
date: 2017-1-04 21:36:05
---

**1、** `<img>`的title和alt有什么区别

- title是鼠标移动到元素显示的值
- alt是`<img>`特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。

**2、** 从浏览器地址栏输入url到显示页面的步骤

- 浏览器根据请求的url，交给DNS解析域名找到真实的Ip，向服务器请求数据。
- 服务器处理完成返回数据，浏览器接收数据(Html、js、css、image等)
- 浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom等)
- 载入解析到的资源文件，渲染页面、完成。


**3、**js遍历li的内容
```
<ul>
  <li>1</li>
  <li>2</li>
</ul>
```
=>
```
  const u = document.querySelector('ul');
  const lis = u.children;
  for(let i = 0; i < lis.length; i++) {
    const li = lis[i];
    console.log(li.innerText);
  }
  或
  const realArr = [].slice.call(lis);
  realArr.forEach((li) => {
    console.log(li.innerText)
  })

```
**4、** JavaScript`===`和`==`的区别
`===`即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换
`==`即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如相等则相等。
需要指出的是NaN不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0等于(==或===)-0(对于0而言没有正负之分)。


**5、** JavaScript中null和undefined的区别
由于历史原因JavaScript中有null和undefined两个表示无的值，其区别很小，主要在于：
- null的类型为Object，undefined的类型为undefined
- Number(null)为0，Number(undefined)为NaN
- null表示没有对象，此处不该有值，undefined表示此处应该有值暂时缺少这个值

**6、** 常见http code及其含义
- 信息响应(1xx)
  表示服务器收到请求，需要请求者继续执行操作
  - 100 Continue: 客户端应继续其请求。
- 成功(2xx)
  表示服务器成功接收请求并处理返回
  - 200 Ok: 请求正常处理完毕。一般用于GET与POST请求
  - 204 No Content: 服务器成功处理了请求但未返回任何内容
  - 206 Partial Content: 服务器成功处理了部分get请求
- 重定向(3xx)
  表示需要客户端进一步操作才能完成请求
  - 301 Moved Permanently: 永久重定向，请求的资源已永久移动到新URI
  - 302 Found: 临时重定向，资源临时移动到新的位置
  - 304 Not Modified: 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。
  - 307 Temporary Redirect: 临时重定向，不允许更改请求方法
- 客户端错误(4xx)
  表示客户端可能发生了错误
  - 400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解
  - 401 Unauthorized: 要求身份验证
  - 403 Forbidden: 服务器理解请求但拒绝执行
  - 404 Not Found: 服务器没有找到资源
- 服务器错误(5xx)
  表示服务器无法完成请求
  - 500 Internal Server Error: 服务器遇到未知问题，无法处理请求
  - 503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求


**7、**  Cookie, SessionStorage与LocalStorage区别

[demo](https://github.com/fengyueran/web-cache-demo.git)
- 储存大小
  - Cookie: 4kb左右
  - SessionStorage: 一般为5M
  - LocalStorage: 一般为5M
- 生命周期
  - Cookie: 默认是关闭浏览器后失效，可以设置失效时间
  - SessionStorage: 仅在当前会话有效，关闭tab页即失效
  - LocalStorage: 持久缓存除非主动清除(通过浏览器或JS)
- 与服务器通信
  - 每次请求都会携带在http请求头中，可能带来性能问题
  - SessionStorage: 只在客户端起作用
  - LocalStorage: 只在客户端起作用

**8、**  html代码中让链接在新窗口中打开的写法

通过设置a标签的target属性为_blank可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过window.openner访问原页面的窗口对象，并且可以通过window.opener.location = newURL将原页面导航至不同的网址。因此需要通过ref="noopenner"来禁用window.opener。
```
  <div>
    <div>
      <a href="http://www.xinghunm.com">Welcome -  old window</a>
    </div>
    <div>
        <a href="http://www.xinghunm.com" target="_blank" ref="noopenner">Welcome -  new window</a>
    </div>
  </div>
```

**9、**  html5有哪些新特性

  - 用于绘画的canvas元素
  - 用于媒介回放的vedio和audio元素
  - 新增sessionStorage和localStorage对离线缓存更好的支持
  - 新的特殊内容元素，如article、header、footer、nav、section
  - 新的表单控件，如calendar、date、time、email、url、search

**10、**  谈谈对盒模型的理解

  浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为W3C标准盒模型和IE盒模型，W3C标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而IE盒模型的大小只由内容区域的大小(自定义的width和height)决定。css可以通过box-sizing来切换两种盒模型。
  - 矩形盒子
    - W3C标准盒模型(box-sizing: content-box)
      size = content + border + padding
    - IE盒模型(box-sizing: border-box)
      size = content
  我们在编写html时若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒模型，FireFox等会将其解释为W3C盒子模型，从而渲染出不同的结果。

**11、**  主流的浏览器内核有哪些

- Trident
  Trident为在早期的IE内核，没有使用W3C标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。
- Gecko
  Gecko(火狐内核)，代码开源，也是一个跨平台内核。
- Presto
  Presto(Opera前内核)，渲染速度快兼容性差，现已废弃而采用Google Chrome的Blink内核。
- Webkit
  Webkit(Safari内核)，主要由渲染引擎WebCore和javascript解释引擎JSCore组成，代码开源。
- Chromium/Blink
  2008年谷歌发布了chrome浏览器，其内核被命名为chromium，chromium代码fork自开源引擎webkit并对其进行重新梳理。
  2013年谷歌决定从WebKit衍生出自己的Blink(WebKit的分支)引擎，后由Google和Opera Software共同研发。
  
**12、**  前端页面分层

- 结构层
  由HTML或XHTML创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。
- 表示层
  由CSS创建，CSS对如何显示这些标签内容进行了回答。
- 行为层
  行为层回答了内容应该如何对事件作出反应

**13、**  以下输出的内容

函数作用域内var声明是局部变量
```
var a = 1;
function func(){console.log(a);var a = "in";}
func();
=> undefined
```

**14、**  以下输出的内容

```
(
  function func() {
    var a = b ='res';
  }
)();

//b前面没有跟着var相当于全局变量，所有输出res
console.log(b);//res
//a前面没有跟着var所以a是局部变量，所有输出undefined
console.log(a);
```

**15、**  用js写一个继承实例

```
function Parent(name, age) {
  this.name = name;
  this.age = age;
  function getName() {
    console.log(this.name);
  }
}

function Child(name, age) {
  Parent.call(this, name, age)
  this.weight = 120;
}

const snow = new Child('snow', '20');
console.log(snow.name)
```

**16、**  匹配文档中的关键字

```
  const colorKeyWords = (node, targetValue) => {
    const HIGHLIGHT_COLOR = "orange";  
    const highlightTag = "<span style='background-color: "+HIGHLIGHT_COLOR+";'>" + targetValue + "</span>";
    let htmlStr = node.innerHTML;

    const targetReg = new RegExp(targetValue, "ig");
    htmlStr = htmlStr.replace(targetReg, highlightTag);
    node.innerHTML = htmlStr;
  }
```

**17、**  单击以下node时获取node的属性title和内容`<div id="xhm" title="blog">my blog</div>`

```
const node = document.getElementById("xhm");
node.addEventListener('click', ()=> {
  console.log(node.innerText); // my blog
  console.log(node.getAttribute('title')); // blog
})
```

**18、**  link和@import的区别

- 从属关系不同
  link属于XHTML提供的标签，除了加载CSS外还可以做其他事情，比如定义RSS、定义rel连接属性等，而@import只能用于加载CSS。

- 加载时机不同
  link引用CSS时，在页面加载的同时加载，而@import引用的CSS要在页面加载完后再加载。

- 兼容性不同
  link属于XHTML标签，无兼容性问题。而@import是在CSS2.1提出的，低版本浏览器不支持。

- DOM可控性的不同
  link支持使用JavaScript控制DOM去改变样式，而@import不支持。


**19、** 修改chrome浏览器表单自动填充后的黄色背景

- 取消chrome的自动填充

```
 <input autoComplete="new-password" />
```

- 设置内阴影来覆盖黄色背景
  
```
&: -webkit-autofill {
  -webkit-box-shadow: 0 0 0 1000px white inset;
  -webkit-text-fill-color: black;
}
```

- 设置动画
  
通过动画设置其背景永远为透明。
  
```
 &:-webkit-autofill {
    animation: autofill-fix 1s infinite;
  }
 
 @keyframes autofill-fix {
   from {
     background-color: transparent;
   }
   to {
      background-color: transparent;
   }
 }
```

**20、** JavaScript数据类型

- 基本数据类型
  - undefined
  - Null
  - Boolean
  - String
  - Number
  - Symbol(new in ES6)
- 引用数据类型(Object类型)
  - Object
  - Array
  - Date
  - RegRxp
  - Function
  

**21、** js将一浮点数小数点左边的数字每三位加一个逗号

- 利用parseInt的toLocaleString方法
```
const formatNum = (num) => num.toString().replace(/(\d+)(.*)/g, (match, s1, s2) => `${parseInt(s1).toLocaleString()}${s2}`)

formatNum(15234555.55)
=> "15,234,555.55"
```

- 完全用正则替换
  
```
//当一个字符串中某个数字后跟着n对三个数字(\d{3})就匹配这个数字
const formateNum = (num) => {
  const numStr = num.toString();
  //替换小数点左边的数字
  return numStr.replace(/\d+/, (match) => {
    //替换目标数字为`${matchNum},`
    return match.replace(/(\d)(?=(\d{3}+$))/, (s1) => `${s1},`);
  })
}

formateNum(435345.656)
=> "435,345.656"
```





