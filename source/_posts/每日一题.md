---
layout: post
title: 每日一题
category : subject
tagline: "Supporting tagline"
tags : [subject]
description: 前端题集
date: 2017-1-04 21:36:05
---

**1、** `<img>`的title和alt有什么区别

- title是鼠标移动到元素显示的值
- alt是`<img>`特有的属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提高图片的可访问性，除了纯装饰图片都应设置有意义的值，搜索引擎会重点分析。

**2、** 从浏览器地址栏输入url到显示页面的步骤

- 浏览器根据请求的url，交给DNS解析域名找到真实的Ip，向服务器请求数据。
- 服务器处理完成返回数据，浏览器接收数据(Html、js、css、image等)
- 浏览器对请求回的资源进行语法分析，建立相应的内部数据结构(Dom等)
- 载入解析到的资源文件，渲染页面、完成。


**3、**js遍历li的内容
```
<ul>
  <li>1</li>
  <li>2</li>
</ul>
```
=>
```
  const u = document.querySelector('ul');
  const lis = u.children;
  for(let i = 0; i < lis.length; i++) {
    const li = lis[i];
    console.log(li.innerText);
  }
  或
  const realArr = [].slice.call(lis);
  realArr.forEach((li) => {
    console.log(li.innerText)
  })

```
**4、** JavaScript`===`和`==`的区别
`===`即严格相等，它会比较等式两边值的类型和值是否相等，不会进行隐式转换
`==`即宽松相等，进行比较前会将等式两边值转换为同一类型(两边都可能被转换)，再进行值的比较，如相等则相等。
需要指出的是NaN不等于任何值包括它自己(如正无穷不应该等于负无穷)，+0等于(==或===)-0(对于0而言没有正负之分)。


**5、** JavaScript中null和undefined的区别
由于历史原因JavaScript中有null和undefined两个表示无的值，其区别很小，主要在于：
- null的类型为Object，undefined的类型为undefined
- Number(null)为0，Number(undefined)为NaN
- null表示没有对象，此处不该有值，undefined表示此处应该有值暂时缺少这个值

**6、** 常见http code及其含义
- 信息响应(1xx)
  表示服务器收到请求，需要请求者继续执行操作
  - 100 Continue: 客户端应继续其请求。
- 成功(2xx)
  表示服务器成功接收请求并处理返回
  - 200 Ok: 请求正常处理完毕。一般用于GET与POST请求
  - 204 No Content: 服务器成功处理了请求但未返回任何内容
  - 206 Partial Content: 服务器成功处理了部分get请求
- 重定向(3xx)
  表示需要客户端进一步操作才能完成请求
  - 301 Moved Permanently: 永久重定向，请求的资源已永久移动到新URI
  - 302 Found: 临时重定向，资源临时移动到新的位置
  - 304 Not Modified: 表示资源在由请求头中的If-Modified-Since或If-None-Match参数指定的这一版本之后没有被修改，客户端仍能够拿到该资源的缓存无需再次传送。
  - 307 Temporary Redirect: 临时重定向，不允许更改请求方法
- 客户端错误(4xx)
  表示客户端可能发生了错误
  - 400 Bad Request: 由于明显的客户端错误(格式错误，太大的大小等)，服务器无法理解
  - 401 Unauthorized: 要求身份验证
  - 403 Forbidden: 服务器理解请求但拒绝执行
  - 404 Not Found: 服务器没有找到资源
- 服务器错误(5xx)
  表示服务器无法完成请求
  - 500 Internal Server Error: 服务器遇到未知问题，无法处理请求
  - 503 Service Unavailable: 由于过载或临时的服务器维护导致的服务器暂时无法处理请求


**7、**  **Coo**kie, SessionStorage与LocalStorage区别

[demo](https://github.com/fengyueran/web-cache-demo.git)
- 储存大小
  - Cookie: 4kb左右
  - SessionStorage: 一般为5M
  - LocalStorage: 一般为5M
- 生命周期
  - Cookie: 默认是关闭浏览器后失效，可以设置失效时间
  - SessionStorage: 仅在当前会话有效，关闭tab页即失效
  - LocalStorage: 持久缓存除非主动清除(通过浏览器或JS)
- 与服务器通信
  - 每次请求都会携带在http请求头中，可能带来性能问题
  - SessionStorage: 只在客户端起作用
  - LocalStorage: 只在客户端起作用

**8、**  html代码中让链接在新窗口中打开的写法

通过设置a标签的target属性为_blank可以在新窗口打开链接，但是由于新页面与原页面在一个进程上，如果新页面开销极大则会对原页面性能造成影响。此外新页面还可通过window.openner访问原页面的窗口对象，并且可以通过window.opener.location = newURL将原页面导航至不同的网址。因此需要通过ref="noopenner"来禁用window.opener。
```
  <div>
    <div>
      <a href="http://www.xinghunm.com">Welcome -  old window</a>
    </div>
    <div>
        <a href="http://www.xinghunm.com" target="_blank" ref="noopenner">Welcome -  new window</a>
    </div>
  </div>
```

**9、**  html5有哪些新特性

  - 用于绘画的canvas元素
  - 用于媒介回放的vedio和audio元素
  - 新增sessionStorage和localStorage对离线缓存更好的支持
  - 新的特殊内容元素，如article、header、footer、nav、section
  - 新的表单控件，如calendar、date、time、email、url、search

**10、**  谈谈对盒模型的理解

  浏览器在对文档进行布局时，会根据盒模型(CSS Basic Box model)将所有元素表示成一个矩形盒子，矩形盒子的组成由内容区域、边框、内边距及外边距组成。如下盒模型分为W3C标准盒模型和IE盒模型，W3C标准盒模型的大小由内容区域(content)、边框(border)、内边距(padding)决定，而IE盒模型的大小只由内容区域的大小(自定义的width和height)决定。css可以通过box-sizing来切换两种盒模型。
  - 矩形盒子
    - W3C标准盒模型(box-sizing: content-box)
      size = content + border + padding
    - IE盒模型(box-sizing: border-box)
      size = content
  我们在编写html时若不声明DOCTYPE类型，IE浏览器会将盒子模型解释为IE盒模型，FireFox等会将其解释为W3C盒子模型，从而渲染出不同的结果。

**11、**  主流的浏览器内核有哪些

- Trident
  Trident为在早期的IE内核，没有使用W3C标准，国内多数浏览器(360、腾讯、搜狗等)都采用过该内核。
- Gecko
  Gecko(火狐内核)，代码开源，也是一个跨平台内核。
- Presto
  Presto(Opera前内核)，渲染速度快兼容性差，现已废弃而采用Google Chrome的Blink内核。
- Webkit
  Webkit(Safari内核)，主要由渲染引擎WebCore和javascript解释引擎JSCore组成，代码开源。
- Chromium/Blink
  2008年谷歌发布了chrome浏览器，其内核被命名为chromium，chromium代码fork自开源引擎webkit并对其进行重新梳理。
  2013年谷歌决定从WebKit衍生出自己的Blink(WebKit的分支)引擎，后由Google和Opera Software共同研发。
  
**12、**  前端页面分层

- 结构层
  由HTML或XHTML创建，通过语义化的标签来描述页面的局部结构(不包含如何显示这些标签的内容)，从而构建出整个页面的结构。
- 表示层
  由CSS创建，CSS对如何显示这些标签内容进行了回答。
- 行为层
  行为层回答了内容应该如何对事件作出反应

**13、**  以下输出的内容

函数作用域内var声明是局部变量
```
var a = 1;
function func(){console.log(a);var a = "in";}
func();
=> undefined
```

**14、**  以下输出的内容

```
(
  function func() {
    var a = b ='res';
  }
)();

//b前面没有跟着var相当于全局变量，所有输出res
console.log(b);//res
//a前面没有跟着var所以a是局部变量，所有输出undefined
console.log(a);
```

**15、**  用js写一个继承实例

```
function Parent(name, age) {
  this.name = name;
  this.age = age;
  function getName() {
    console.log(this.name);
  }
}

function Child(name, age) {
  Parent.call(this, name, age)
  this.weight = 120;
}

const snow = new Child('snow', '20');
console.log(snow.name)
```

**16、**  匹配文档中的关键字

```
  const colorKeyWords = (node, targetValue) => {
    const HIGHLIGHT_COLOR = "orange";  
    const highlightTag = "<span style='background-color: "+HIGHLIGHT_COLOR+";'>" + targetValue + "</span>";
    let htmlStr = node.innerHTML;

    const targetReg = new RegExp(targetValue, "ig");
    htmlStr = htmlStr.replace(targetReg, highlightTag);
    node.innerHTML = htmlStr;
  }
```

**17、**  单击以下node时获取node的属性title和内容`<div id="xhm" title="blog">my blog</div>`

```
const node = document.getElementById("xhm");
node.addEventListener('click', ()=> {
  console.log(node.innerText); // my blog
  console.log(node.getAttribute('title')); // blog
})
```

**18、**  link和@import的区别

- 从属关系不同
  link属于XHTML提供的标签，除了加载CSS外还可以做其他事情，比如定义RSS、定义rel连接属性等，而@import只能用于加载CSS。

- 加载时机不同
  link引用CSS时，在页面加载的同时加载，而@import引用的CSS要在页面加载完后再加载。

- 兼容性不同
  link属于XHTML标签，无兼容性问题。而@import是在CSS2.1提出的，低版本浏览器不支持。

- DOM可控性的不同
  link支持使用JavaScript控制DOM去改变样式，而@import不支持。


**19、** 修改chrome浏览器表单自动填充后的黄色背景

- 取消chrome的自动填充

```
 <input autoComplete="new-password" />
```

- 设置内阴影来覆盖黄色背景
  
```
&: -webkit-autofill {
  -webkit-box-shadow: 0 0 0 1000px white inset;
  -webkit-text-fill-color: black;
}
```

- 设置动画
  
通过动画设置其背景永远为透明。
  
```
 &:-webkit-autofill {
    animation: autofill-fix 1s infinite;
  }
 
 @keyframes autofill-fix {
   from {
     background-color: transparent;
   }
   to {
      background-color: transparent;
   }
 }
```

**20、** JavaScript数据类型

- 基本数据类型
  - undefined
  - Null
  - Boolean
  - String
  - Number
  - Symbol(new in ES6)
- 引用数据类型(Object类型)
  - Object
  - Array
  - Date
  - RegRxp
  - Function
  

**21、** js将一浮点数小数点左边的数字每三位加一个逗号

- 利用parseInt的toLocaleString方法
```
const formatNum = (num) => num.toString().replace(/(\d+)(.*)/g, (match, s1, s2) => `${parseInt(s1).toLocaleString()}${s2}`)

formatNum(15234555.55)
=> "15,234,555.55"
```

- 完全用正则替换
  
```
//当一个字符串中某个数字后跟着n对三个数字(\d{3})就匹配这个数字
const formateNum = (num) => {
  const numStr = num.toString();
  //替换小数点左边的数字
  return numStr.replace(/\d+/, (match) => {
    //替换目标数字为`${matchNum},`
    return match.replace(/(\d)(?=(\d{3}+$))/, (s1) => `${s1},`);
  })
}

formateNum(435345.656)
=> "435,345.656"
```

**22、** HTML常见的内联元素和块级元素
- 内联元素
  - a
  - img
  - input
  - label
  - span
  - br
  - select

- 块级元素
  - div
  - h1-h6
  - form
  - hr
  - p
  - ul
  - table
  - option

**23、** 移动开发中使用rem的优点

rem是CSS3新增的一个单位即root em，它与em的区别在于em是相对父元素的font-size，而rem相对的是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。因此对于移动开发而言，只要通过媒体查询来根据不同的屏幕宽度设置`<html>`元素的字体大小，就可以适配不同的屏幕。


**24、** js模块化分哪些阶段

- 无模块化
  
  js最初的作用只是进行表单验证或添加一些简单的动画，js文件通过`script`标签进行引用，没有模块化一说，随着前端复杂度提高想要引入更多的js文件就把多个`script`标签放在一起。
  ```
  　<script src="script1.js"></script>
　　<script src="script2.js"></script>
　　<script src="script3.js"></script>
  ```
  - 优点
    相对于把所有逻辑放入一个文件，这种引入多个js文件实现简单模块化的思想是进步的。
  - 缺点
    污染全局作用域，文件间依赖关系不明显。

- CommonJS规范
  CommonJS是一个JavaScript模块化规范，最初用于服务端的node。根据这个规范一个文件就是一个模块，其内部定义的变量函数只属于这个模块而不对外暴露。CommonJS通过export或module.exports来导出需要对外提供的接口，通过require方法来同步加载所要依赖的模块。

  - 模块定义
  ```
  // util.js
  var x = 0;
  var add = function (value) {
    return value + x;
  };
  module.exports.x = x;
  module.exports.add = add;

  ```
  - 模块使用
  ```
   var util = require(./util.js); 
   console.log(util.x); // 0
   console.log(util.add(1)); // 1
  ```

  - 优点
    解决了全局污染及模块间依赖的问题
  - 缺点
    CommonJS为同步加载，在服务端因其文件都在本地，同步加载没有问题，但在浏览器端文件需要异步加载 CommonJS就不再适用了。

- AMD规范
  AMD(Asynchronous Module Definition)规范为异步加载模块，并允许指定回调函数，实现AMD规范的加载器JS主要有两个require.js 和 curl.js。
  AMD标准中定义了两个API，define和require: 
  - 模块定义: define(id, [depends], callback)

  ```
  //math.js，定义了一个math模块
  define(function () {
    var add = function (x, y) {
      return x + y;
    }
    return {
      add: add,
    };
  });

  ```
  - 模块使用: require([module], callback)
  ```
    require(['math'], function (math){
      console.log(math.add(1,1));
    });
        
  ```

  - 优点
    适合在浏览器环境中异步加载模块，并可以并行加载多个模块。
  - 缺点
    提高了开发成本，且不能按需加载，而是必须提前加载所有的依赖。



- CMD规范
  CMD(Common Module Definition)规范是seajs推崇的规范，与requirejs类似，其不同点在于其加载模式为按需加载。

  ```
  define(function(require, exports, module) {
    var a = require('pdf.js');
    a.doSomething();
    // 依赖就近书写，什么时候用到什么时候引入
    var b = require('./b');
    b.doSomething();
  });
  ```

  - 优点
    实现了异步加载模块，并可以按需加载。
  - 缺点
    依赖SPM打包，模块的加载逻辑偏重。

- ES6模块化
  前面的模块化方法都是社区自己实现的，而ES6的模块化方案是真正的规范。在ES6中通过import关键字引入模块，export关键字导出模块，目前浏览器尚不支持es6因此需要用babel将代码转换为广泛支持的require。
  ```
    import React, { Component } from 'react';
    import Counter from '../counter';

    class Home extends Component {
      render() {
        return (
          <div>
            <Counter />
          </div>
        );
      }
    }

    export default Home;
  ```


**25、** 不用第三个变量，直接交换两个变量的值

- 方法1: 利用技巧
  
```
  var a = 5;
  var b = 6;
  a = a + b;
  b = a - b;
  a = a - b;

  console.log(a); // 6
  console.log(b); // 5
```

- 方法2: 利用位运算
  位运算当且仅当只有一个表达式的某位上为1时，结果的该位才为1。否则结果的该位为0。

```
  var a = 5; // 二进制101
  var b = 6; // 二进制110
  a = a^b;
=> 
  a = 101
      110
      ---
      011

  b = a^b;

=>
  b = 011
      110
      ---
      101
  
  a = a^b;
=>
  a = 011
      101
      ---
      110

  console.log(a); // 6
  console.log(b); // 5
```
  
**26、** CSS创建平移动画

  
```
  width: 100px;
    height: 30px;
    position: absolute;
    background: blue;
    left: 0;
    top: 0;
    animation: move 3s ease infinite; 
  
    @keyframes move {
      50% {
        left: 100px;
        top: 100px;
      }
    }
    或
    @keyframes move {
      50% {
        transform: translate(100px, 100px);
      }
    }
```

**27、** js选择select下的option

```
<select>
  <option value="option1">1</option>
  <option value="option2">2</option>
</select>

const selectNode = document.querySelector('select');
// 1.设置value的值等于option的value来选中option
selectNode.value = option2;

// 2.设置selectedIndex来选中option
selectNode.selectedIndex = 1;

```

**28、** CSS实现超出部分内容显示...

```
{
  //需限制其宽度
  max-width: 100px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```


    






